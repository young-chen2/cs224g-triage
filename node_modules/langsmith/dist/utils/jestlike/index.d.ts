/// <reference types="jest" />
import { KVMap } from "../../schemas.js";
import { toBeRelativeCloseTo, toBeAbsoluteCloseTo, toBeSemanticCloseTo } from "./matchers.js";
import { SimpleEvaluationResult } from "./types.js";
import type { LangSmithJestlikeWrapperConfig, LangSmithJestlikeWrapperParams, LangSmithJestDescribeWrapper } from "./types.js";
export declare const STRIP_ANSI_REGEX: RegExp;
export declare const TEST_ID_DELIMITER = ", test_id=";
export declare function logFeedback(feedback: SimpleEvaluationResult, config?: {
    sourceRunId?: string;
}): void;
export declare function logOutputs(output: Record<string, unknown>): void;
export declare function objectHash(obj: KVMap, depth?: number): string;
export declare function generateWrapperFromJestlikeMethods(methods: Record<string, any>, testRunnerName: string): {
    test: (<I extends Record<string, any> = Record<string, any>, O extends Record<string, any> = Record<string, any>>(name: string, lsParams: LangSmithJestlikeWrapperParams<I, O>, testFn: (data: {
        inputs: I;
        referenceOutputs?: O;
    } & Record<string, any>) => unknown | Promise<unknown>, timeout?: number) => void) & {
        only: (<I extends Record<string, any> = Record<string, any>, O extends Record<string, any> = Record<string, any>>(name: string, lsParams: LangSmithJestlikeWrapperParams<I, O>, testFn: (data: {
            inputs: I;
            referenceOutputs?: O;
        } & Record<string, any>) => unknown | Promise<unknown>, timeout?: number) => void) & {
            each: <I_1 extends KVMap, O_1 extends KVMap>(table: ({
                inputs: I_1;
                referenceOutputs: O_1;
            } & Record<string, any>)[], config?: LangSmithJestlikeWrapperConfig) => (name: string, fn: (params: {
                inputs: I_1;
                referenceOutputs?: O_1 | undefined;
            } & Record<string, any>) => unknown | Promise<unknown>, timeout?: number) => void;
        };
        skip: (<I extends Record<string, any> = Record<string, any>, O extends Record<string, any> = Record<string, any>>(name: string, lsParams: LangSmithJestlikeWrapperParams<I, O>, testFn: (data: {
            inputs: I;
            referenceOutputs?: O;
        } & Record<string, any>) => unknown | Promise<unknown>, timeout?: number) => void) & {
            each: <I_1 extends KVMap, O_1 extends KVMap>(table: ({
                inputs: I_1;
                referenceOutputs: O_1;
            } & Record<string, any>)[], config?: LangSmithJestlikeWrapperConfig) => (name: string, fn: (params: {
                inputs: I_1;
                referenceOutputs?: O_1 | undefined;
            } & Record<string, any>) => unknown | Promise<unknown>, timeout?: number) => void;
        };
        each: <I_1 extends KVMap, O_1 extends KVMap>(table: ({
            inputs: I_1;
            referenceOutputs: O_1;
        } & Record<string, any>)[], config?: LangSmithJestlikeWrapperConfig) => (name: string, fn: (params: {
            inputs: I_1;
            referenceOutputs?: O_1 | undefined;
        } & Record<string, any>) => unknown | Promise<unknown>, timeout?: number) => void;
    };
    it: (<I extends Record<string, any> = Record<string, any>, O extends Record<string, any> = Record<string, any>>(name: string, lsParams: LangSmithJestlikeWrapperParams<I, O>, testFn: (data: {
        inputs: I;
        referenceOutputs?: O;
    } & Record<string, any>) => unknown | Promise<unknown>, timeout?: number) => void) & {
        only: (<I extends Record<string, any> = Record<string, any>, O extends Record<string, any> = Record<string, any>>(name: string, lsParams: LangSmithJestlikeWrapperParams<I, O>, testFn: (data: {
            inputs: I;
            referenceOutputs?: O;
        } & Record<string, any>) => unknown | Promise<unknown>, timeout?: number) => void) & {
            each: <I_1 extends KVMap, O_1 extends KVMap>(table: ({
                inputs: I_1;
                referenceOutputs: O_1;
            } & Record<string, any>)[], config?: LangSmithJestlikeWrapperConfig) => (name: string, fn: (params: {
                inputs: I_1;
                referenceOutputs?: O_1 | undefined;
            } & Record<string, any>) => unknown | Promise<unknown>, timeout?: number) => void;
        };
        skip: (<I extends Record<string, any> = Record<string, any>, O extends Record<string, any> = Record<string, any>>(name: string, lsParams: LangSmithJestlikeWrapperParams<I, O>, testFn: (data: {
            inputs: I;
            referenceOutputs?: O;
        } & Record<string, any>) => unknown | Promise<unknown>, timeout?: number) => void) & {
            each: <I_1 extends KVMap, O_1 extends KVMap>(table: ({
                inputs: I_1;
                referenceOutputs: O_1;
            } & Record<string, any>)[], config?: LangSmithJestlikeWrapperConfig) => (name: string, fn: (params: {
                inputs: I_1;
                referenceOutputs?: O_1 | undefined;
            } & Record<string, any>) => unknown | Promise<unknown>, timeout?: number) => void;
        };
        each: <I_1 extends KVMap, O_1 extends KVMap>(table: ({
            inputs: I_1;
            referenceOutputs: O_1;
        } & Record<string, any>)[], config?: LangSmithJestlikeWrapperConfig) => (name: string, fn: (params: {
            inputs: I_1;
            referenceOutputs?: O_1 | undefined;
        } & Record<string, any>) => unknown | Promise<unknown>, timeout?: number) => void;
    };
    describe: LangSmithJestDescribeWrapper & {
        only: LangSmithJestDescribeWrapper;
        skip: LangSmithJestDescribeWrapper;
    };
    expect: jest.Expect;
    toBeRelativeCloseTo: typeof toBeRelativeCloseTo;
    toBeAbsoluteCloseTo: typeof toBeAbsoluteCloseTo;
    toBeSemanticCloseTo: typeof toBeSemanticCloseTo;
};
