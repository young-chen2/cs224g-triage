{"ast":null,"code":"import { deepCompareStrict } from './deep-compare-strict.js';\nimport { dereference } from './dereference.js';\nimport { format } from './format.js';\nimport { encodePointer } from './pointer.js';\nimport { ucs2length } from './ucs2-length.js';\nexport function validate(instance, schema, draft = '2019-09', lookup = dereference(schema), shortCircuit = true, recursiveAnchor = null, instanceLocation = '#', schemaLocation = '#', evaluated = Object.create(null)) {\n  if (schema === true) {\n    return {\n      valid: true,\n      errors: []\n    };\n  }\n  if (schema === false) {\n    return {\n      valid: false,\n      errors: [{\n        instanceLocation,\n        keyword: 'false',\n        keywordLocation: instanceLocation,\n        error: 'False boolean schema.'\n      }]\n    };\n  }\n  const rawInstanceType = typeof instance;\n  let instanceType;\n  switch (rawInstanceType) {\n    case 'boolean':\n    case 'number':\n    case 'string':\n      instanceType = rawInstanceType;\n      break;\n    case 'object':\n      if (instance === null) {\n        instanceType = 'null';\n      } else if (Array.isArray(instance)) {\n        instanceType = 'array';\n      } else {\n        instanceType = 'object';\n      }\n      break;\n    default:\n      throw new Error(`Instances of \"${rawInstanceType}\" type are not supported.`);\n  }\n  const {\n    $ref,\n    $recursiveRef,\n    $recursiveAnchor,\n    type: $type,\n    const: $const,\n    enum: $enum,\n    required: $required,\n    not: $not,\n    anyOf: $anyOf,\n    allOf: $allOf,\n    oneOf: $oneOf,\n    if: $if,\n    then: $then,\n    else: $else,\n    format: $format,\n    properties: $properties,\n    patternProperties: $patternProperties,\n    additionalProperties: $additionalProperties,\n    unevaluatedProperties: $unevaluatedProperties,\n    minProperties: $minProperties,\n    maxProperties: $maxProperties,\n    propertyNames: $propertyNames,\n    dependentRequired: $dependentRequired,\n    dependentSchemas: $dependentSchemas,\n    dependencies: $dependencies,\n    prefixItems: $prefixItems,\n    items: $items,\n    additionalItems: $additionalItems,\n    unevaluatedItems: $unevaluatedItems,\n    contains: $contains,\n    minContains: $minContains,\n    maxContains: $maxContains,\n    minItems: $minItems,\n    maxItems: $maxItems,\n    uniqueItems: $uniqueItems,\n    minimum: $minimum,\n    maximum: $maximum,\n    exclusiveMinimum: $exclusiveMinimum,\n    exclusiveMaximum: $exclusiveMaximum,\n    multipleOf: $multipleOf,\n    minLength: $minLength,\n    maxLength: $maxLength,\n    pattern: $pattern,\n    __absolute_ref__,\n    __absolute_recursive_ref__\n  } = schema;\n  const errors = [];\n  if ($recursiveAnchor === true && recursiveAnchor === null) {\n    recursiveAnchor = schema;\n  }\n  if ($recursiveRef === '#') {\n    const refSchema = recursiveAnchor === null ? lookup[__absolute_recursive_ref__] : recursiveAnchor;\n    const keywordLocation = `${schemaLocation}/$recursiveRef`;\n    const result = validate(instance, recursiveAnchor === null ? schema : recursiveAnchor, draft, lookup, shortCircuit, refSchema, instanceLocation, keywordLocation, evaluated);\n    if (!result.valid) {\n      errors.push({\n        instanceLocation,\n        keyword: '$recursiveRef',\n        keywordLocation,\n        error: 'A subschema had errors.'\n      }, ...result.errors);\n    }\n  }\n  if ($ref !== undefined) {\n    const uri = __absolute_ref__ || $ref;\n    const refSchema = lookup[uri];\n    if (refSchema === undefined) {\n      let message = `Unresolved $ref \"${$ref}\".`;\n      if (__absolute_ref__ && __absolute_ref__ !== $ref) {\n        message += `  Absolute URI \"${__absolute_ref__}\".`;\n      }\n      message += `\\nKnown schemas:\\n- ${Object.keys(lookup).join('\\n- ')}`;\n      throw new Error(message);\n    }\n    const keywordLocation = `${schemaLocation}/$ref`;\n    const result = validate(instance, refSchema, draft, lookup, shortCircuit, recursiveAnchor, instanceLocation, keywordLocation, evaluated);\n    if (!result.valid) {\n      errors.push({\n        instanceLocation,\n        keyword: '$ref',\n        keywordLocation,\n        error: 'A subschema had errors.'\n      }, ...result.errors);\n    }\n    if (draft === '4' || draft === '7') {\n      return {\n        valid: errors.length === 0,\n        errors\n      };\n    }\n  }\n  if (Array.isArray($type)) {\n    let length = $type.length;\n    let valid = false;\n    for (let i = 0; i < length; i++) {\n      if (instanceType === $type[i] || $type[i] === 'integer' && instanceType === 'number' && instance % 1 === 0 && instance === instance) {\n        valid = true;\n        break;\n      }\n    }\n    if (!valid) {\n      errors.push({\n        instanceLocation,\n        keyword: 'type',\n        keywordLocation: `${schemaLocation}/type`,\n        error: `Instance type \"${instanceType}\" is invalid. Expected \"${$type.join('\", \"')}\".`\n      });\n    }\n  } else if ($type === 'integer') {\n    if (instanceType !== 'number' || instance % 1 || instance !== instance) {\n      errors.push({\n        instanceLocation,\n        keyword: 'type',\n        keywordLocation: `${schemaLocation}/type`,\n        error: `Instance type \"${instanceType}\" is invalid. Expected \"${$type}\".`\n      });\n    }\n  } else if ($type !== undefined && instanceType !== $type) {\n    errors.push({\n      instanceLocation,\n      keyword: 'type',\n      keywordLocation: `${schemaLocation}/type`,\n      error: `Instance type \"${instanceType}\" is invalid. Expected \"${$type}\".`\n    });\n  }\n  if ($const !== undefined) {\n    if (instanceType === 'object' || instanceType === 'array') {\n      if (!deepCompareStrict(instance, $const)) {\n        errors.push({\n          instanceLocation,\n          keyword: 'const',\n          keywordLocation: `${schemaLocation}/const`,\n          error: `Instance does not match ${JSON.stringify($const)}.`\n        });\n      }\n    } else if (instance !== $const) {\n      errors.push({\n        instanceLocation,\n        keyword: 'const',\n        keywordLocation: `${schemaLocation}/const`,\n        error: `Instance does not match ${JSON.stringify($const)}.`\n      });\n    }\n  }\n  if ($enum !== undefined) {\n    if (instanceType === 'object' || instanceType === 'array') {\n      if (!$enum.some(value => deepCompareStrict(instance, value))) {\n        errors.push({\n          instanceLocation,\n          keyword: 'enum',\n          keywordLocation: `${schemaLocation}/enum`,\n          error: `Instance does not match any of ${JSON.stringify($enum)}.`\n        });\n      }\n    } else if (!$enum.some(value => instance === value)) {\n      errors.push({\n        instanceLocation,\n        keyword: 'enum',\n        keywordLocation: `${schemaLocation}/enum`,\n        error: `Instance does not match any of ${JSON.stringify($enum)}.`\n      });\n    }\n  }\n  if ($not !== undefined) {\n    const keywordLocation = `${schemaLocation}/not`;\n    const result = validate(instance, $not, draft, lookup, shortCircuit, recursiveAnchor, instanceLocation, keywordLocation);\n    if (result.valid) {\n      errors.push({\n        instanceLocation,\n        keyword: 'not',\n        keywordLocation,\n        error: 'Instance matched \"not\" schema.'\n      });\n    }\n  }\n  let subEvaluateds = [];\n  if ($anyOf !== undefined) {\n    const keywordLocation = `${schemaLocation}/anyOf`;\n    const errorsLength = errors.length;\n    let anyValid = false;\n    for (let i = 0; i < $anyOf.length; i++) {\n      const subSchema = $anyOf[i];\n      const subEvaluated = Object.create(evaluated);\n      const result = validate(instance, subSchema, draft, lookup, shortCircuit, $recursiveAnchor === true ? recursiveAnchor : null, instanceLocation, `${keywordLocation}/${i}`, subEvaluated);\n      errors.push(...result.errors);\n      anyValid = anyValid || result.valid;\n      if (result.valid) {\n        subEvaluateds.push(subEvaluated);\n      }\n    }\n    if (anyValid) {\n      errors.length = errorsLength;\n    } else {\n      errors.splice(errorsLength, 0, {\n        instanceLocation,\n        keyword: 'anyOf',\n        keywordLocation,\n        error: 'Instance does not match any subschemas.'\n      });\n    }\n  }\n  if ($allOf !== undefined) {\n    const keywordLocation = `${schemaLocation}/allOf`;\n    const errorsLength = errors.length;\n    let allValid = true;\n    for (let i = 0; i < $allOf.length; i++) {\n      const subSchema = $allOf[i];\n      const subEvaluated = Object.create(evaluated);\n      const result = validate(instance, subSchema, draft, lookup, shortCircuit, $recursiveAnchor === true ? recursiveAnchor : null, instanceLocation, `${keywordLocation}/${i}`, subEvaluated);\n      errors.push(...result.errors);\n      allValid = allValid && result.valid;\n      if (result.valid) {\n        subEvaluateds.push(subEvaluated);\n      }\n    }\n    if (allValid) {\n      errors.length = errorsLength;\n    } else {\n      errors.splice(errorsLength, 0, {\n        instanceLocation,\n        keyword: 'allOf',\n        keywordLocation,\n        error: `Instance does not match every subschema.`\n      });\n    }\n  }\n  if ($oneOf !== undefined) {\n    const keywordLocation = `${schemaLocation}/oneOf`;\n    const errorsLength = errors.length;\n    const matches = $oneOf.filter((subSchema, i) => {\n      const subEvaluated = Object.create(evaluated);\n      const result = validate(instance, subSchema, draft, lookup, shortCircuit, $recursiveAnchor === true ? recursiveAnchor : null, instanceLocation, `${keywordLocation}/${i}`, subEvaluated);\n      errors.push(...result.errors);\n      if (result.valid) {\n        subEvaluateds.push(subEvaluated);\n      }\n      return result.valid;\n    }).length;\n    if (matches === 1) {\n      errors.length = errorsLength;\n    } else {\n      errors.splice(errorsLength, 0, {\n        instanceLocation,\n        keyword: 'oneOf',\n        keywordLocation,\n        error: `Instance does not match exactly one subschema (${matches} matches).`\n      });\n    }\n  }\n  if (instanceType === 'object' || instanceType === 'array') {\n    Object.assign(evaluated, ...subEvaluateds);\n  }\n  if ($if !== undefined) {\n    const keywordLocation = `${schemaLocation}/if`;\n    const conditionResult = validate(instance, $if, draft, lookup, shortCircuit, recursiveAnchor, instanceLocation, keywordLocation, evaluated).valid;\n    if (conditionResult) {\n      if ($then !== undefined) {\n        const thenResult = validate(instance, $then, draft, lookup, shortCircuit, recursiveAnchor, instanceLocation, `${schemaLocation}/then`, evaluated);\n        if (!thenResult.valid) {\n          errors.push({\n            instanceLocation,\n            keyword: 'if',\n            keywordLocation,\n            error: `Instance does not match \"then\" schema.`\n          }, ...thenResult.errors);\n        }\n      }\n    } else if ($else !== undefined) {\n      const elseResult = validate(instance, $else, draft, lookup, shortCircuit, recursiveAnchor, instanceLocation, `${schemaLocation}/else`, evaluated);\n      if (!elseResult.valid) {\n        errors.push({\n          instanceLocation,\n          keyword: 'if',\n          keywordLocation,\n          error: `Instance does not match \"else\" schema.`\n        }, ...elseResult.errors);\n      }\n    }\n  }\n  if (instanceType === 'object') {\n    if ($required !== undefined) {\n      for (const key of $required) {\n        if (!(key in instance)) {\n          errors.push({\n            instanceLocation,\n            keyword: 'required',\n            keywordLocation: `${schemaLocation}/required`,\n            error: `Instance does not have required property \"${key}\".`\n          });\n        }\n      }\n    }\n    const keys = Object.keys(instance);\n    if ($minProperties !== undefined && keys.length < $minProperties) {\n      errors.push({\n        instanceLocation,\n        keyword: 'minProperties',\n        keywordLocation: `${schemaLocation}/minProperties`,\n        error: `Instance does not have at least ${$minProperties} properties.`\n      });\n    }\n    if ($maxProperties !== undefined && keys.length > $maxProperties) {\n      errors.push({\n        instanceLocation,\n        keyword: 'maxProperties',\n        keywordLocation: `${schemaLocation}/maxProperties`,\n        error: `Instance does not have at least ${$maxProperties} properties.`\n      });\n    }\n    if ($propertyNames !== undefined) {\n      const keywordLocation = `${schemaLocation}/propertyNames`;\n      for (const key in instance) {\n        const subInstancePointer = `${instanceLocation}/${encodePointer(key)}`;\n        const result = validate(key, $propertyNames, draft, lookup, shortCircuit, recursiveAnchor, subInstancePointer, keywordLocation);\n        if (!result.valid) {\n          errors.push({\n            instanceLocation,\n            keyword: 'propertyNames',\n            keywordLocation,\n            error: `Property name \"${key}\" does not match schema.`\n          }, ...result.errors);\n        }\n      }\n    }\n    if ($dependentRequired !== undefined) {\n      const keywordLocation = `${schemaLocation}/dependantRequired`;\n      for (const key in $dependentRequired) {\n        if (key in instance) {\n          const required = $dependentRequired[key];\n          for (const dependantKey of required) {\n            if (!(dependantKey in instance)) {\n              errors.push({\n                instanceLocation,\n                keyword: 'dependentRequired',\n                keywordLocation,\n                error: `Instance has \"${key}\" but does not have \"${dependantKey}\".`\n              });\n            }\n          }\n        }\n      }\n    }\n    if ($dependentSchemas !== undefined) {\n      for (const key in $dependentSchemas) {\n        const keywordLocation = `${schemaLocation}/dependentSchemas`;\n        if (key in instance) {\n          const result = validate(instance, $dependentSchemas[key], draft, lookup, shortCircuit, recursiveAnchor, instanceLocation, `${keywordLocation}/${encodePointer(key)}`, evaluated);\n          if (!result.valid) {\n            errors.push({\n              instanceLocation,\n              keyword: 'dependentSchemas',\n              keywordLocation,\n              error: `Instance has \"${key}\" but does not match dependant schema.`\n            }, ...result.errors);\n          }\n        }\n      }\n    }\n    if ($dependencies !== undefined) {\n      const keywordLocation = `${schemaLocation}/dependencies`;\n      for (const key in $dependencies) {\n        if (key in instance) {\n          const propsOrSchema = $dependencies[key];\n          if (Array.isArray(propsOrSchema)) {\n            for (const dependantKey of propsOrSchema) {\n              if (!(dependantKey in instance)) {\n                errors.push({\n                  instanceLocation,\n                  keyword: 'dependencies',\n                  keywordLocation,\n                  error: `Instance has \"${key}\" but does not have \"${dependantKey}\".`\n                });\n              }\n            }\n          } else {\n            const result = validate(instance, propsOrSchema, draft, lookup, shortCircuit, recursiveAnchor, instanceLocation, `${keywordLocation}/${encodePointer(key)}`);\n            if (!result.valid) {\n              errors.push({\n                instanceLocation,\n                keyword: 'dependencies',\n                keywordLocation,\n                error: `Instance has \"${key}\" but does not match dependant schema.`\n              }, ...result.errors);\n            }\n          }\n        }\n      }\n    }\n    const thisEvaluated = Object.create(null);\n    let stop = false;\n    if ($properties !== undefined) {\n      const keywordLocation = `${schemaLocation}/properties`;\n      for (const key in $properties) {\n        if (!(key in instance)) {\n          continue;\n        }\n        const subInstancePointer = `${instanceLocation}/${encodePointer(key)}`;\n        const result = validate(instance[key], $properties[key], draft, lookup, shortCircuit, recursiveAnchor, subInstancePointer, `${keywordLocation}/${encodePointer(key)}`);\n        if (result.valid) {\n          evaluated[key] = thisEvaluated[key] = true;\n        } else {\n          stop = shortCircuit;\n          errors.push({\n            instanceLocation,\n            keyword: 'properties',\n            keywordLocation,\n            error: `Property \"${key}\" does not match schema.`\n          }, ...result.errors);\n          if (stop) break;\n        }\n      }\n    }\n    if (!stop && $patternProperties !== undefined) {\n      const keywordLocation = `${schemaLocation}/patternProperties`;\n      for (const pattern in $patternProperties) {\n        const regex = new RegExp(pattern, 'u');\n        const subSchema = $patternProperties[pattern];\n        for (const key in instance) {\n          if (!regex.test(key)) {\n            continue;\n          }\n          const subInstancePointer = `${instanceLocation}/${encodePointer(key)}`;\n          const result = validate(instance[key], subSchema, draft, lookup, shortCircuit, recursiveAnchor, subInstancePointer, `${keywordLocation}/${encodePointer(pattern)}`);\n          if (result.valid) {\n            evaluated[key] = thisEvaluated[key] = true;\n          } else {\n            stop = shortCircuit;\n            errors.push({\n              instanceLocation,\n              keyword: 'patternProperties',\n              keywordLocation,\n              error: `Property \"${key}\" matches pattern \"${pattern}\" but does not match associated schema.`\n            }, ...result.errors);\n          }\n        }\n      }\n    }\n    if (!stop && $additionalProperties !== undefined) {\n      const keywordLocation = `${schemaLocation}/additionalProperties`;\n      for (const key in instance) {\n        if (thisEvaluated[key]) {\n          continue;\n        }\n        const subInstancePointer = `${instanceLocation}/${encodePointer(key)}`;\n        const result = validate(instance[key], $additionalProperties, draft, lookup, shortCircuit, recursiveAnchor, subInstancePointer, keywordLocation);\n        if (result.valid) {\n          evaluated[key] = true;\n        } else {\n          stop = shortCircuit;\n          errors.push({\n            instanceLocation,\n            keyword: 'additionalProperties',\n            keywordLocation,\n            error: `Property \"${key}\" does not match additional properties schema.`\n          }, ...result.errors);\n        }\n      }\n    } else if (!stop && $unevaluatedProperties !== undefined) {\n      const keywordLocation = `${schemaLocation}/unevaluatedProperties`;\n      for (const key in instance) {\n        if (!evaluated[key]) {\n          const subInstancePointer = `${instanceLocation}/${encodePointer(key)}`;\n          const result = validate(instance[key], $unevaluatedProperties, draft, lookup, shortCircuit, recursiveAnchor, subInstancePointer, keywordLocation);\n          if (result.valid) {\n            evaluated[key] = true;\n          } else {\n            errors.push({\n              instanceLocation,\n              keyword: 'unevaluatedProperties',\n              keywordLocation,\n              error: `Property \"${key}\" does not match unevaluated properties schema.`\n            }, ...result.errors);\n          }\n        }\n      }\n    }\n  } else if (instanceType === 'array') {\n    if ($maxItems !== undefined && instance.length > $maxItems) {\n      errors.push({\n        instanceLocation,\n        keyword: 'maxItems',\n        keywordLocation: `${schemaLocation}/maxItems`,\n        error: `Array has too many items (${instance.length} > ${$maxItems}).`\n      });\n    }\n    if ($minItems !== undefined && instance.length < $minItems) {\n      errors.push({\n        instanceLocation,\n        keyword: 'minItems',\n        keywordLocation: `${schemaLocation}/minItems`,\n        error: `Array has too few items (${instance.length} < ${$minItems}).`\n      });\n    }\n    const length = instance.length;\n    let i = 0;\n    let stop = false;\n    if ($prefixItems !== undefined) {\n      const keywordLocation = `${schemaLocation}/prefixItems`;\n      const length2 = Math.min($prefixItems.length, length);\n      for (; i < length2; i++) {\n        const result = validate(instance[i], $prefixItems[i], draft, lookup, shortCircuit, recursiveAnchor, `${instanceLocation}/${i}`, `${keywordLocation}/${i}`);\n        evaluated[i] = true;\n        if (!result.valid) {\n          stop = shortCircuit;\n          errors.push({\n            instanceLocation,\n            keyword: 'prefixItems',\n            keywordLocation,\n            error: `Items did not match schema.`\n          }, ...result.errors);\n          if (stop) break;\n        }\n      }\n    }\n    if ($items !== undefined) {\n      const keywordLocation = `${schemaLocation}/items`;\n      if (Array.isArray($items)) {\n        const length2 = Math.min($items.length, length);\n        for (; i < length2; i++) {\n          const result = validate(instance[i], $items[i], draft, lookup, shortCircuit, recursiveAnchor, `${instanceLocation}/${i}`, `${keywordLocation}/${i}`);\n          evaluated[i] = true;\n          if (!result.valid) {\n            stop = shortCircuit;\n            errors.push({\n              instanceLocation,\n              keyword: 'items',\n              keywordLocation,\n              error: `Items did not match schema.`\n            }, ...result.errors);\n            if (stop) break;\n          }\n        }\n      } else {\n        for (; i < length; i++) {\n          const result = validate(instance[i], $items, draft, lookup, shortCircuit, recursiveAnchor, `${instanceLocation}/${i}`, keywordLocation);\n          evaluated[i] = true;\n          if (!result.valid) {\n            stop = shortCircuit;\n            errors.push({\n              instanceLocation,\n              keyword: 'items',\n              keywordLocation,\n              error: `Items did not match schema.`\n            }, ...result.errors);\n            if (stop) break;\n          }\n        }\n      }\n      if (!stop && $additionalItems !== undefined) {\n        const keywordLocation = `${schemaLocation}/additionalItems`;\n        for (; i < length; i++) {\n          const result = validate(instance[i], $additionalItems, draft, lookup, shortCircuit, recursiveAnchor, `${instanceLocation}/${i}`, keywordLocation);\n          evaluated[i] = true;\n          if (!result.valid) {\n            stop = shortCircuit;\n            errors.push({\n              instanceLocation,\n              keyword: 'additionalItems',\n              keywordLocation,\n              error: `Items did not match additional items schema.`\n            }, ...result.errors);\n          }\n        }\n      }\n    }\n    if ($contains !== undefined) {\n      if (length === 0 && $minContains === undefined) {\n        errors.push({\n          instanceLocation,\n          keyword: 'contains',\n          keywordLocation: `${schemaLocation}/contains`,\n          error: `Array is empty. It must contain at least one item matching the schema.`\n        });\n      } else if ($minContains !== undefined && length < $minContains) {\n        errors.push({\n          instanceLocation,\n          keyword: 'minContains',\n          keywordLocation: `${schemaLocation}/minContains`,\n          error: `Array has less items (${length}) than minContains (${$minContains}).`\n        });\n      } else {\n        const keywordLocation = `${schemaLocation}/contains`;\n        const errorsLength = errors.length;\n        let contained = 0;\n        for (let j = 0; j < length; j++) {\n          const result = validate(instance[j], $contains, draft, lookup, shortCircuit, recursiveAnchor, `${instanceLocation}/${j}`, keywordLocation);\n          if (result.valid) {\n            evaluated[j] = true;\n            contained++;\n          } else {\n            errors.push(...result.errors);\n          }\n        }\n        if (contained >= ($minContains || 0)) {\n          errors.length = errorsLength;\n        }\n        if ($minContains === undefined && $maxContains === undefined && contained === 0) {\n          errors.splice(errorsLength, 0, {\n            instanceLocation,\n            keyword: 'contains',\n            keywordLocation,\n            error: `Array does not contain item matching schema.`\n          });\n        } else if ($minContains !== undefined && contained < $minContains) {\n          errors.push({\n            instanceLocation,\n            keyword: 'minContains',\n            keywordLocation: `${schemaLocation}/minContains`,\n            error: `Array must contain at least ${$minContains} items matching schema. Only ${contained} items were found.`\n          });\n        } else if ($maxContains !== undefined && contained > $maxContains) {\n          errors.push({\n            instanceLocation,\n            keyword: 'maxContains',\n            keywordLocation: `${schemaLocation}/maxContains`,\n            error: `Array may contain at most ${$maxContains} items matching schema. ${contained} items were found.`\n          });\n        }\n      }\n    }\n    if (!stop && $unevaluatedItems !== undefined) {\n      const keywordLocation = `${schemaLocation}/unevaluatedItems`;\n      for (i; i < length; i++) {\n        if (evaluated[i]) {\n          continue;\n        }\n        const result = validate(instance[i], $unevaluatedItems, draft, lookup, shortCircuit, recursiveAnchor, `${instanceLocation}/${i}`, keywordLocation);\n        evaluated[i] = true;\n        if (!result.valid) {\n          errors.push({\n            instanceLocation,\n            keyword: 'unevaluatedItems',\n            keywordLocation,\n            error: `Items did not match unevaluated items schema.`\n          }, ...result.errors);\n        }\n      }\n    }\n    if ($uniqueItems) {\n      for (let j = 0; j < length; j++) {\n        const a = instance[j];\n        const ao = typeof a === 'object' && a !== null;\n        for (let k = 0; k < length; k++) {\n          if (j === k) {\n            continue;\n          }\n          const b = instance[k];\n          const bo = typeof b === 'object' && b !== null;\n          if (a === b || ao && bo && deepCompareStrict(a, b)) {\n            errors.push({\n              instanceLocation,\n              keyword: 'uniqueItems',\n              keywordLocation: `${schemaLocation}/uniqueItems`,\n              error: `Duplicate items at indexes ${j} and ${k}.`\n            });\n            j = Number.MAX_SAFE_INTEGER;\n            k = Number.MAX_SAFE_INTEGER;\n          }\n        }\n      }\n    }\n  } else if (instanceType === 'number') {\n    if (draft === '4') {\n      if ($minimum !== undefined && ($exclusiveMinimum === true && instance <= $minimum || instance < $minimum)) {\n        errors.push({\n          instanceLocation,\n          keyword: 'minimum',\n          keywordLocation: `${schemaLocation}/minimum`,\n          error: `${instance} is less than ${$exclusiveMinimum ? 'or equal to ' : ''} ${$minimum}.`\n        });\n      }\n      if ($maximum !== undefined && ($exclusiveMaximum === true && instance >= $maximum || instance > $maximum)) {\n        errors.push({\n          instanceLocation,\n          keyword: 'maximum',\n          keywordLocation: `${schemaLocation}/maximum`,\n          error: `${instance} is greater than ${$exclusiveMaximum ? 'or equal to ' : ''} ${$maximum}.`\n        });\n      }\n    } else {\n      if ($minimum !== undefined && instance < $minimum) {\n        errors.push({\n          instanceLocation,\n          keyword: 'minimum',\n          keywordLocation: `${schemaLocation}/minimum`,\n          error: `${instance} is less than ${$minimum}.`\n        });\n      }\n      if ($maximum !== undefined && instance > $maximum) {\n        errors.push({\n          instanceLocation,\n          keyword: 'maximum',\n          keywordLocation: `${schemaLocation}/maximum`,\n          error: `${instance} is greater than ${$maximum}.`\n        });\n      }\n      if ($exclusiveMinimum !== undefined && instance <= $exclusiveMinimum) {\n        errors.push({\n          instanceLocation,\n          keyword: 'exclusiveMinimum',\n          keywordLocation: `${schemaLocation}/exclusiveMinimum`,\n          error: `${instance} is less than ${$exclusiveMinimum}.`\n        });\n      }\n      if ($exclusiveMaximum !== undefined && instance >= $exclusiveMaximum) {\n        errors.push({\n          instanceLocation,\n          keyword: 'exclusiveMaximum',\n          keywordLocation: `${schemaLocation}/exclusiveMaximum`,\n          error: `${instance} is greater than or equal to ${$exclusiveMaximum}.`\n        });\n      }\n    }\n    if ($multipleOf !== undefined) {\n      const remainder = instance % $multipleOf;\n      if (Math.abs(0 - remainder) >= 1.1920929e-7 && Math.abs($multipleOf - remainder) >= 1.1920929e-7) {\n        errors.push({\n          instanceLocation,\n          keyword: 'multipleOf',\n          keywordLocation: `${schemaLocation}/multipleOf`,\n          error: `${instance} is not a multiple of ${$multipleOf}.`\n        });\n      }\n    }\n  } else if (instanceType === 'string') {\n    const length = $minLength === undefined && $maxLength === undefined ? 0 : ucs2length(instance);\n    if ($minLength !== undefined && length < $minLength) {\n      errors.push({\n        instanceLocation,\n        keyword: 'minLength',\n        keywordLocation: `${schemaLocation}/minLength`,\n        error: `String is too short (${length} < ${$minLength}).`\n      });\n    }\n    if ($maxLength !== undefined && length > $maxLength) {\n      errors.push({\n        instanceLocation,\n        keyword: 'maxLength',\n        keywordLocation: `${schemaLocation}/maxLength`,\n        error: `String is too long (${length} > ${$maxLength}).`\n      });\n    }\n    if ($pattern !== undefined && !new RegExp($pattern, 'u').test(instance)) {\n      errors.push({\n        instanceLocation,\n        keyword: 'pattern',\n        keywordLocation: `${schemaLocation}/pattern`,\n        error: `String does not match pattern.`\n      });\n    }\n    if ($format !== undefined && format[$format] && !format[$format](instance)) {\n      errors.push({\n        instanceLocation,\n        keyword: 'format',\n        keywordLocation: `${schemaLocation}/format`,\n        error: `String does not match format \"${$format}\".`\n      });\n    }\n  }\n  return {\n    valid: errors.length === 0,\n    errors\n  };\n}","map":{"version":3,"names":["deepCompareStrict","dereference","format","encodePointer","ucs2length","validate","instance","schema","draft","lookup","shortCircuit","recursiveAnchor","instanceLocation","schemaLocation","evaluated","Object","create","valid","errors","keyword","keywordLocation","error","rawInstanceType","instanceType","Array","isArray","Error","$ref","$recursiveRef","$recursiveAnchor","type","$type","const","$const","enum","$enum","required","$required","not","$not","anyOf","$anyOf","allOf","$allOf","oneOf","$oneOf","if","$if","then","$then","else","$else","$format","properties","$properties","patternProperties","$patternProperties","additionalProperties","$additionalProperties","unevaluatedProperties","$unevaluatedProperties","minProperties","$minProperties","maxProperties","$maxProperties","propertyNames","$propertyNames","dependentRequired","$dependentRequired","dependentSchemas","$dependentSchemas","dependencies","$dependencies","prefixItems","$prefixItems","items","$items","additionalItems","$additionalItems","unevaluatedItems","$unevaluatedItems","contains","$contains","minContains","$minContains","maxContains","$maxContains","minItems","$minItems","maxItems","$maxItems","uniqueItems","$uniqueItems","minimum","$minimum","maximum","$maximum","exclusiveMinimum","$exclusiveMinimum","exclusiveMaximum","$exclusiveMaximum","multipleOf","$multipleOf","minLength","$minLength","maxLength","$maxLength","pattern","$pattern","__absolute_ref__","__absolute_recursive_ref__","refSchema","result","push","undefined","uri","message","keys","join","length","i","JSON","stringify","some","value","subEvaluateds","errorsLength","anyValid","subSchema","subEvaluated","splice","allValid","matches","filter","assign","conditionResult","thenResult","elseResult","key","subInstancePointer","dependantKey","propsOrSchema","thisEvaluated","stop","regex","RegExp","test","length2","Math","min","contained","j","a","ao","k","b","bo","Number","MAX_SAFE_INTEGER","remainder","abs"],"sources":["/Users/youngchen/Downloads/cs224g-triage/node_modules/@cfworker/json-schema/dist/esm/validate.js"],"sourcesContent":["import { deepCompareStrict } from './deep-compare-strict.js';\nimport { dereference } from './dereference.js';\nimport { format } from './format.js';\nimport { encodePointer } from './pointer.js';\nimport { ucs2length } from './ucs2-length.js';\nexport function validate(instance, schema, draft = '2019-09', lookup = dereference(schema), shortCircuit = true, recursiveAnchor = null, instanceLocation = '#', schemaLocation = '#', evaluated = Object.create(null)) {\n    if (schema === true) {\n        return { valid: true, errors: [] };\n    }\n    if (schema === false) {\n        return {\n            valid: false,\n            errors: [\n                {\n                    instanceLocation,\n                    keyword: 'false',\n                    keywordLocation: instanceLocation,\n                    error: 'False boolean schema.'\n                }\n            ]\n        };\n    }\n    const rawInstanceType = typeof instance;\n    let instanceType;\n    switch (rawInstanceType) {\n        case 'boolean':\n        case 'number':\n        case 'string':\n            instanceType = rawInstanceType;\n            break;\n        case 'object':\n            if (instance === null) {\n                instanceType = 'null';\n            }\n            else if (Array.isArray(instance)) {\n                instanceType = 'array';\n            }\n            else {\n                instanceType = 'object';\n            }\n            break;\n        default:\n            throw new Error(`Instances of \"${rawInstanceType}\" type are not supported.`);\n    }\n    const { $ref, $recursiveRef, $recursiveAnchor, type: $type, const: $const, enum: $enum, required: $required, not: $not, anyOf: $anyOf, allOf: $allOf, oneOf: $oneOf, if: $if, then: $then, else: $else, format: $format, properties: $properties, patternProperties: $patternProperties, additionalProperties: $additionalProperties, unevaluatedProperties: $unevaluatedProperties, minProperties: $minProperties, maxProperties: $maxProperties, propertyNames: $propertyNames, dependentRequired: $dependentRequired, dependentSchemas: $dependentSchemas, dependencies: $dependencies, prefixItems: $prefixItems, items: $items, additionalItems: $additionalItems, unevaluatedItems: $unevaluatedItems, contains: $contains, minContains: $minContains, maxContains: $maxContains, minItems: $minItems, maxItems: $maxItems, uniqueItems: $uniqueItems, minimum: $minimum, maximum: $maximum, exclusiveMinimum: $exclusiveMinimum, exclusiveMaximum: $exclusiveMaximum, multipleOf: $multipleOf, minLength: $minLength, maxLength: $maxLength, pattern: $pattern, __absolute_ref__, __absolute_recursive_ref__ } = schema;\n    const errors = [];\n    if ($recursiveAnchor === true && recursiveAnchor === null) {\n        recursiveAnchor = schema;\n    }\n    if ($recursiveRef === '#') {\n        const refSchema = recursiveAnchor === null\n            ? lookup[__absolute_recursive_ref__]\n            : recursiveAnchor;\n        const keywordLocation = `${schemaLocation}/$recursiveRef`;\n        const result = validate(instance, recursiveAnchor === null ? schema : recursiveAnchor, draft, lookup, shortCircuit, refSchema, instanceLocation, keywordLocation, evaluated);\n        if (!result.valid) {\n            errors.push({\n                instanceLocation,\n                keyword: '$recursiveRef',\n                keywordLocation,\n                error: 'A subschema had errors.'\n            }, ...result.errors);\n        }\n    }\n    if ($ref !== undefined) {\n        const uri = __absolute_ref__ || $ref;\n        const refSchema = lookup[uri];\n        if (refSchema === undefined) {\n            let message = `Unresolved $ref \"${$ref}\".`;\n            if (__absolute_ref__ && __absolute_ref__ !== $ref) {\n                message += `  Absolute URI \"${__absolute_ref__}\".`;\n            }\n            message += `\\nKnown schemas:\\n- ${Object.keys(lookup).join('\\n- ')}`;\n            throw new Error(message);\n        }\n        const keywordLocation = `${schemaLocation}/$ref`;\n        const result = validate(instance, refSchema, draft, lookup, shortCircuit, recursiveAnchor, instanceLocation, keywordLocation, evaluated);\n        if (!result.valid) {\n            errors.push({\n                instanceLocation,\n                keyword: '$ref',\n                keywordLocation,\n                error: 'A subschema had errors.'\n            }, ...result.errors);\n        }\n        if (draft === '4' || draft === '7') {\n            return { valid: errors.length === 0, errors };\n        }\n    }\n    if (Array.isArray($type)) {\n        let length = $type.length;\n        let valid = false;\n        for (let i = 0; i < length; i++) {\n            if (instanceType === $type[i] ||\n                ($type[i] === 'integer' &&\n                    instanceType === 'number' &&\n                    instance % 1 === 0 &&\n                    instance === instance)) {\n                valid = true;\n                break;\n            }\n        }\n        if (!valid) {\n            errors.push({\n                instanceLocation,\n                keyword: 'type',\n                keywordLocation: `${schemaLocation}/type`,\n                error: `Instance type \"${instanceType}\" is invalid. Expected \"${$type.join('\", \"')}\".`\n            });\n        }\n    }\n    else if ($type === 'integer') {\n        if (instanceType !== 'number' || instance % 1 || instance !== instance) {\n            errors.push({\n                instanceLocation,\n                keyword: 'type',\n                keywordLocation: `${schemaLocation}/type`,\n                error: `Instance type \"${instanceType}\" is invalid. Expected \"${$type}\".`\n            });\n        }\n    }\n    else if ($type !== undefined && instanceType !== $type) {\n        errors.push({\n            instanceLocation,\n            keyword: 'type',\n            keywordLocation: `${schemaLocation}/type`,\n            error: `Instance type \"${instanceType}\" is invalid. Expected \"${$type}\".`\n        });\n    }\n    if ($const !== undefined) {\n        if (instanceType === 'object' || instanceType === 'array') {\n            if (!deepCompareStrict(instance, $const)) {\n                errors.push({\n                    instanceLocation,\n                    keyword: 'const',\n                    keywordLocation: `${schemaLocation}/const`,\n                    error: `Instance does not match ${JSON.stringify($const)}.`\n                });\n            }\n        }\n        else if (instance !== $const) {\n            errors.push({\n                instanceLocation,\n                keyword: 'const',\n                keywordLocation: `${schemaLocation}/const`,\n                error: `Instance does not match ${JSON.stringify($const)}.`\n            });\n        }\n    }\n    if ($enum !== undefined) {\n        if (instanceType === 'object' || instanceType === 'array') {\n            if (!$enum.some(value => deepCompareStrict(instance, value))) {\n                errors.push({\n                    instanceLocation,\n                    keyword: 'enum',\n                    keywordLocation: `${schemaLocation}/enum`,\n                    error: `Instance does not match any of ${JSON.stringify($enum)}.`\n                });\n            }\n        }\n        else if (!$enum.some(value => instance === value)) {\n            errors.push({\n                instanceLocation,\n                keyword: 'enum',\n                keywordLocation: `${schemaLocation}/enum`,\n                error: `Instance does not match any of ${JSON.stringify($enum)}.`\n            });\n        }\n    }\n    if ($not !== undefined) {\n        const keywordLocation = `${schemaLocation}/not`;\n        const result = validate(instance, $not, draft, lookup, shortCircuit, recursiveAnchor, instanceLocation, keywordLocation);\n        if (result.valid) {\n            errors.push({\n                instanceLocation,\n                keyword: 'not',\n                keywordLocation,\n                error: 'Instance matched \"not\" schema.'\n            });\n        }\n    }\n    let subEvaluateds = [];\n    if ($anyOf !== undefined) {\n        const keywordLocation = `${schemaLocation}/anyOf`;\n        const errorsLength = errors.length;\n        let anyValid = false;\n        for (let i = 0; i < $anyOf.length; i++) {\n            const subSchema = $anyOf[i];\n            const subEvaluated = Object.create(evaluated);\n            const result = validate(instance, subSchema, draft, lookup, shortCircuit, $recursiveAnchor === true ? recursiveAnchor : null, instanceLocation, `${keywordLocation}/${i}`, subEvaluated);\n            errors.push(...result.errors);\n            anyValid = anyValid || result.valid;\n            if (result.valid) {\n                subEvaluateds.push(subEvaluated);\n            }\n        }\n        if (anyValid) {\n            errors.length = errorsLength;\n        }\n        else {\n            errors.splice(errorsLength, 0, {\n                instanceLocation,\n                keyword: 'anyOf',\n                keywordLocation,\n                error: 'Instance does not match any subschemas.'\n            });\n        }\n    }\n    if ($allOf !== undefined) {\n        const keywordLocation = `${schemaLocation}/allOf`;\n        const errorsLength = errors.length;\n        let allValid = true;\n        for (let i = 0; i < $allOf.length; i++) {\n            const subSchema = $allOf[i];\n            const subEvaluated = Object.create(evaluated);\n            const result = validate(instance, subSchema, draft, lookup, shortCircuit, $recursiveAnchor === true ? recursiveAnchor : null, instanceLocation, `${keywordLocation}/${i}`, subEvaluated);\n            errors.push(...result.errors);\n            allValid = allValid && result.valid;\n            if (result.valid) {\n                subEvaluateds.push(subEvaluated);\n            }\n        }\n        if (allValid) {\n            errors.length = errorsLength;\n        }\n        else {\n            errors.splice(errorsLength, 0, {\n                instanceLocation,\n                keyword: 'allOf',\n                keywordLocation,\n                error: `Instance does not match every subschema.`\n            });\n        }\n    }\n    if ($oneOf !== undefined) {\n        const keywordLocation = `${schemaLocation}/oneOf`;\n        const errorsLength = errors.length;\n        const matches = $oneOf.filter((subSchema, i) => {\n            const subEvaluated = Object.create(evaluated);\n            const result = validate(instance, subSchema, draft, lookup, shortCircuit, $recursiveAnchor === true ? recursiveAnchor : null, instanceLocation, `${keywordLocation}/${i}`, subEvaluated);\n            errors.push(...result.errors);\n            if (result.valid) {\n                subEvaluateds.push(subEvaluated);\n            }\n            return result.valid;\n        }).length;\n        if (matches === 1) {\n            errors.length = errorsLength;\n        }\n        else {\n            errors.splice(errorsLength, 0, {\n                instanceLocation,\n                keyword: 'oneOf',\n                keywordLocation,\n                error: `Instance does not match exactly one subschema (${matches} matches).`\n            });\n        }\n    }\n    if (instanceType === 'object' || instanceType === 'array') {\n        Object.assign(evaluated, ...subEvaluateds);\n    }\n    if ($if !== undefined) {\n        const keywordLocation = `${schemaLocation}/if`;\n        const conditionResult = validate(instance, $if, draft, lookup, shortCircuit, recursiveAnchor, instanceLocation, keywordLocation, evaluated).valid;\n        if (conditionResult) {\n            if ($then !== undefined) {\n                const thenResult = validate(instance, $then, draft, lookup, shortCircuit, recursiveAnchor, instanceLocation, `${schemaLocation}/then`, evaluated);\n                if (!thenResult.valid) {\n                    errors.push({\n                        instanceLocation,\n                        keyword: 'if',\n                        keywordLocation,\n                        error: `Instance does not match \"then\" schema.`\n                    }, ...thenResult.errors);\n                }\n            }\n        }\n        else if ($else !== undefined) {\n            const elseResult = validate(instance, $else, draft, lookup, shortCircuit, recursiveAnchor, instanceLocation, `${schemaLocation}/else`, evaluated);\n            if (!elseResult.valid) {\n                errors.push({\n                    instanceLocation,\n                    keyword: 'if',\n                    keywordLocation,\n                    error: `Instance does not match \"else\" schema.`\n                }, ...elseResult.errors);\n            }\n        }\n    }\n    if (instanceType === 'object') {\n        if ($required !== undefined) {\n            for (const key of $required) {\n                if (!(key in instance)) {\n                    errors.push({\n                        instanceLocation,\n                        keyword: 'required',\n                        keywordLocation: `${schemaLocation}/required`,\n                        error: `Instance does not have required property \"${key}\".`\n                    });\n                }\n            }\n        }\n        const keys = Object.keys(instance);\n        if ($minProperties !== undefined && keys.length < $minProperties) {\n            errors.push({\n                instanceLocation,\n                keyword: 'minProperties',\n                keywordLocation: `${schemaLocation}/minProperties`,\n                error: `Instance does not have at least ${$minProperties} properties.`\n            });\n        }\n        if ($maxProperties !== undefined && keys.length > $maxProperties) {\n            errors.push({\n                instanceLocation,\n                keyword: 'maxProperties',\n                keywordLocation: `${schemaLocation}/maxProperties`,\n                error: `Instance does not have at least ${$maxProperties} properties.`\n            });\n        }\n        if ($propertyNames !== undefined) {\n            const keywordLocation = `${schemaLocation}/propertyNames`;\n            for (const key in instance) {\n                const subInstancePointer = `${instanceLocation}/${encodePointer(key)}`;\n                const result = validate(key, $propertyNames, draft, lookup, shortCircuit, recursiveAnchor, subInstancePointer, keywordLocation);\n                if (!result.valid) {\n                    errors.push({\n                        instanceLocation,\n                        keyword: 'propertyNames',\n                        keywordLocation,\n                        error: `Property name \"${key}\" does not match schema.`\n                    }, ...result.errors);\n                }\n            }\n        }\n        if ($dependentRequired !== undefined) {\n            const keywordLocation = `${schemaLocation}/dependantRequired`;\n            for (const key in $dependentRequired) {\n                if (key in instance) {\n                    const required = $dependentRequired[key];\n                    for (const dependantKey of required) {\n                        if (!(dependantKey in instance)) {\n                            errors.push({\n                                instanceLocation,\n                                keyword: 'dependentRequired',\n                                keywordLocation,\n                                error: `Instance has \"${key}\" but does not have \"${dependantKey}\".`\n                            });\n                        }\n                    }\n                }\n            }\n        }\n        if ($dependentSchemas !== undefined) {\n            for (const key in $dependentSchemas) {\n                const keywordLocation = `${schemaLocation}/dependentSchemas`;\n                if (key in instance) {\n                    const result = validate(instance, $dependentSchemas[key], draft, lookup, shortCircuit, recursiveAnchor, instanceLocation, `${keywordLocation}/${encodePointer(key)}`, evaluated);\n                    if (!result.valid) {\n                        errors.push({\n                            instanceLocation,\n                            keyword: 'dependentSchemas',\n                            keywordLocation,\n                            error: `Instance has \"${key}\" but does not match dependant schema.`\n                        }, ...result.errors);\n                    }\n                }\n            }\n        }\n        if ($dependencies !== undefined) {\n            const keywordLocation = `${schemaLocation}/dependencies`;\n            for (const key in $dependencies) {\n                if (key in instance) {\n                    const propsOrSchema = $dependencies[key];\n                    if (Array.isArray(propsOrSchema)) {\n                        for (const dependantKey of propsOrSchema) {\n                            if (!(dependantKey in instance)) {\n                                errors.push({\n                                    instanceLocation,\n                                    keyword: 'dependencies',\n                                    keywordLocation,\n                                    error: `Instance has \"${key}\" but does not have \"${dependantKey}\".`\n                                });\n                            }\n                        }\n                    }\n                    else {\n                        const result = validate(instance, propsOrSchema, draft, lookup, shortCircuit, recursiveAnchor, instanceLocation, `${keywordLocation}/${encodePointer(key)}`);\n                        if (!result.valid) {\n                            errors.push({\n                                instanceLocation,\n                                keyword: 'dependencies',\n                                keywordLocation,\n                                error: `Instance has \"${key}\" but does not match dependant schema.`\n                            }, ...result.errors);\n                        }\n                    }\n                }\n            }\n        }\n        const thisEvaluated = Object.create(null);\n        let stop = false;\n        if ($properties !== undefined) {\n            const keywordLocation = `${schemaLocation}/properties`;\n            for (const key in $properties) {\n                if (!(key in instance)) {\n                    continue;\n                }\n                const subInstancePointer = `${instanceLocation}/${encodePointer(key)}`;\n                const result = validate(instance[key], $properties[key], draft, lookup, shortCircuit, recursiveAnchor, subInstancePointer, `${keywordLocation}/${encodePointer(key)}`);\n                if (result.valid) {\n                    evaluated[key] = thisEvaluated[key] = true;\n                }\n                else {\n                    stop = shortCircuit;\n                    errors.push({\n                        instanceLocation,\n                        keyword: 'properties',\n                        keywordLocation,\n                        error: `Property \"${key}\" does not match schema.`\n                    }, ...result.errors);\n                    if (stop)\n                        break;\n                }\n            }\n        }\n        if (!stop && $patternProperties !== undefined) {\n            const keywordLocation = `${schemaLocation}/patternProperties`;\n            for (const pattern in $patternProperties) {\n                const regex = new RegExp(pattern, 'u');\n                const subSchema = $patternProperties[pattern];\n                for (const key in instance) {\n                    if (!regex.test(key)) {\n                        continue;\n                    }\n                    const subInstancePointer = `${instanceLocation}/${encodePointer(key)}`;\n                    const result = validate(instance[key], subSchema, draft, lookup, shortCircuit, recursiveAnchor, subInstancePointer, `${keywordLocation}/${encodePointer(pattern)}`);\n                    if (result.valid) {\n                        evaluated[key] = thisEvaluated[key] = true;\n                    }\n                    else {\n                        stop = shortCircuit;\n                        errors.push({\n                            instanceLocation,\n                            keyword: 'patternProperties',\n                            keywordLocation,\n                            error: `Property \"${key}\" matches pattern \"${pattern}\" but does not match associated schema.`\n                        }, ...result.errors);\n                    }\n                }\n            }\n        }\n        if (!stop && $additionalProperties !== undefined) {\n            const keywordLocation = `${schemaLocation}/additionalProperties`;\n            for (const key in instance) {\n                if (thisEvaluated[key]) {\n                    continue;\n                }\n                const subInstancePointer = `${instanceLocation}/${encodePointer(key)}`;\n                const result = validate(instance[key], $additionalProperties, draft, lookup, shortCircuit, recursiveAnchor, subInstancePointer, keywordLocation);\n                if (result.valid) {\n                    evaluated[key] = true;\n                }\n                else {\n                    stop = shortCircuit;\n                    errors.push({\n                        instanceLocation,\n                        keyword: 'additionalProperties',\n                        keywordLocation,\n                        error: `Property \"${key}\" does not match additional properties schema.`\n                    }, ...result.errors);\n                }\n            }\n        }\n        else if (!stop && $unevaluatedProperties !== undefined) {\n            const keywordLocation = `${schemaLocation}/unevaluatedProperties`;\n            for (const key in instance) {\n                if (!evaluated[key]) {\n                    const subInstancePointer = `${instanceLocation}/${encodePointer(key)}`;\n                    const result = validate(instance[key], $unevaluatedProperties, draft, lookup, shortCircuit, recursiveAnchor, subInstancePointer, keywordLocation);\n                    if (result.valid) {\n                        evaluated[key] = true;\n                    }\n                    else {\n                        errors.push({\n                            instanceLocation,\n                            keyword: 'unevaluatedProperties',\n                            keywordLocation,\n                            error: `Property \"${key}\" does not match unevaluated properties schema.`\n                        }, ...result.errors);\n                    }\n                }\n            }\n        }\n    }\n    else if (instanceType === 'array') {\n        if ($maxItems !== undefined && instance.length > $maxItems) {\n            errors.push({\n                instanceLocation,\n                keyword: 'maxItems',\n                keywordLocation: `${schemaLocation}/maxItems`,\n                error: `Array has too many items (${instance.length} > ${$maxItems}).`\n            });\n        }\n        if ($minItems !== undefined && instance.length < $minItems) {\n            errors.push({\n                instanceLocation,\n                keyword: 'minItems',\n                keywordLocation: `${schemaLocation}/minItems`,\n                error: `Array has too few items (${instance.length} < ${$minItems}).`\n            });\n        }\n        const length = instance.length;\n        let i = 0;\n        let stop = false;\n        if ($prefixItems !== undefined) {\n            const keywordLocation = `${schemaLocation}/prefixItems`;\n            const length2 = Math.min($prefixItems.length, length);\n            for (; i < length2; i++) {\n                const result = validate(instance[i], $prefixItems[i], draft, lookup, shortCircuit, recursiveAnchor, `${instanceLocation}/${i}`, `${keywordLocation}/${i}`);\n                evaluated[i] = true;\n                if (!result.valid) {\n                    stop = shortCircuit;\n                    errors.push({\n                        instanceLocation,\n                        keyword: 'prefixItems',\n                        keywordLocation,\n                        error: `Items did not match schema.`\n                    }, ...result.errors);\n                    if (stop)\n                        break;\n                }\n            }\n        }\n        if ($items !== undefined) {\n            const keywordLocation = `${schemaLocation}/items`;\n            if (Array.isArray($items)) {\n                const length2 = Math.min($items.length, length);\n                for (; i < length2; i++) {\n                    const result = validate(instance[i], $items[i], draft, lookup, shortCircuit, recursiveAnchor, `${instanceLocation}/${i}`, `${keywordLocation}/${i}`);\n                    evaluated[i] = true;\n                    if (!result.valid) {\n                        stop = shortCircuit;\n                        errors.push({\n                            instanceLocation,\n                            keyword: 'items',\n                            keywordLocation,\n                            error: `Items did not match schema.`\n                        }, ...result.errors);\n                        if (stop)\n                            break;\n                    }\n                }\n            }\n            else {\n                for (; i < length; i++) {\n                    const result = validate(instance[i], $items, draft, lookup, shortCircuit, recursiveAnchor, `${instanceLocation}/${i}`, keywordLocation);\n                    evaluated[i] = true;\n                    if (!result.valid) {\n                        stop = shortCircuit;\n                        errors.push({\n                            instanceLocation,\n                            keyword: 'items',\n                            keywordLocation,\n                            error: `Items did not match schema.`\n                        }, ...result.errors);\n                        if (stop)\n                            break;\n                    }\n                }\n            }\n            if (!stop && $additionalItems !== undefined) {\n                const keywordLocation = `${schemaLocation}/additionalItems`;\n                for (; i < length; i++) {\n                    const result = validate(instance[i], $additionalItems, draft, lookup, shortCircuit, recursiveAnchor, `${instanceLocation}/${i}`, keywordLocation);\n                    evaluated[i] = true;\n                    if (!result.valid) {\n                        stop = shortCircuit;\n                        errors.push({\n                            instanceLocation,\n                            keyword: 'additionalItems',\n                            keywordLocation,\n                            error: `Items did not match additional items schema.`\n                        }, ...result.errors);\n                    }\n                }\n            }\n        }\n        if ($contains !== undefined) {\n            if (length === 0 && $minContains === undefined) {\n                errors.push({\n                    instanceLocation,\n                    keyword: 'contains',\n                    keywordLocation: `${schemaLocation}/contains`,\n                    error: `Array is empty. It must contain at least one item matching the schema.`\n                });\n            }\n            else if ($minContains !== undefined && length < $minContains) {\n                errors.push({\n                    instanceLocation,\n                    keyword: 'minContains',\n                    keywordLocation: `${schemaLocation}/minContains`,\n                    error: `Array has less items (${length}) than minContains (${$minContains}).`\n                });\n            }\n            else {\n                const keywordLocation = `${schemaLocation}/contains`;\n                const errorsLength = errors.length;\n                let contained = 0;\n                for (let j = 0; j < length; j++) {\n                    const result = validate(instance[j], $contains, draft, lookup, shortCircuit, recursiveAnchor, `${instanceLocation}/${j}`, keywordLocation);\n                    if (result.valid) {\n                        evaluated[j] = true;\n                        contained++;\n                    }\n                    else {\n                        errors.push(...result.errors);\n                    }\n                }\n                if (contained >= ($minContains || 0)) {\n                    errors.length = errorsLength;\n                }\n                if ($minContains === undefined &&\n                    $maxContains === undefined &&\n                    contained === 0) {\n                    errors.splice(errorsLength, 0, {\n                        instanceLocation,\n                        keyword: 'contains',\n                        keywordLocation,\n                        error: `Array does not contain item matching schema.`\n                    });\n                }\n                else if ($minContains !== undefined && contained < $minContains) {\n                    errors.push({\n                        instanceLocation,\n                        keyword: 'minContains',\n                        keywordLocation: `${schemaLocation}/minContains`,\n                        error: `Array must contain at least ${$minContains} items matching schema. Only ${contained} items were found.`\n                    });\n                }\n                else if ($maxContains !== undefined && contained > $maxContains) {\n                    errors.push({\n                        instanceLocation,\n                        keyword: 'maxContains',\n                        keywordLocation: `${schemaLocation}/maxContains`,\n                        error: `Array may contain at most ${$maxContains} items matching schema. ${contained} items were found.`\n                    });\n                }\n            }\n        }\n        if (!stop && $unevaluatedItems !== undefined) {\n            const keywordLocation = `${schemaLocation}/unevaluatedItems`;\n            for (i; i < length; i++) {\n                if (evaluated[i]) {\n                    continue;\n                }\n                const result = validate(instance[i], $unevaluatedItems, draft, lookup, shortCircuit, recursiveAnchor, `${instanceLocation}/${i}`, keywordLocation);\n                evaluated[i] = true;\n                if (!result.valid) {\n                    errors.push({\n                        instanceLocation,\n                        keyword: 'unevaluatedItems',\n                        keywordLocation,\n                        error: `Items did not match unevaluated items schema.`\n                    }, ...result.errors);\n                }\n            }\n        }\n        if ($uniqueItems) {\n            for (let j = 0; j < length; j++) {\n                const a = instance[j];\n                const ao = typeof a === 'object' && a !== null;\n                for (let k = 0; k < length; k++) {\n                    if (j === k) {\n                        continue;\n                    }\n                    const b = instance[k];\n                    const bo = typeof b === 'object' && b !== null;\n                    if (a === b || (ao && bo && deepCompareStrict(a, b))) {\n                        errors.push({\n                            instanceLocation,\n                            keyword: 'uniqueItems',\n                            keywordLocation: `${schemaLocation}/uniqueItems`,\n                            error: `Duplicate items at indexes ${j} and ${k}.`\n                        });\n                        j = Number.MAX_SAFE_INTEGER;\n                        k = Number.MAX_SAFE_INTEGER;\n                    }\n                }\n            }\n        }\n    }\n    else if (instanceType === 'number') {\n        if (draft === '4') {\n            if ($minimum !== undefined &&\n                (($exclusiveMinimum === true && instance <= $minimum) ||\n                    instance < $minimum)) {\n                errors.push({\n                    instanceLocation,\n                    keyword: 'minimum',\n                    keywordLocation: `${schemaLocation}/minimum`,\n                    error: `${instance} is less than ${$exclusiveMinimum ? 'or equal to ' : ''} ${$minimum}.`\n                });\n            }\n            if ($maximum !== undefined &&\n                (($exclusiveMaximum === true && instance >= $maximum) ||\n                    instance > $maximum)) {\n                errors.push({\n                    instanceLocation,\n                    keyword: 'maximum',\n                    keywordLocation: `${schemaLocation}/maximum`,\n                    error: `${instance} is greater than ${$exclusiveMaximum ? 'or equal to ' : ''} ${$maximum}.`\n                });\n            }\n        }\n        else {\n            if ($minimum !== undefined && instance < $minimum) {\n                errors.push({\n                    instanceLocation,\n                    keyword: 'minimum',\n                    keywordLocation: `${schemaLocation}/minimum`,\n                    error: `${instance} is less than ${$minimum}.`\n                });\n            }\n            if ($maximum !== undefined && instance > $maximum) {\n                errors.push({\n                    instanceLocation,\n                    keyword: 'maximum',\n                    keywordLocation: `${schemaLocation}/maximum`,\n                    error: `${instance} is greater than ${$maximum}.`\n                });\n            }\n            if ($exclusiveMinimum !== undefined && instance <= $exclusiveMinimum) {\n                errors.push({\n                    instanceLocation,\n                    keyword: 'exclusiveMinimum',\n                    keywordLocation: `${schemaLocation}/exclusiveMinimum`,\n                    error: `${instance} is less than ${$exclusiveMinimum}.`\n                });\n            }\n            if ($exclusiveMaximum !== undefined && instance >= $exclusiveMaximum) {\n                errors.push({\n                    instanceLocation,\n                    keyword: 'exclusiveMaximum',\n                    keywordLocation: `${schemaLocation}/exclusiveMaximum`,\n                    error: `${instance} is greater than or equal to ${$exclusiveMaximum}.`\n                });\n            }\n        }\n        if ($multipleOf !== undefined) {\n            const remainder = instance % $multipleOf;\n            if (Math.abs(0 - remainder) >= 1.1920929e-7 &&\n                Math.abs($multipleOf - remainder) >= 1.1920929e-7) {\n                errors.push({\n                    instanceLocation,\n                    keyword: 'multipleOf',\n                    keywordLocation: `${schemaLocation}/multipleOf`,\n                    error: `${instance} is not a multiple of ${$multipleOf}.`\n                });\n            }\n        }\n    }\n    else if (instanceType === 'string') {\n        const length = $minLength === undefined && $maxLength === undefined\n            ? 0\n            : ucs2length(instance);\n        if ($minLength !== undefined && length < $minLength) {\n            errors.push({\n                instanceLocation,\n                keyword: 'minLength',\n                keywordLocation: `${schemaLocation}/minLength`,\n                error: `String is too short (${length} < ${$minLength}).`\n            });\n        }\n        if ($maxLength !== undefined && length > $maxLength) {\n            errors.push({\n                instanceLocation,\n                keyword: 'maxLength',\n                keywordLocation: `${schemaLocation}/maxLength`,\n                error: `String is too long (${length} > ${$maxLength}).`\n            });\n        }\n        if ($pattern !== undefined && !new RegExp($pattern, 'u').test(instance)) {\n            errors.push({\n                instanceLocation,\n                keyword: 'pattern',\n                keywordLocation: `${schemaLocation}/pattern`,\n                error: `String does not match pattern.`\n            });\n        }\n        if ($format !== undefined &&\n            format[$format] &&\n            !format[$format](instance)) {\n            errors.push({\n                instanceLocation,\n                keyword: 'format',\n                keywordLocation: `${schemaLocation}/format`,\n                error: `String does not match format \"${$format}\".`\n            });\n        }\n    }\n    return { valid: errors.length === 0, errors };\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}