{"ast":null,"code":"import { v4 as uuidv4 } from \"uuid\";\nimport { BaseCallbackHandler, isBaseCallbackHandler } from \"./base.js\";\nimport { ConsoleCallbackHandler } from \"../tracers/console.js\";\nimport { getBufferString } from \"../messages/utils.js\";\nimport { getEnvironmentVariable } from \"../utils/env.js\";\nimport { LangChainTracer } from \"../tracers/tracer_langchain.js\";\nimport { consumeCallback } from \"./promises.js\";\nimport { isTracingEnabled } from \"../utils/callbacks.js\";\nimport { isBaseTracer } from \"../tracers/base.js\";\nimport { getContextVariable, _getConfigureHooks } from \"../singletons/async_local_storage/context.js\";\nexport function parseCallbackConfigArg(arg) {\n  if (!arg) {\n    return {};\n  } else if (Array.isArray(arg) || \"name\" in arg) {\n    return {\n      callbacks: arg\n    };\n  } else {\n    return arg;\n  }\n}\n/**\n * Manage callbacks from different components of LangChain.\n */\nexport class BaseCallbackManager {\n  setHandler(handler) {\n    return this.setHandlers([handler]);\n  }\n}\n/**\n * Base class for run manager in LangChain.\n */\nexport class BaseRunManager {\n  constructor(runId, handlers, inheritableHandlers, tags, inheritableTags, metadata, inheritableMetadata, _parentRunId) {\n    Object.defineProperty(this, \"runId\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: runId\n    });\n    Object.defineProperty(this, \"handlers\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: handlers\n    });\n    Object.defineProperty(this, \"inheritableHandlers\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: inheritableHandlers\n    });\n    Object.defineProperty(this, \"tags\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: tags\n    });\n    Object.defineProperty(this, \"inheritableTags\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: inheritableTags\n    });\n    Object.defineProperty(this, \"metadata\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: metadata\n    });\n    Object.defineProperty(this, \"inheritableMetadata\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: inheritableMetadata\n    });\n    Object.defineProperty(this, \"_parentRunId\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: _parentRunId\n    });\n  }\n  get parentRunId() {\n    return this._parentRunId;\n  }\n  async handleText(text) {\n    await Promise.all(this.handlers.map(handler => consumeCallback(async () => {\n      try {\n        await handler.handleText?.(text, this.runId, this._parentRunId, this.tags);\n      } catch (err) {\n        const logFunction = handler.raiseError ? console.error : console.warn;\n        logFunction(`Error in handler ${handler.constructor.name}, handleText: ${err}`);\n        if (handler.raiseError) {\n          throw err;\n        }\n      }\n    }, handler.awaitHandlers)));\n  }\n  async handleCustomEvent(eventName,\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  data, _runId, _tags,\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  _metadata) {\n    await Promise.all(this.handlers.map(handler => consumeCallback(async () => {\n      try {\n        await handler.handleCustomEvent?.(eventName, data, this.runId, this.tags, this.metadata);\n      } catch (err) {\n        const logFunction = handler.raiseError ? console.error : console.warn;\n        logFunction(`Error in handler ${handler.constructor.name}, handleCustomEvent: ${err}`);\n        if (handler.raiseError) {\n          throw err;\n        }\n      }\n    }, handler.awaitHandlers)));\n  }\n}\n/**\n * Manages callbacks for retriever runs.\n */\nexport class CallbackManagerForRetrieverRun extends BaseRunManager {\n  getChild(tag) {\n    // eslint-disable-next-line @typescript-eslint/no-use-before-define\n    const manager = new CallbackManager(this.runId);\n    manager.setHandlers(this.inheritableHandlers);\n    manager.addTags(this.inheritableTags);\n    manager.addMetadata(this.inheritableMetadata);\n    if (tag) {\n      manager.addTags([tag], false);\n    }\n    return manager;\n  }\n  async handleRetrieverEnd(documents) {\n    await Promise.all(this.handlers.map(handler => consumeCallback(async () => {\n      if (!handler.ignoreRetriever) {\n        try {\n          await handler.handleRetrieverEnd?.(documents, this.runId, this._parentRunId, this.tags);\n        } catch (err) {\n          const logFunction = handler.raiseError ? console.error : console.warn;\n          logFunction(`Error in handler ${handler.constructor.name}, handleRetriever`);\n          if (handler.raiseError) {\n            throw err;\n          }\n        }\n      }\n    }, handler.awaitHandlers)));\n  }\n  async handleRetrieverError(err) {\n    await Promise.all(this.handlers.map(handler => consumeCallback(async () => {\n      if (!handler.ignoreRetriever) {\n        try {\n          await handler.handleRetrieverError?.(err, this.runId, this._parentRunId, this.tags);\n        } catch (error) {\n          const logFunction = handler.raiseError ? console.error : console.warn;\n          logFunction(`Error in handler ${handler.constructor.name}, handleRetrieverError: ${error}`);\n          if (handler.raiseError) {\n            throw err;\n          }\n        }\n      }\n    }, handler.awaitHandlers)));\n  }\n}\nexport class CallbackManagerForLLMRun extends BaseRunManager {\n  async handleLLMNewToken(token, idx, _runId, _parentRunId, _tags, fields) {\n    await Promise.all(this.handlers.map(handler => consumeCallback(async () => {\n      if (!handler.ignoreLLM) {\n        try {\n          await handler.handleLLMNewToken?.(token, idx ?? {\n            prompt: 0,\n            completion: 0\n          }, this.runId, this._parentRunId, this.tags, fields);\n        } catch (err) {\n          const logFunction = handler.raiseError ? console.error : console.warn;\n          logFunction(`Error in handler ${handler.constructor.name}, handleLLMNewToken: ${err}`);\n          if (handler.raiseError) {\n            throw err;\n          }\n        }\n      }\n    }, handler.awaitHandlers)));\n  }\n  async handleLLMError(err, _runId, _parentRunId, _tags, extraParams) {\n    await Promise.all(this.handlers.map(handler => consumeCallback(async () => {\n      if (!handler.ignoreLLM) {\n        try {\n          await handler.handleLLMError?.(err, this.runId, this._parentRunId, this.tags, extraParams);\n        } catch (err) {\n          const logFunction = handler.raiseError ? console.error : console.warn;\n          logFunction(`Error in handler ${handler.constructor.name}, handleLLMError: ${err}`);\n          if (handler.raiseError) {\n            throw err;\n          }\n        }\n      }\n    }, handler.awaitHandlers)));\n  }\n  async handleLLMEnd(output, _runId, _parentRunId, _tags, extraParams) {\n    await Promise.all(this.handlers.map(handler => consumeCallback(async () => {\n      if (!handler.ignoreLLM) {\n        try {\n          await handler.handleLLMEnd?.(output, this.runId, this._parentRunId, this.tags, extraParams);\n        } catch (err) {\n          const logFunction = handler.raiseError ? console.error : console.warn;\n          logFunction(`Error in handler ${handler.constructor.name}, handleLLMEnd: ${err}`);\n          if (handler.raiseError) {\n            throw err;\n          }\n        }\n      }\n    }, handler.awaitHandlers)));\n  }\n}\nexport class CallbackManagerForChainRun extends BaseRunManager {\n  getChild(tag) {\n    // eslint-disable-next-line @typescript-eslint/no-use-before-define\n    const manager = new CallbackManager(this.runId);\n    manager.setHandlers(this.inheritableHandlers);\n    manager.addTags(this.inheritableTags);\n    manager.addMetadata(this.inheritableMetadata);\n    if (tag) {\n      manager.addTags([tag], false);\n    }\n    return manager;\n  }\n  async handleChainError(err, _runId, _parentRunId, _tags, kwargs) {\n    await Promise.all(this.handlers.map(handler => consumeCallback(async () => {\n      if (!handler.ignoreChain) {\n        try {\n          await handler.handleChainError?.(err, this.runId, this._parentRunId, this.tags, kwargs);\n        } catch (err) {\n          const logFunction = handler.raiseError ? console.error : console.warn;\n          logFunction(`Error in handler ${handler.constructor.name}, handleChainError: ${err}`);\n          if (handler.raiseError) {\n            throw err;\n          }\n        }\n      }\n    }, handler.awaitHandlers)));\n  }\n  async handleChainEnd(output, _runId, _parentRunId, _tags, kwargs) {\n    await Promise.all(this.handlers.map(handler => consumeCallback(async () => {\n      if (!handler.ignoreChain) {\n        try {\n          await handler.handleChainEnd?.(output, this.runId, this._parentRunId, this.tags, kwargs);\n        } catch (err) {\n          const logFunction = handler.raiseError ? console.error : console.warn;\n          logFunction(`Error in handler ${handler.constructor.name}, handleChainEnd: ${err}`);\n          if (handler.raiseError) {\n            throw err;\n          }\n        }\n      }\n    }, handler.awaitHandlers)));\n  }\n  async handleAgentAction(action) {\n    await Promise.all(this.handlers.map(handler => consumeCallback(async () => {\n      if (!handler.ignoreAgent) {\n        try {\n          await handler.handleAgentAction?.(action, this.runId, this._parentRunId, this.tags);\n        } catch (err) {\n          const logFunction = handler.raiseError ? console.error : console.warn;\n          logFunction(`Error in handler ${handler.constructor.name}, handleAgentAction: ${err}`);\n          if (handler.raiseError) {\n            throw err;\n          }\n        }\n      }\n    }, handler.awaitHandlers)));\n  }\n  async handleAgentEnd(action) {\n    await Promise.all(this.handlers.map(handler => consumeCallback(async () => {\n      if (!handler.ignoreAgent) {\n        try {\n          await handler.handleAgentEnd?.(action, this.runId, this._parentRunId, this.tags);\n        } catch (err) {\n          const logFunction = handler.raiseError ? console.error : console.warn;\n          logFunction(`Error in handler ${handler.constructor.name}, handleAgentEnd: ${err}`);\n          if (handler.raiseError) {\n            throw err;\n          }\n        }\n      }\n    }, handler.awaitHandlers)));\n  }\n}\nexport class CallbackManagerForToolRun extends BaseRunManager {\n  getChild(tag) {\n    // eslint-disable-next-line @typescript-eslint/no-use-before-define\n    const manager = new CallbackManager(this.runId);\n    manager.setHandlers(this.inheritableHandlers);\n    manager.addTags(this.inheritableTags);\n    manager.addMetadata(this.inheritableMetadata);\n    if (tag) {\n      manager.addTags([tag], false);\n    }\n    return manager;\n  }\n  async handleToolError(err) {\n    await Promise.all(this.handlers.map(handler => consumeCallback(async () => {\n      if (!handler.ignoreAgent) {\n        try {\n          await handler.handleToolError?.(err, this.runId, this._parentRunId, this.tags);\n        } catch (err) {\n          const logFunction = handler.raiseError ? console.error : console.warn;\n          logFunction(`Error in handler ${handler.constructor.name}, handleToolError: ${err}`);\n          if (handler.raiseError) {\n            throw err;\n          }\n        }\n      }\n    }, handler.awaitHandlers)));\n  }\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  async handleToolEnd(output) {\n    await Promise.all(this.handlers.map(handler => consumeCallback(async () => {\n      if (!handler.ignoreAgent) {\n        try {\n          await handler.handleToolEnd?.(output, this.runId, this._parentRunId, this.tags);\n        } catch (err) {\n          const logFunction = handler.raiseError ? console.error : console.warn;\n          logFunction(`Error in handler ${handler.constructor.name}, handleToolEnd: ${err}`);\n          if (handler.raiseError) {\n            throw err;\n          }\n        }\n      }\n    }, handler.awaitHandlers)));\n  }\n}\n/**\n * @example\n * ```typescript\n * const prompt = PromptTemplate.fromTemplate(\"What is the answer to {question}?\");\n *\n * // Example of using LLMChain with OpenAI and a simple prompt\n * const chain = new LLMChain({\n *   llm: new ChatOpenAI({ temperature: 0.9 }),\n *   prompt,\n * });\n *\n * // Running the chain with a single question\n * const result = await chain.call({\n *   question: \"What is the airspeed velocity of an unladen swallow?\",\n * });\n * console.log(\"The answer is:\", result);\n * ```\n */\nexport class CallbackManager extends BaseCallbackManager {\n  constructor(parentRunId, options) {\n    super();\n    Object.defineProperty(this, \"handlers\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: []\n    });\n    Object.defineProperty(this, \"inheritableHandlers\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: []\n    });\n    Object.defineProperty(this, \"tags\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: []\n    });\n    Object.defineProperty(this, \"inheritableTags\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: []\n    });\n    Object.defineProperty(this, \"metadata\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: {}\n    });\n    Object.defineProperty(this, \"inheritableMetadata\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: {}\n    });\n    Object.defineProperty(this, \"name\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: \"callback_manager\"\n    });\n    Object.defineProperty(this, \"_parentRunId\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    this.handlers = options?.handlers ?? this.handlers;\n    this.inheritableHandlers = options?.inheritableHandlers ?? this.inheritableHandlers;\n    this.tags = options?.tags ?? this.tags;\n    this.inheritableTags = options?.inheritableTags ?? this.inheritableTags;\n    this.metadata = options?.metadata ?? this.metadata;\n    this.inheritableMetadata = options?.inheritableMetadata ?? this.inheritableMetadata;\n    this._parentRunId = parentRunId;\n  }\n  /**\n   * Gets the parent run ID, if any.\n   *\n   * @returns The parent run ID.\n   */\n  getParentRunId() {\n    return this._parentRunId;\n  }\n  async handleLLMStart(llm, prompts, runId = undefined, _parentRunId = undefined, extraParams = undefined, _tags = undefined, _metadata = undefined, runName = undefined) {\n    return Promise.all(prompts.map(async (prompt, idx) => {\n      // Can't have duplicate runs with the same run ID (if provided)\n      const runId_ = idx === 0 && runId ? runId : uuidv4();\n      await Promise.all(this.handlers.map(handler => {\n        if (handler.ignoreLLM) {\n          return;\n        }\n        if (isBaseTracer(handler)) {\n          // Create and add run to the run map.\n          // We do this synchronously to avoid race conditions\n          // when callbacks are backgrounded.\n          handler._createRunForLLMStart(llm, [prompt], runId_, this._parentRunId, extraParams, this.tags, this.metadata, runName);\n        }\n        return consumeCallback(async () => {\n          try {\n            await handler.handleLLMStart?.(llm, [prompt], runId_, this._parentRunId, extraParams, this.tags, this.metadata, runName);\n          } catch (err) {\n            const logFunction = handler.raiseError ? console.error : console.warn;\n            logFunction(`Error in handler ${handler.constructor.name}, handleLLMStart: ${err}`);\n            if (handler.raiseError) {\n              throw err;\n            }\n          }\n        }, handler.awaitHandlers);\n      }));\n      return new CallbackManagerForLLMRun(runId_, this.handlers, this.inheritableHandlers, this.tags, this.inheritableTags, this.metadata, this.inheritableMetadata, this._parentRunId);\n    }));\n  }\n  async handleChatModelStart(llm, messages, runId = undefined, _parentRunId = undefined, extraParams = undefined, _tags = undefined, _metadata = undefined, runName = undefined) {\n    return Promise.all(messages.map(async (messageGroup, idx) => {\n      // Can't have duplicate runs with the same run ID (if provided)\n      const runId_ = idx === 0 && runId ? runId : uuidv4();\n      await Promise.all(this.handlers.map(handler => {\n        if (handler.ignoreLLM) {\n          return;\n        }\n        if (isBaseTracer(handler)) {\n          // Create and add run to the run map.\n          // We do this synchronously to avoid race conditions\n          // when callbacks are backgrounded.\n          handler._createRunForChatModelStart(llm, [messageGroup], runId_, this._parentRunId, extraParams, this.tags, this.metadata, runName);\n        }\n        return consumeCallback(async () => {\n          try {\n            if (handler.handleChatModelStart) {\n              await handler.handleChatModelStart?.(llm, [messageGroup], runId_, this._parentRunId, extraParams, this.tags, this.metadata, runName);\n            } else if (handler.handleLLMStart) {\n              const messageString = getBufferString(messageGroup);\n              await handler.handleLLMStart?.(llm, [messageString], runId_, this._parentRunId, extraParams, this.tags, this.metadata, runName);\n            }\n          } catch (err) {\n            const logFunction = handler.raiseError ? console.error : console.warn;\n            logFunction(`Error in handler ${handler.constructor.name}, handleLLMStart: ${err}`);\n            if (handler.raiseError) {\n              throw err;\n            }\n          }\n        }, handler.awaitHandlers);\n      }));\n      return new CallbackManagerForLLMRun(runId_, this.handlers, this.inheritableHandlers, this.tags, this.inheritableTags, this.metadata, this.inheritableMetadata, this._parentRunId);\n    }));\n  }\n  async handleChainStart(chain, inputs, runId = uuidv4(), runType = undefined, _tags = undefined, _metadata = undefined, runName = undefined) {\n    await Promise.all(this.handlers.map(handler => {\n      if (handler.ignoreChain) {\n        return;\n      }\n      if (isBaseTracer(handler)) {\n        // Create and add run to the run map.\n        // We do this synchronously to avoid race conditions\n        // when callbacks are backgrounded.\n        handler._createRunForChainStart(chain, inputs, runId, this._parentRunId, this.tags, this.metadata, runType, runName);\n      }\n      return consumeCallback(async () => {\n        try {\n          await handler.handleChainStart?.(chain, inputs, runId, this._parentRunId, this.tags, this.metadata, runType, runName);\n        } catch (err) {\n          const logFunction = handler.raiseError ? console.error : console.warn;\n          logFunction(`Error in handler ${handler.constructor.name}, handleChainStart: ${err}`);\n          if (handler.raiseError) {\n            throw err;\n          }\n        }\n      }, handler.awaitHandlers);\n    }));\n    return new CallbackManagerForChainRun(runId, this.handlers, this.inheritableHandlers, this.tags, this.inheritableTags, this.metadata, this.inheritableMetadata, this._parentRunId);\n  }\n  async handleToolStart(tool, input, runId = uuidv4(), _parentRunId = undefined, _tags = undefined, _metadata = undefined, runName = undefined) {\n    await Promise.all(this.handlers.map(handler => {\n      if (handler.ignoreAgent) {\n        return;\n      }\n      if (isBaseTracer(handler)) {\n        // Create and add run to the run map.\n        // We do this synchronously to avoid race conditions\n        // when callbacks are backgrounded.\n        handler._createRunForToolStart(tool, input, runId, this._parentRunId, this.tags, this.metadata, runName);\n      }\n      return consumeCallback(async () => {\n        try {\n          await handler.handleToolStart?.(tool, input, runId, this._parentRunId, this.tags, this.metadata, runName);\n        } catch (err) {\n          const logFunction = handler.raiseError ? console.error : console.warn;\n          logFunction(`Error in handler ${handler.constructor.name}, handleToolStart: ${err}`);\n          if (handler.raiseError) {\n            throw err;\n          }\n        }\n      }, handler.awaitHandlers);\n    }));\n    return new CallbackManagerForToolRun(runId, this.handlers, this.inheritableHandlers, this.tags, this.inheritableTags, this.metadata, this.inheritableMetadata, this._parentRunId);\n  }\n  async handleRetrieverStart(retriever, query, runId = uuidv4(), _parentRunId = undefined, _tags = undefined, _metadata = undefined, runName = undefined) {\n    await Promise.all(this.handlers.map(handler => {\n      if (handler.ignoreRetriever) {\n        return;\n      }\n      if (isBaseTracer(handler)) {\n        // Create and add run to the run map.\n        // We do this synchronously to avoid race conditions\n        // when callbacks are backgrounded.\n        handler._createRunForRetrieverStart(retriever, query, runId, this._parentRunId, this.tags, this.metadata, runName);\n      }\n      return consumeCallback(async () => {\n        try {\n          await handler.handleRetrieverStart?.(retriever, query, runId, this._parentRunId, this.tags, this.metadata, runName);\n        } catch (err) {\n          const logFunction = handler.raiseError ? console.error : console.warn;\n          logFunction(`Error in handler ${handler.constructor.name}, handleRetrieverStart: ${err}`);\n          if (handler.raiseError) {\n            throw err;\n          }\n        }\n      }, handler.awaitHandlers);\n    }));\n    return new CallbackManagerForRetrieverRun(runId, this.handlers, this.inheritableHandlers, this.tags, this.inheritableTags, this.metadata, this.inheritableMetadata, this._parentRunId);\n  }\n  async handleCustomEvent(eventName,\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  data, runId, _tags,\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  _metadata) {\n    await Promise.all(this.handlers.map(handler => consumeCallback(async () => {\n      if (!handler.ignoreCustomEvent) {\n        try {\n          await handler.handleCustomEvent?.(eventName, data, runId, this.tags, this.metadata);\n        } catch (err) {\n          const logFunction = handler.raiseError ? console.error : console.warn;\n          logFunction(`Error in handler ${handler.constructor.name}, handleCustomEvent: ${err}`);\n          if (handler.raiseError) {\n            throw err;\n          }\n        }\n      }\n    }, handler.awaitHandlers)));\n  }\n  addHandler(handler, inherit = true) {\n    this.handlers.push(handler);\n    if (inherit) {\n      this.inheritableHandlers.push(handler);\n    }\n  }\n  removeHandler(handler) {\n    this.handlers = this.handlers.filter(_handler => _handler !== handler);\n    this.inheritableHandlers = this.inheritableHandlers.filter(_handler => _handler !== handler);\n  }\n  setHandlers(handlers, inherit = true) {\n    this.handlers = [];\n    this.inheritableHandlers = [];\n    for (const handler of handlers) {\n      this.addHandler(handler, inherit);\n    }\n  }\n  addTags(tags, inherit = true) {\n    this.removeTags(tags); // Remove duplicates\n    this.tags.push(...tags);\n    if (inherit) {\n      this.inheritableTags.push(...tags);\n    }\n  }\n  removeTags(tags) {\n    this.tags = this.tags.filter(tag => !tags.includes(tag));\n    this.inheritableTags = this.inheritableTags.filter(tag => !tags.includes(tag));\n  }\n  addMetadata(metadata, inherit = true) {\n    this.metadata = {\n      ...this.metadata,\n      ...metadata\n    };\n    if (inherit) {\n      this.inheritableMetadata = {\n        ...this.inheritableMetadata,\n        ...metadata\n      };\n    }\n  }\n  removeMetadata(metadata) {\n    for (const key of Object.keys(metadata)) {\n      delete this.metadata[key];\n      delete this.inheritableMetadata[key];\n    }\n  }\n  copy(additionalHandlers = [], inherit = true) {\n    const manager = new CallbackManager(this._parentRunId);\n    for (const handler of this.handlers) {\n      const inheritable = this.inheritableHandlers.includes(handler);\n      manager.addHandler(handler, inheritable);\n    }\n    for (const tag of this.tags) {\n      const inheritable = this.inheritableTags.includes(tag);\n      manager.addTags([tag], inheritable);\n    }\n    for (const key of Object.keys(this.metadata)) {\n      const inheritable = Object.keys(this.inheritableMetadata).includes(key);\n      manager.addMetadata({\n        [key]: this.metadata[key]\n      }, inheritable);\n    }\n    for (const handler of additionalHandlers) {\n      if (\n      // Prevent multiple copies of console_callback_handler\n      manager.handlers.filter(h => h.name === \"console_callback_handler\").some(h => h.name === handler.name)) {\n        continue;\n      }\n      manager.addHandler(handler, inherit);\n    }\n    return manager;\n  }\n  static fromHandlers(handlers) {\n    class Handler extends BaseCallbackHandler {\n      constructor() {\n        super();\n        Object.defineProperty(this, \"name\", {\n          enumerable: true,\n          configurable: true,\n          writable: true,\n          value: uuidv4()\n        });\n        Object.assign(this, handlers);\n      }\n    }\n    const manager = new this();\n    manager.addHandler(new Handler());\n    return manager;\n  }\n  static configure(inheritableHandlers, localHandlers, inheritableTags, localTags, inheritableMetadata, localMetadata, options) {\n    return this._configureSync(inheritableHandlers, localHandlers, inheritableTags, localTags, inheritableMetadata, localMetadata, options);\n  }\n  // TODO: Deprecate async method in favor of this one.\n  static _configureSync(inheritableHandlers, localHandlers, inheritableTags, localTags, inheritableMetadata, localMetadata, options) {\n    let callbackManager;\n    if (inheritableHandlers || localHandlers) {\n      if (Array.isArray(inheritableHandlers) || !inheritableHandlers) {\n        callbackManager = new CallbackManager();\n        callbackManager.setHandlers(inheritableHandlers?.map(ensureHandler) ?? [], true);\n      } else {\n        callbackManager = inheritableHandlers;\n      }\n      callbackManager = callbackManager.copy(Array.isArray(localHandlers) ? localHandlers.map(ensureHandler) : localHandlers?.handlers, false);\n    }\n    const verboseEnabled = getEnvironmentVariable(\"LANGCHAIN_VERBOSE\") === \"true\" || options?.verbose;\n    const tracingV2Enabled = LangChainTracer.getTraceableRunTree()?.tracingEnabled || isTracingEnabled();\n    const tracingEnabled = tracingV2Enabled || (getEnvironmentVariable(\"LANGCHAIN_TRACING\") ?? false);\n    if (verboseEnabled || tracingEnabled) {\n      if (!callbackManager) {\n        callbackManager = new CallbackManager();\n      }\n      if (verboseEnabled && !callbackManager.handlers.some(handler => handler.name === ConsoleCallbackHandler.prototype.name)) {\n        const consoleHandler = new ConsoleCallbackHandler();\n        callbackManager.addHandler(consoleHandler, true);\n      }\n      if (tracingEnabled && !callbackManager.handlers.some(handler => handler.name === \"langchain_tracer\")) {\n        if (tracingV2Enabled) {\n          const tracerV2 = new LangChainTracer();\n          callbackManager.addHandler(tracerV2, true);\n          // handoff between langchain and langsmith/traceable\n          // override the parent run ID\n          callbackManager._parentRunId = LangChainTracer.getTraceableRunTree()?.id ?? callbackManager._parentRunId;\n        }\n      }\n    }\n    for (const {\n      contextVar,\n      inheritable = true,\n      handlerClass,\n      envVar\n    } of _getConfigureHooks()) {\n      const createIfNotInContext = envVar && getEnvironmentVariable(envVar) === \"true\" && handlerClass;\n      let handler;\n      const contextVarValue = contextVar !== undefined ? getContextVariable(contextVar) : undefined;\n      if (contextVarValue && isBaseCallbackHandler(contextVarValue)) {\n        handler = contextVarValue;\n      } else if (createIfNotInContext) {\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        handler = new handlerClass({});\n      }\n      if (handler !== undefined) {\n        if (!callbackManager) {\n          callbackManager = new CallbackManager();\n        }\n        if (!callbackManager.handlers.some(h => h.name === handler.name)) {\n          callbackManager.addHandler(handler, inheritable);\n        }\n      }\n    }\n    if (inheritableTags || localTags) {\n      if (callbackManager) {\n        callbackManager.addTags(inheritableTags ?? []);\n        callbackManager.addTags(localTags ?? [], false);\n      }\n    }\n    if (inheritableMetadata || localMetadata) {\n      if (callbackManager) {\n        callbackManager.addMetadata(inheritableMetadata ?? {});\n        callbackManager.addMetadata(localMetadata ?? {}, false);\n      }\n    }\n    return callbackManager;\n  }\n}\nexport function ensureHandler(handler) {\n  if (\"name\" in handler) {\n    return handler;\n  }\n  return BaseCallbackHandler.fromMethods(handler);\n}\n/**\n * @deprecated Use [`traceable`](https://docs.smith.langchain.com/observability/how_to_guides/tracing/annotate_code)\n * from \"langsmith\" instead.\n */\nexport class TraceGroup {\n  constructor(groupName, options) {\n    Object.defineProperty(this, \"groupName\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: groupName\n    });\n    Object.defineProperty(this, \"options\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: options\n    });\n    Object.defineProperty(this, \"runManager\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n  }\n  async getTraceGroupCallbackManager(group_name, inputs, options) {\n    const cb = new LangChainTracer(options);\n    const cm = await CallbackManager.configure([cb]);\n    const runManager = await cm?.handleChainStart({\n      lc: 1,\n      type: \"not_implemented\",\n      id: [\"langchain\", \"callbacks\", \"groups\", group_name]\n    }, inputs ?? {});\n    if (!runManager) {\n      throw new Error(\"Failed to create run group callback manager.\");\n    }\n    return runManager;\n  }\n  async start(inputs) {\n    if (!this.runManager) {\n      this.runManager = await this.getTraceGroupCallbackManager(this.groupName, inputs, this.options);\n    }\n    return this.runManager.getChild();\n  }\n  async error(err) {\n    if (this.runManager) {\n      await this.runManager.handleChainError(err);\n      this.runManager = undefined;\n    }\n  }\n  async end(output) {\n    if (this.runManager) {\n      await this.runManager.handleChainEnd(output ?? {});\n      this.runManager = undefined;\n    }\n  }\n}\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nfunction _coerceToDict(value, defaultKey) {\n  return value && !Array.isArray(value) && typeof value === \"object\" ? value : {\n    [defaultKey]: value\n  };\n}\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport async function traceAsGroup(groupOptions, enclosedCode, ...args) {\n  const traceGroup = new TraceGroup(groupOptions.name, groupOptions);\n  const callbackManager = await traceGroup.start({\n    ...args\n  });\n  try {\n    const result = await enclosedCode(callbackManager, ...args);\n    await traceGroup.end(_coerceToDict(result, \"output\"));\n    return result;\n  } catch (err) {\n    await traceGroup.error(err);\n    throw err;\n  }\n}","map":{"version":3,"names":["v4","uuidv4","BaseCallbackHandler","isBaseCallbackHandler","ConsoleCallbackHandler","getBufferString","getEnvironmentVariable","LangChainTracer","consumeCallback","isTracingEnabled","isBaseTracer","getContextVariable","_getConfigureHooks","parseCallbackConfigArg","arg","Array","isArray","callbacks","BaseCallbackManager","setHandler","handler","setHandlers","BaseRunManager","constructor","runId","handlers","inheritableHandlers","tags","inheritableTags","metadata","inheritableMetadata","_parentRunId","Object","defineProperty","enumerable","configurable","writable","value","parentRunId","handleText","text","Promise","all","map","err","logFunction","raiseError","console","error","warn","name","awaitHandlers","handleCustomEvent","eventName","data","_runId","_tags","_metadata","CallbackManagerForRetrieverRun","getChild","tag","manager","CallbackManager","addTags","addMetadata","handleRetrieverEnd","documents","ignoreRetriever","handleRetrieverError","CallbackManagerForLLMRun","handleLLMNewToken","token","idx","fields","ignoreLLM","prompt","completion","handleLLMError","extraParams","handleLLMEnd","output","CallbackManagerForChainRun","handleChainError","kwargs","ignoreChain","handleChainEnd","handleAgentAction","action","ignoreAgent","handleAgentEnd","CallbackManagerForToolRun","handleToolError","handleToolEnd","options","getParentRunId","handleLLMStart","llm","prompts","undefined","runName","runId_","_createRunForLLMStart","handleChatModelStart","messages","messageGroup","_createRunForChatModelStart","messageString","handleChainStart","chain","inputs","runType","_createRunForChainStart","handleToolStart","tool","input","_createRunForToolStart","handleRetrieverStart","retriever","query","_createRunForRetrieverStart","ignoreCustomEvent","addHandler","inherit","push","removeHandler","filter","_handler","removeTags","includes","removeMetadata","key","keys","copy","additionalHandlers","inheritable","h","some","fromHandlers","Handler","assign","configure","localHandlers","localTags","localMetadata","_configureSync","callbackManager","ensureHandler","verboseEnabled","verbose","tracingV2Enabled","getTraceableRunTree","tracingEnabled","prototype","consoleHandler","tracerV2","id","contextVar","handlerClass","envVar","createIfNotInContext","contextVarValue","fromMethods","TraceGroup","groupName","getTraceGroupCallbackManager","group_name","cb","cm","runManager","lc","type","Error","start","end","_coerceToDict","defaultKey","traceAsGroup","groupOptions","enclosedCode","args","traceGroup","result"],"sources":["/Users/youngchen/Downloads/cs224g-triage/node_modules/@langchain/core/dist/callbacks/manager.js"],"sourcesContent":["import { v4 as uuidv4 } from \"uuid\";\nimport { BaseCallbackHandler, isBaseCallbackHandler, } from \"./base.js\";\nimport { ConsoleCallbackHandler } from \"../tracers/console.js\";\nimport { getBufferString } from \"../messages/utils.js\";\nimport { getEnvironmentVariable } from \"../utils/env.js\";\nimport { LangChainTracer, } from \"../tracers/tracer_langchain.js\";\nimport { consumeCallback } from \"./promises.js\";\nimport { isTracingEnabled } from \"../utils/callbacks.js\";\nimport { isBaseTracer } from \"../tracers/base.js\";\nimport { getContextVariable, _getConfigureHooks, } from \"../singletons/async_local_storage/context.js\";\nexport function parseCallbackConfigArg(arg) {\n    if (!arg) {\n        return {};\n    }\n    else if (Array.isArray(arg) || \"name\" in arg) {\n        return { callbacks: arg };\n    }\n    else {\n        return arg;\n    }\n}\n/**\n * Manage callbacks from different components of LangChain.\n */\nexport class BaseCallbackManager {\n    setHandler(handler) {\n        return this.setHandlers([handler]);\n    }\n}\n/**\n * Base class for run manager in LangChain.\n */\nexport class BaseRunManager {\n    constructor(runId, handlers, inheritableHandlers, tags, inheritableTags, metadata, inheritableMetadata, _parentRunId) {\n        Object.defineProperty(this, \"runId\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: runId\n        });\n        Object.defineProperty(this, \"handlers\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: handlers\n        });\n        Object.defineProperty(this, \"inheritableHandlers\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: inheritableHandlers\n        });\n        Object.defineProperty(this, \"tags\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: tags\n        });\n        Object.defineProperty(this, \"inheritableTags\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: inheritableTags\n        });\n        Object.defineProperty(this, \"metadata\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: metadata\n        });\n        Object.defineProperty(this, \"inheritableMetadata\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: inheritableMetadata\n        });\n        Object.defineProperty(this, \"_parentRunId\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: _parentRunId\n        });\n    }\n    get parentRunId() {\n        return this._parentRunId;\n    }\n    async handleText(text) {\n        await Promise.all(this.handlers.map((handler) => consumeCallback(async () => {\n            try {\n                await handler.handleText?.(text, this.runId, this._parentRunId, this.tags);\n            }\n            catch (err) {\n                const logFunction = handler.raiseError\n                    ? console.error\n                    : console.warn;\n                logFunction(`Error in handler ${handler.constructor.name}, handleText: ${err}`);\n                if (handler.raiseError) {\n                    throw err;\n                }\n            }\n        }, handler.awaitHandlers)));\n    }\n    async handleCustomEvent(eventName, \n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    data, _runId, _tags, \n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    _metadata) {\n        await Promise.all(this.handlers.map((handler) => consumeCallback(async () => {\n            try {\n                await handler.handleCustomEvent?.(eventName, data, this.runId, this.tags, this.metadata);\n            }\n            catch (err) {\n                const logFunction = handler.raiseError\n                    ? console.error\n                    : console.warn;\n                logFunction(`Error in handler ${handler.constructor.name}, handleCustomEvent: ${err}`);\n                if (handler.raiseError) {\n                    throw err;\n                }\n            }\n        }, handler.awaitHandlers)));\n    }\n}\n/**\n * Manages callbacks for retriever runs.\n */\nexport class CallbackManagerForRetrieverRun extends BaseRunManager {\n    getChild(tag) {\n        // eslint-disable-next-line @typescript-eslint/no-use-before-define\n        const manager = new CallbackManager(this.runId);\n        manager.setHandlers(this.inheritableHandlers);\n        manager.addTags(this.inheritableTags);\n        manager.addMetadata(this.inheritableMetadata);\n        if (tag) {\n            manager.addTags([tag], false);\n        }\n        return manager;\n    }\n    async handleRetrieverEnd(documents) {\n        await Promise.all(this.handlers.map((handler) => consumeCallback(async () => {\n            if (!handler.ignoreRetriever) {\n                try {\n                    await handler.handleRetrieverEnd?.(documents, this.runId, this._parentRunId, this.tags);\n                }\n                catch (err) {\n                    const logFunction = handler.raiseError\n                        ? console.error\n                        : console.warn;\n                    logFunction(`Error in handler ${handler.constructor.name}, handleRetriever`);\n                    if (handler.raiseError) {\n                        throw err;\n                    }\n                }\n            }\n        }, handler.awaitHandlers)));\n    }\n    async handleRetrieverError(err) {\n        await Promise.all(this.handlers.map((handler) => consumeCallback(async () => {\n            if (!handler.ignoreRetriever) {\n                try {\n                    await handler.handleRetrieverError?.(err, this.runId, this._parentRunId, this.tags);\n                }\n                catch (error) {\n                    const logFunction = handler.raiseError\n                        ? console.error\n                        : console.warn;\n                    logFunction(`Error in handler ${handler.constructor.name}, handleRetrieverError: ${error}`);\n                    if (handler.raiseError) {\n                        throw err;\n                    }\n                }\n            }\n        }, handler.awaitHandlers)));\n    }\n}\nexport class CallbackManagerForLLMRun extends BaseRunManager {\n    async handleLLMNewToken(token, idx, _runId, _parentRunId, _tags, fields) {\n        await Promise.all(this.handlers.map((handler) => consumeCallback(async () => {\n            if (!handler.ignoreLLM) {\n                try {\n                    await handler.handleLLMNewToken?.(token, idx ?? { prompt: 0, completion: 0 }, this.runId, this._parentRunId, this.tags, fields);\n                }\n                catch (err) {\n                    const logFunction = handler.raiseError\n                        ? console.error\n                        : console.warn;\n                    logFunction(`Error in handler ${handler.constructor.name}, handleLLMNewToken: ${err}`);\n                    if (handler.raiseError) {\n                        throw err;\n                    }\n                }\n            }\n        }, handler.awaitHandlers)));\n    }\n    async handleLLMError(err, _runId, _parentRunId, _tags, extraParams) {\n        await Promise.all(this.handlers.map((handler) => consumeCallback(async () => {\n            if (!handler.ignoreLLM) {\n                try {\n                    await handler.handleLLMError?.(err, this.runId, this._parentRunId, this.tags, extraParams);\n                }\n                catch (err) {\n                    const logFunction = handler.raiseError\n                        ? console.error\n                        : console.warn;\n                    logFunction(`Error in handler ${handler.constructor.name}, handleLLMError: ${err}`);\n                    if (handler.raiseError) {\n                        throw err;\n                    }\n                }\n            }\n        }, handler.awaitHandlers)));\n    }\n    async handleLLMEnd(output, _runId, _parentRunId, _tags, extraParams) {\n        await Promise.all(this.handlers.map((handler) => consumeCallback(async () => {\n            if (!handler.ignoreLLM) {\n                try {\n                    await handler.handleLLMEnd?.(output, this.runId, this._parentRunId, this.tags, extraParams);\n                }\n                catch (err) {\n                    const logFunction = handler.raiseError\n                        ? console.error\n                        : console.warn;\n                    logFunction(`Error in handler ${handler.constructor.name}, handleLLMEnd: ${err}`);\n                    if (handler.raiseError) {\n                        throw err;\n                    }\n                }\n            }\n        }, handler.awaitHandlers)));\n    }\n}\nexport class CallbackManagerForChainRun extends BaseRunManager {\n    getChild(tag) {\n        // eslint-disable-next-line @typescript-eslint/no-use-before-define\n        const manager = new CallbackManager(this.runId);\n        manager.setHandlers(this.inheritableHandlers);\n        manager.addTags(this.inheritableTags);\n        manager.addMetadata(this.inheritableMetadata);\n        if (tag) {\n            manager.addTags([tag], false);\n        }\n        return manager;\n    }\n    async handleChainError(err, _runId, _parentRunId, _tags, kwargs) {\n        await Promise.all(this.handlers.map((handler) => consumeCallback(async () => {\n            if (!handler.ignoreChain) {\n                try {\n                    await handler.handleChainError?.(err, this.runId, this._parentRunId, this.tags, kwargs);\n                }\n                catch (err) {\n                    const logFunction = handler.raiseError\n                        ? console.error\n                        : console.warn;\n                    logFunction(`Error in handler ${handler.constructor.name}, handleChainError: ${err}`);\n                    if (handler.raiseError) {\n                        throw err;\n                    }\n                }\n            }\n        }, handler.awaitHandlers)));\n    }\n    async handleChainEnd(output, _runId, _parentRunId, _tags, kwargs) {\n        await Promise.all(this.handlers.map((handler) => consumeCallback(async () => {\n            if (!handler.ignoreChain) {\n                try {\n                    await handler.handleChainEnd?.(output, this.runId, this._parentRunId, this.tags, kwargs);\n                }\n                catch (err) {\n                    const logFunction = handler.raiseError\n                        ? console.error\n                        : console.warn;\n                    logFunction(`Error in handler ${handler.constructor.name}, handleChainEnd: ${err}`);\n                    if (handler.raiseError) {\n                        throw err;\n                    }\n                }\n            }\n        }, handler.awaitHandlers)));\n    }\n    async handleAgentAction(action) {\n        await Promise.all(this.handlers.map((handler) => consumeCallback(async () => {\n            if (!handler.ignoreAgent) {\n                try {\n                    await handler.handleAgentAction?.(action, this.runId, this._parentRunId, this.tags);\n                }\n                catch (err) {\n                    const logFunction = handler.raiseError\n                        ? console.error\n                        : console.warn;\n                    logFunction(`Error in handler ${handler.constructor.name}, handleAgentAction: ${err}`);\n                    if (handler.raiseError) {\n                        throw err;\n                    }\n                }\n            }\n        }, handler.awaitHandlers)));\n    }\n    async handleAgentEnd(action) {\n        await Promise.all(this.handlers.map((handler) => consumeCallback(async () => {\n            if (!handler.ignoreAgent) {\n                try {\n                    await handler.handleAgentEnd?.(action, this.runId, this._parentRunId, this.tags);\n                }\n                catch (err) {\n                    const logFunction = handler.raiseError\n                        ? console.error\n                        : console.warn;\n                    logFunction(`Error in handler ${handler.constructor.name}, handleAgentEnd: ${err}`);\n                    if (handler.raiseError) {\n                        throw err;\n                    }\n                }\n            }\n        }, handler.awaitHandlers)));\n    }\n}\nexport class CallbackManagerForToolRun extends BaseRunManager {\n    getChild(tag) {\n        // eslint-disable-next-line @typescript-eslint/no-use-before-define\n        const manager = new CallbackManager(this.runId);\n        manager.setHandlers(this.inheritableHandlers);\n        manager.addTags(this.inheritableTags);\n        manager.addMetadata(this.inheritableMetadata);\n        if (tag) {\n            manager.addTags([tag], false);\n        }\n        return manager;\n    }\n    async handleToolError(err) {\n        await Promise.all(this.handlers.map((handler) => consumeCallback(async () => {\n            if (!handler.ignoreAgent) {\n                try {\n                    await handler.handleToolError?.(err, this.runId, this._parentRunId, this.tags);\n                }\n                catch (err) {\n                    const logFunction = handler.raiseError\n                        ? console.error\n                        : console.warn;\n                    logFunction(`Error in handler ${handler.constructor.name}, handleToolError: ${err}`);\n                    if (handler.raiseError) {\n                        throw err;\n                    }\n                }\n            }\n        }, handler.awaitHandlers)));\n    }\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    async handleToolEnd(output) {\n        await Promise.all(this.handlers.map((handler) => consumeCallback(async () => {\n            if (!handler.ignoreAgent) {\n                try {\n                    await handler.handleToolEnd?.(output, this.runId, this._parentRunId, this.tags);\n                }\n                catch (err) {\n                    const logFunction = handler.raiseError\n                        ? console.error\n                        : console.warn;\n                    logFunction(`Error in handler ${handler.constructor.name}, handleToolEnd: ${err}`);\n                    if (handler.raiseError) {\n                        throw err;\n                    }\n                }\n            }\n        }, handler.awaitHandlers)));\n    }\n}\n/**\n * @example\n * ```typescript\n * const prompt = PromptTemplate.fromTemplate(\"What is the answer to {question}?\");\n *\n * // Example of using LLMChain with OpenAI and a simple prompt\n * const chain = new LLMChain({\n *   llm: new ChatOpenAI({ temperature: 0.9 }),\n *   prompt,\n * });\n *\n * // Running the chain with a single question\n * const result = await chain.call({\n *   question: \"What is the airspeed velocity of an unladen swallow?\",\n * });\n * console.log(\"The answer is:\", result);\n * ```\n */\nexport class CallbackManager extends BaseCallbackManager {\n    constructor(parentRunId, options) {\n        super();\n        Object.defineProperty(this, \"handlers\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: []\n        });\n        Object.defineProperty(this, \"inheritableHandlers\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: []\n        });\n        Object.defineProperty(this, \"tags\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: []\n        });\n        Object.defineProperty(this, \"inheritableTags\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: []\n        });\n        Object.defineProperty(this, \"metadata\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: {}\n        });\n        Object.defineProperty(this, \"inheritableMetadata\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: {}\n        });\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: \"callback_manager\"\n        });\n        Object.defineProperty(this, \"_parentRunId\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.handlers = options?.handlers ?? this.handlers;\n        this.inheritableHandlers =\n            options?.inheritableHandlers ?? this.inheritableHandlers;\n        this.tags = options?.tags ?? this.tags;\n        this.inheritableTags = options?.inheritableTags ?? this.inheritableTags;\n        this.metadata = options?.metadata ?? this.metadata;\n        this.inheritableMetadata =\n            options?.inheritableMetadata ?? this.inheritableMetadata;\n        this._parentRunId = parentRunId;\n    }\n    /**\n     * Gets the parent run ID, if any.\n     *\n     * @returns The parent run ID.\n     */\n    getParentRunId() {\n        return this._parentRunId;\n    }\n    async handleLLMStart(llm, prompts, runId = undefined, _parentRunId = undefined, extraParams = undefined, _tags = undefined, _metadata = undefined, runName = undefined) {\n        return Promise.all(prompts.map(async (prompt, idx) => {\n            // Can't have duplicate runs with the same run ID (if provided)\n            const runId_ = idx === 0 && runId ? runId : uuidv4();\n            await Promise.all(this.handlers.map((handler) => {\n                if (handler.ignoreLLM) {\n                    return;\n                }\n                if (isBaseTracer(handler)) {\n                    // Create and add run to the run map.\n                    // We do this synchronously to avoid race conditions\n                    // when callbacks are backgrounded.\n                    handler._createRunForLLMStart(llm, [prompt], runId_, this._parentRunId, extraParams, this.tags, this.metadata, runName);\n                }\n                return consumeCallback(async () => {\n                    try {\n                        await handler.handleLLMStart?.(llm, [prompt], runId_, this._parentRunId, extraParams, this.tags, this.metadata, runName);\n                    }\n                    catch (err) {\n                        const logFunction = handler.raiseError\n                            ? console.error\n                            : console.warn;\n                        logFunction(`Error in handler ${handler.constructor.name}, handleLLMStart: ${err}`);\n                        if (handler.raiseError) {\n                            throw err;\n                        }\n                    }\n                }, handler.awaitHandlers);\n            }));\n            return new CallbackManagerForLLMRun(runId_, this.handlers, this.inheritableHandlers, this.tags, this.inheritableTags, this.metadata, this.inheritableMetadata, this._parentRunId);\n        }));\n    }\n    async handleChatModelStart(llm, messages, runId = undefined, _parentRunId = undefined, extraParams = undefined, _tags = undefined, _metadata = undefined, runName = undefined) {\n        return Promise.all(messages.map(async (messageGroup, idx) => {\n            // Can't have duplicate runs with the same run ID (if provided)\n            const runId_ = idx === 0 && runId ? runId : uuidv4();\n            await Promise.all(this.handlers.map((handler) => {\n                if (handler.ignoreLLM) {\n                    return;\n                }\n                if (isBaseTracer(handler)) {\n                    // Create and add run to the run map.\n                    // We do this synchronously to avoid race conditions\n                    // when callbacks are backgrounded.\n                    handler._createRunForChatModelStart(llm, [messageGroup], runId_, this._parentRunId, extraParams, this.tags, this.metadata, runName);\n                }\n                return consumeCallback(async () => {\n                    try {\n                        if (handler.handleChatModelStart) {\n                            await handler.handleChatModelStart?.(llm, [messageGroup], runId_, this._parentRunId, extraParams, this.tags, this.metadata, runName);\n                        }\n                        else if (handler.handleLLMStart) {\n                            const messageString = getBufferString(messageGroup);\n                            await handler.handleLLMStart?.(llm, [messageString], runId_, this._parentRunId, extraParams, this.tags, this.metadata, runName);\n                        }\n                    }\n                    catch (err) {\n                        const logFunction = handler.raiseError\n                            ? console.error\n                            : console.warn;\n                        logFunction(`Error in handler ${handler.constructor.name}, handleLLMStart: ${err}`);\n                        if (handler.raiseError) {\n                            throw err;\n                        }\n                    }\n                }, handler.awaitHandlers);\n            }));\n            return new CallbackManagerForLLMRun(runId_, this.handlers, this.inheritableHandlers, this.tags, this.inheritableTags, this.metadata, this.inheritableMetadata, this._parentRunId);\n        }));\n    }\n    async handleChainStart(chain, inputs, runId = uuidv4(), runType = undefined, _tags = undefined, _metadata = undefined, runName = undefined) {\n        await Promise.all(this.handlers.map((handler) => {\n            if (handler.ignoreChain) {\n                return;\n            }\n            if (isBaseTracer(handler)) {\n                // Create and add run to the run map.\n                // We do this synchronously to avoid race conditions\n                // when callbacks are backgrounded.\n                handler._createRunForChainStart(chain, inputs, runId, this._parentRunId, this.tags, this.metadata, runType, runName);\n            }\n            return consumeCallback(async () => {\n                try {\n                    await handler.handleChainStart?.(chain, inputs, runId, this._parentRunId, this.tags, this.metadata, runType, runName);\n                }\n                catch (err) {\n                    const logFunction = handler.raiseError\n                        ? console.error\n                        : console.warn;\n                    logFunction(`Error in handler ${handler.constructor.name}, handleChainStart: ${err}`);\n                    if (handler.raiseError) {\n                        throw err;\n                    }\n                }\n            }, handler.awaitHandlers);\n        }));\n        return new CallbackManagerForChainRun(runId, this.handlers, this.inheritableHandlers, this.tags, this.inheritableTags, this.metadata, this.inheritableMetadata, this._parentRunId);\n    }\n    async handleToolStart(tool, input, runId = uuidv4(), _parentRunId = undefined, _tags = undefined, _metadata = undefined, runName = undefined) {\n        await Promise.all(this.handlers.map((handler) => {\n            if (handler.ignoreAgent) {\n                return;\n            }\n            if (isBaseTracer(handler)) {\n                // Create and add run to the run map.\n                // We do this synchronously to avoid race conditions\n                // when callbacks are backgrounded.\n                handler._createRunForToolStart(tool, input, runId, this._parentRunId, this.tags, this.metadata, runName);\n            }\n            return consumeCallback(async () => {\n                try {\n                    await handler.handleToolStart?.(tool, input, runId, this._parentRunId, this.tags, this.metadata, runName);\n                }\n                catch (err) {\n                    const logFunction = handler.raiseError\n                        ? console.error\n                        : console.warn;\n                    logFunction(`Error in handler ${handler.constructor.name}, handleToolStart: ${err}`);\n                    if (handler.raiseError) {\n                        throw err;\n                    }\n                }\n            }, handler.awaitHandlers);\n        }));\n        return new CallbackManagerForToolRun(runId, this.handlers, this.inheritableHandlers, this.tags, this.inheritableTags, this.metadata, this.inheritableMetadata, this._parentRunId);\n    }\n    async handleRetrieverStart(retriever, query, runId = uuidv4(), _parentRunId = undefined, _tags = undefined, _metadata = undefined, runName = undefined) {\n        await Promise.all(this.handlers.map((handler) => {\n            if (handler.ignoreRetriever) {\n                return;\n            }\n            if (isBaseTracer(handler)) {\n                // Create and add run to the run map.\n                // We do this synchronously to avoid race conditions\n                // when callbacks are backgrounded.\n                handler._createRunForRetrieverStart(retriever, query, runId, this._parentRunId, this.tags, this.metadata, runName);\n            }\n            return consumeCallback(async () => {\n                try {\n                    await handler.handleRetrieverStart?.(retriever, query, runId, this._parentRunId, this.tags, this.metadata, runName);\n                }\n                catch (err) {\n                    const logFunction = handler.raiseError\n                        ? console.error\n                        : console.warn;\n                    logFunction(`Error in handler ${handler.constructor.name}, handleRetrieverStart: ${err}`);\n                    if (handler.raiseError) {\n                        throw err;\n                    }\n                }\n            }, handler.awaitHandlers);\n        }));\n        return new CallbackManagerForRetrieverRun(runId, this.handlers, this.inheritableHandlers, this.tags, this.inheritableTags, this.metadata, this.inheritableMetadata, this._parentRunId);\n    }\n    async handleCustomEvent(eventName, \n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    data, runId, _tags, \n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    _metadata) {\n        await Promise.all(this.handlers.map((handler) => consumeCallback(async () => {\n            if (!handler.ignoreCustomEvent) {\n                try {\n                    await handler.handleCustomEvent?.(eventName, data, runId, this.tags, this.metadata);\n                }\n                catch (err) {\n                    const logFunction = handler.raiseError\n                        ? console.error\n                        : console.warn;\n                    logFunction(`Error in handler ${handler.constructor.name}, handleCustomEvent: ${err}`);\n                    if (handler.raiseError) {\n                        throw err;\n                    }\n                }\n            }\n        }, handler.awaitHandlers)));\n    }\n    addHandler(handler, inherit = true) {\n        this.handlers.push(handler);\n        if (inherit) {\n            this.inheritableHandlers.push(handler);\n        }\n    }\n    removeHandler(handler) {\n        this.handlers = this.handlers.filter((_handler) => _handler !== handler);\n        this.inheritableHandlers = this.inheritableHandlers.filter((_handler) => _handler !== handler);\n    }\n    setHandlers(handlers, inherit = true) {\n        this.handlers = [];\n        this.inheritableHandlers = [];\n        for (const handler of handlers) {\n            this.addHandler(handler, inherit);\n        }\n    }\n    addTags(tags, inherit = true) {\n        this.removeTags(tags); // Remove duplicates\n        this.tags.push(...tags);\n        if (inherit) {\n            this.inheritableTags.push(...tags);\n        }\n    }\n    removeTags(tags) {\n        this.tags = this.tags.filter((tag) => !tags.includes(tag));\n        this.inheritableTags = this.inheritableTags.filter((tag) => !tags.includes(tag));\n    }\n    addMetadata(metadata, inherit = true) {\n        this.metadata = { ...this.metadata, ...metadata };\n        if (inherit) {\n            this.inheritableMetadata = { ...this.inheritableMetadata, ...metadata };\n        }\n    }\n    removeMetadata(metadata) {\n        for (const key of Object.keys(metadata)) {\n            delete this.metadata[key];\n            delete this.inheritableMetadata[key];\n        }\n    }\n    copy(additionalHandlers = [], inherit = true) {\n        const manager = new CallbackManager(this._parentRunId);\n        for (const handler of this.handlers) {\n            const inheritable = this.inheritableHandlers.includes(handler);\n            manager.addHandler(handler, inheritable);\n        }\n        for (const tag of this.tags) {\n            const inheritable = this.inheritableTags.includes(tag);\n            manager.addTags([tag], inheritable);\n        }\n        for (const key of Object.keys(this.metadata)) {\n            const inheritable = Object.keys(this.inheritableMetadata).includes(key);\n            manager.addMetadata({ [key]: this.metadata[key] }, inheritable);\n        }\n        for (const handler of additionalHandlers) {\n            if (\n            // Prevent multiple copies of console_callback_handler\n            manager.handlers\n                .filter((h) => h.name === \"console_callback_handler\")\n                .some((h) => h.name === handler.name)) {\n                continue;\n            }\n            manager.addHandler(handler, inherit);\n        }\n        return manager;\n    }\n    static fromHandlers(handlers) {\n        class Handler extends BaseCallbackHandler {\n            constructor() {\n                super();\n                Object.defineProperty(this, \"name\", {\n                    enumerable: true,\n                    configurable: true,\n                    writable: true,\n                    value: uuidv4()\n                });\n                Object.assign(this, handlers);\n            }\n        }\n        const manager = new this();\n        manager.addHandler(new Handler());\n        return manager;\n    }\n    static configure(inheritableHandlers, localHandlers, inheritableTags, localTags, inheritableMetadata, localMetadata, options) {\n        return this._configureSync(inheritableHandlers, localHandlers, inheritableTags, localTags, inheritableMetadata, localMetadata, options);\n    }\n    // TODO: Deprecate async method in favor of this one.\n    static _configureSync(inheritableHandlers, localHandlers, inheritableTags, localTags, inheritableMetadata, localMetadata, options) {\n        let callbackManager;\n        if (inheritableHandlers || localHandlers) {\n            if (Array.isArray(inheritableHandlers) || !inheritableHandlers) {\n                callbackManager = new CallbackManager();\n                callbackManager.setHandlers(inheritableHandlers?.map(ensureHandler) ?? [], true);\n            }\n            else {\n                callbackManager = inheritableHandlers;\n            }\n            callbackManager = callbackManager.copy(Array.isArray(localHandlers)\n                ? localHandlers.map(ensureHandler)\n                : localHandlers?.handlers, false);\n        }\n        const verboseEnabled = getEnvironmentVariable(\"LANGCHAIN_VERBOSE\") === \"true\" ||\n            options?.verbose;\n        const tracingV2Enabled = LangChainTracer.getTraceableRunTree()?.tracingEnabled ||\n            isTracingEnabled();\n        const tracingEnabled = tracingV2Enabled ||\n            (getEnvironmentVariable(\"LANGCHAIN_TRACING\") ?? false);\n        if (verboseEnabled || tracingEnabled) {\n            if (!callbackManager) {\n                callbackManager = new CallbackManager();\n            }\n            if (verboseEnabled &&\n                !callbackManager.handlers.some((handler) => handler.name === ConsoleCallbackHandler.prototype.name)) {\n                const consoleHandler = new ConsoleCallbackHandler();\n                callbackManager.addHandler(consoleHandler, true);\n            }\n            if (tracingEnabled &&\n                !callbackManager.handlers.some((handler) => handler.name === \"langchain_tracer\")) {\n                if (tracingV2Enabled) {\n                    const tracerV2 = new LangChainTracer();\n                    callbackManager.addHandler(tracerV2, true);\n                    // handoff between langchain and langsmith/traceable\n                    // override the parent run ID\n                    callbackManager._parentRunId =\n                        LangChainTracer.getTraceableRunTree()?.id ??\n                            callbackManager._parentRunId;\n                }\n            }\n        }\n        for (const { contextVar, inheritable = true, handlerClass, envVar, } of _getConfigureHooks()) {\n            const createIfNotInContext = envVar && getEnvironmentVariable(envVar) === \"true\" && handlerClass;\n            let handler;\n            const contextVarValue = contextVar !== undefined ? getContextVariable(contextVar) : undefined;\n            if (contextVarValue && isBaseCallbackHandler(contextVarValue)) {\n                handler = contextVarValue;\n            }\n            else if (createIfNotInContext) {\n                // eslint-disable-next-line @typescript-eslint/no-explicit-any\n                handler = new handlerClass({});\n            }\n            if (handler !== undefined) {\n                if (!callbackManager) {\n                    callbackManager = new CallbackManager();\n                }\n                if (!callbackManager.handlers.some((h) => h.name === handler.name)) {\n                    callbackManager.addHandler(handler, inheritable);\n                }\n            }\n        }\n        if (inheritableTags || localTags) {\n            if (callbackManager) {\n                callbackManager.addTags(inheritableTags ?? []);\n                callbackManager.addTags(localTags ?? [], false);\n            }\n        }\n        if (inheritableMetadata || localMetadata) {\n            if (callbackManager) {\n                callbackManager.addMetadata(inheritableMetadata ?? {});\n                callbackManager.addMetadata(localMetadata ?? {}, false);\n            }\n        }\n        return callbackManager;\n    }\n}\nexport function ensureHandler(handler) {\n    if (\"name\" in handler) {\n        return handler;\n    }\n    return BaseCallbackHandler.fromMethods(handler);\n}\n/**\n * @deprecated Use [`traceable`](https://docs.smith.langchain.com/observability/how_to_guides/tracing/annotate_code)\n * from \"langsmith\" instead.\n */\nexport class TraceGroup {\n    constructor(groupName, options) {\n        Object.defineProperty(this, \"groupName\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: groupName\n        });\n        Object.defineProperty(this, \"options\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: options\n        });\n        Object.defineProperty(this, \"runManager\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n    }\n    async getTraceGroupCallbackManager(group_name, inputs, options) {\n        const cb = new LangChainTracer(options);\n        const cm = await CallbackManager.configure([cb]);\n        const runManager = await cm?.handleChainStart({\n            lc: 1,\n            type: \"not_implemented\",\n            id: [\"langchain\", \"callbacks\", \"groups\", group_name],\n        }, inputs ?? {});\n        if (!runManager) {\n            throw new Error(\"Failed to create run group callback manager.\");\n        }\n        return runManager;\n    }\n    async start(inputs) {\n        if (!this.runManager) {\n            this.runManager = await this.getTraceGroupCallbackManager(this.groupName, inputs, this.options);\n        }\n        return this.runManager.getChild();\n    }\n    async error(err) {\n        if (this.runManager) {\n            await this.runManager.handleChainError(err);\n            this.runManager = undefined;\n        }\n    }\n    async end(output) {\n        if (this.runManager) {\n            await this.runManager.handleChainEnd(output ?? {});\n            this.runManager = undefined;\n        }\n    }\n}\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nfunction _coerceToDict(value, defaultKey) {\n    return value && !Array.isArray(value) && typeof value === \"object\"\n        ? value\n        : { [defaultKey]: value };\n}\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport async function traceAsGroup(groupOptions, enclosedCode, ...args) {\n    const traceGroup = new TraceGroup(groupOptions.name, groupOptions);\n    const callbackManager = await traceGroup.start({ ...args });\n    try {\n        const result = await enclosedCode(callbackManager, ...args);\n        await traceGroup.end(_coerceToDict(result, \"output\"));\n        return result;\n    }\n    catch (err) {\n        await traceGroup.error(err);\n        throw err;\n    }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}