{"ast":null,"code":"import { Runnable, _coerceToDict, _coerceToRunnable } from \"./base.js\";\nimport { getCallbackManagerForConfig, patchConfig } from \"./config.js\";\nimport { concat } from \"../utils/stream.js\";\n/**\n * Class that represents a runnable branch. The RunnableBranch is\n * initialized with an array of branches and a default branch. When invoked,\n * it evaluates the condition of each branch in order and executes the\n * corresponding branch if the condition is true. If none of the conditions\n * are true, it executes the default branch.\n * @example\n * ```typescript\n * const branch = RunnableBranch.from([\n *   [\n *     (x: { topic: string; question: string }) =>\n *       x.topic.toLowerCase().includes(\"anthropic\"),\n *     anthropicChain,\n *   ],\n *   [\n *     (x: { topic: string; question: string }) =>\n *       x.topic.toLowerCase().includes(\"langchain\"),\n *     langChainChain,\n *   ],\n *   generalChain,\n * ]);\n *\n * const fullChain = RunnableSequence.from([\n *   {\n *     topic: classificationChain,\n *     question: (input: { question: string }) => input.question,\n *   },\n *   branch,\n * ]);\n *\n * const result = await fullChain.invoke({\n *   question: \"how do I use LangChain?\",\n * });\n * ```\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport class RunnableBranch extends Runnable {\n  static lc_name() {\n    return \"RunnableBranch\";\n  }\n  constructor(fields) {\n    super(fields);\n    Object.defineProperty(this, \"lc_namespace\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: [\"langchain_core\", \"runnables\"]\n    });\n    Object.defineProperty(this, \"lc_serializable\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: true\n    });\n    Object.defineProperty(this, \"default\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, \"branches\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    this.branches = fields.branches;\n    this.default = fields.default;\n  }\n  /**\n   * Convenience method for instantiating a RunnableBranch from\n   * RunnableLikes (objects, functions, or Runnables).\n   *\n   * Each item in the input except for the last one should be a\n   * tuple with two items. The first is a \"condition\" RunnableLike that\n   * returns \"true\" if the second RunnableLike in the tuple should run.\n   *\n   * The final item in the input should be a RunnableLike that acts as a\n   * default branch if no other branches match.\n   *\n   * @example\n   * ```ts\n   * import { RunnableBranch } from \"@langchain/core/runnables\";\n   *\n   * const branch = RunnableBranch.from([\n   *   [(x: number) => x > 0, (x: number) => x + 1],\n   *   [(x: number) => x < 0, (x: number) => x - 1],\n   *   (x: number) => x\n   * ]);\n   * ```\n   * @param branches An array where the every item except the last is a tuple of [condition, runnable]\n   *   pairs. The last item is a default runnable which is invoked if no other condition matches.\n   * @returns A new RunnableBranch.\n   */\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  static from(branches) {\n    if (branches.length < 1) {\n      throw new Error(\"RunnableBranch requires at least one branch\");\n    }\n    const branchLikes = branches.slice(0, -1);\n    const coercedBranches = branchLikes.map(([condition, runnable]) => [_coerceToRunnable(condition), _coerceToRunnable(runnable)]);\n    const defaultBranch = _coerceToRunnable(branches[branches.length - 1]);\n    return new this({\n      branches: coercedBranches,\n      default: defaultBranch\n    });\n  }\n  async _invoke(input, config, runManager) {\n    let result;\n    for (let i = 0; i < this.branches.length; i += 1) {\n      const [condition, branchRunnable] = this.branches[i];\n      const conditionValue = await condition.invoke(input, patchConfig(config, {\n        callbacks: runManager?.getChild(`condition:${i + 1}`)\n      }));\n      if (conditionValue) {\n        result = await branchRunnable.invoke(input, patchConfig(config, {\n          callbacks: runManager?.getChild(`branch:${i + 1}`)\n        }));\n        break;\n      }\n    }\n    if (!result) {\n      result = await this.default.invoke(input, patchConfig(config, {\n        callbacks: runManager?.getChild(\"branch:default\")\n      }));\n    }\n    return result;\n  }\n  async invoke(input, config = {}) {\n    return this._callWithConfig(this._invoke, input, config);\n  }\n  async *_streamIterator(input, config) {\n    const callbackManager_ = await getCallbackManagerForConfig(config);\n    const runManager = await callbackManager_?.handleChainStart(this.toJSON(), _coerceToDict(input, \"input\"), config?.runId, undefined, undefined, undefined, config?.runName);\n    let finalOutput;\n    let finalOutputSupported = true;\n    let stream;\n    try {\n      for (let i = 0; i < this.branches.length; i += 1) {\n        const [condition, branchRunnable] = this.branches[i];\n        const conditionValue = await condition.invoke(input, patchConfig(config, {\n          callbacks: runManager?.getChild(`condition:${i + 1}`)\n        }));\n        if (conditionValue) {\n          stream = await branchRunnable.stream(input, patchConfig(config, {\n            callbacks: runManager?.getChild(`branch:${i + 1}`)\n          }));\n          for await (const chunk of stream) {\n            yield chunk;\n            if (finalOutputSupported) {\n              if (finalOutput === undefined) {\n                finalOutput = chunk;\n              } else {\n                try {\n                  finalOutput = concat(finalOutput, chunk);\n                } catch (e) {\n                  finalOutput = undefined;\n                  finalOutputSupported = false;\n                }\n              }\n            }\n          }\n          break;\n        }\n      }\n      if (stream === undefined) {\n        stream = await this.default.stream(input, patchConfig(config, {\n          callbacks: runManager?.getChild(\"branch:default\")\n        }));\n        for await (const chunk of stream) {\n          yield chunk;\n          if (finalOutputSupported) {\n            if (finalOutput === undefined) {\n              finalOutput = chunk;\n            } else {\n              try {\n                finalOutput = concat(finalOutput, chunk);\n              } catch (e) {\n                finalOutput = undefined;\n                finalOutputSupported = false;\n              }\n            }\n          }\n        }\n      }\n    } catch (e) {\n      await runManager?.handleChainError(e);\n      throw e;\n    }\n    await runManager?.handleChainEnd(finalOutput ?? {});\n  }\n}","map":{"version":3,"names":["Runnable","_coerceToDict","_coerceToRunnable","getCallbackManagerForConfig","patchConfig","concat","RunnableBranch","lc_name","constructor","fields","Object","defineProperty","enumerable","configurable","writable","value","branches","default","from","length","Error","branchLikes","slice","coercedBranches","map","condition","runnable","defaultBranch","_invoke","input","config","runManager","result","i","branchRunnable","conditionValue","invoke","callbacks","getChild","_callWithConfig","_streamIterator","callbackManager_","handleChainStart","toJSON","runId","undefined","runName","finalOutput","finalOutputSupported","stream","chunk","e","handleChainError","handleChainEnd"],"sources":["/Users/youngchen/Downloads/cs224g-triage/node_modules/@langchain/core/dist/runnables/branch.js"],"sourcesContent":["import { Runnable, _coerceToDict, _coerceToRunnable, } from \"./base.js\";\nimport { getCallbackManagerForConfig, patchConfig, } from \"./config.js\";\nimport { concat } from \"../utils/stream.js\";\n/**\n * Class that represents a runnable branch. The RunnableBranch is\n * initialized with an array of branches and a default branch. When invoked,\n * it evaluates the condition of each branch in order and executes the\n * corresponding branch if the condition is true. If none of the conditions\n * are true, it executes the default branch.\n * @example\n * ```typescript\n * const branch = RunnableBranch.from([\n *   [\n *     (x: { topic: string; question: string }) =>\n *       x.topic.toLowerCase().includes(\"anthropic\"),\n *     anthropicChain,\n *   ],\n *   [\n *     (x: { topic: string; question: string }) =>\n *       x.topic.toLowerCase().includes(\"langchain\"),\n *     langChainChain,\n *   ],\n *   generalChain,\n * ]);\n *\n * const fullChain = RunnableSequence.from([\n *   {\n *     topic: classificationChain,\n *     question: (input: { question: string }) => input.question,\n *   },\n *   branch,\n * ]);\n *\n * const result = await fullChain.invoke({\n *   question: \"how do I use LangChain?\",\n * });\n * ```\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport class RunnableBranch extends Runnable {\n    static lc_name() {\n        return \"RunnableBranch\";\n    }\n    constructor(fields) {\n        super(fields);\n        Object.defineProperty(this, \"lc_namespace\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: [\"langchain_core\", \"runnables\"]\n        });\n        Object.defineProperty(this, \"lc_serializable\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: true\n        });\n        Object.defineProperty(this, \"default\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"branches\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.branches = fields.branches;\n        this.default = fields.default;\n    }\n    /**\n     * Convenience method for instantiating a RunnableBranch from\n     * RunnableLikes (objects, functions, or Runnables).\n     *\n     * Each item in the input except for the last one should be a\n     * tuple with two items. The first is a \"condition\" RunnableLike that\n     * returns \"true\" if the second RunnableLike in the tuple should run.\n     *\n     * The final item in the input should be a RunnableLike that acts as a\n     * default branch if no other branches match.\n     *\n     * @example\n     * ```ts\n     * import { RunnableBranch } from \"@langchain/core/runnables\";\n     *\n     * const branch = RunnableBranch.from([\n     *   [(x: number) => x > 0, (x: number) => x + 1],\n     *   [(x: number) => x < 0, (x: number) => x - 1],\n     *   (x: number) => x\n     * ]);\n     * ```\n     * @param branches An array where the every item except the last is a tuple of [condition, runnable]\n     *   pairs. The last item is a default runnable which is invoked if no other condition matches.\n     * @returns A new RunnableBranch.\n     */\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    static from(branches) {\n        if (branches.length < 1) {\n            throw new Error(\"RunnableBranch requires at least one branch\");\n        }\n        const branchLikes = branches.slice(0, -1);\n        const coercedBranches = branchLikes.map(([condition, runnable]) => [\n            _coerceToRunnable(condition),\n            _coerceToRunnable(runnable),\n        ]);\n        const defaultBranch = _coerceToRunnable(branches[branches.length - 1]);\n        return new this({\n            branches: coercedBranches,\n            default: defaultBranch,\n        });\n    }\n    async _invoke(input, config, runManager) {\n        let result;\n        for (let i = 0; i < this.branches.length; i += 1) {\n            const [condition, branchRunnable] = this.branches[i];\n            const conditionValue = await condition.invoke(input, patchConfig(config, {\n                callbacks: runManager?.getChild(`condition:${i + 1}`),\n            }));\n            if (conditionValue) {\n                result = await branchRunnable.invoke(input, patchConfig(config, {\n                    callbacks: runManager?.getChild(`branch:${i + 1}`),\n                }));\n                break;\n            }\n        }\n        if (!result) {\n            result = await this.default.invoke(input, patchConfig(config, {\n                callbacks: runManager?.getChild(\"branch:default\"),\n            }));\n        }\n        return result;\n    }\n    async invoke(input, config = {}) {\n        return this._callWithConfig(this._invoke, input, config);\n    }\n    async *_streamIterator(input, config) {\n        const callbackManager_ = await getCallbackManagerForConfig(config);\n        const runManager = await callbackManager_?.handleChainStart(this.toJSON(), _coerceToDict(input, \"input\"), config?.runId, undefined, undefined, undefined, config?.runName);\n        let finalOutput;\n        let finalOutputSupported = true;\n        let stream;\n        try {\n            for (let i = 0; i < this.branches.length; i += 1) {\n                const [condition, branchRunnable] = this.branches[i];\n                const conditionValue = await condition.invoke(input, patchConfig(config, {\n                    callbacks: runManager?.getChild(`condition:${i + 1}`),\n                }));\n                if (conditionValue) {\n                    stream = await branchRunnable.stream(input, patchConfig(config, {\n                        callbacks: runManager?.getChild(`branch:${i + 1}`),\n                    }));\n                    for await (const chunk of stream) {\n                        yield chunk;\n                        if (finalOutputSupported) {\n                            if (finalOutput === undefined) {\n                                finalOutput = chunk;\n                            }\n                            else {\n                                try {\n                                    finalOutput = concat(finalOutput, chunk);\n                                }\n                                catch (e) {\n                                    finalOutput = undefined;\n                                    finalOutputSupported = false;\n                                }\n                            }\n                        }\n                    }\n                    break;\n                }\n            }\n            if (stream === undefined) {\n                stream = await this.default.stream(input, patchConfig(config, {\n                    callbacks: runManager?.getChild(\"branch:default\"),\n                }));\n                for await (const chunk of stream) {\n                    yield chunk;\n                    if (finalOutputSupported) {\n                        if (finalOutput === undefined) {\n                            finalOutput = chunk;\n                        }\n                        else {\n                            try {\n                                finalOutput = concat(finalOutput, chunk);\n                            }\n                            catch (e) {\n                                finalOutput = undefined;\n                                finalOutputSupported = false;\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        catch (e) {\n            await runManager?.handleChainError(e);\n            throw e;\n        }\n        await runManager?.handleChainEnd(finalOutput ?? {});\n    }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}