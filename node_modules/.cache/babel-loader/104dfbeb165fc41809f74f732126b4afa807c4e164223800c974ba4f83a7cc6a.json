{"ast":null,"code":"import { parsePartialJson } from \"../utils/json.js\";\nimport { BaseMessage, BaseMessageChunk, mergeContent, _mergeDicts, _mergeLists } from \"./base.js\";\nimport { defaultToolCallParser } from \"./tool.js\";\n/**\n * Represents an AI message in a conversation.\n */\nexport class AIMessage extends BaseMessage {\n  get lc_aliases() {\n    // exclude snake case conversion to pascal case\n    return {\n      ...super.lc_aliases,\n      tool_calls: \"tool_calls\",\n      invalid_tool_calls: \"invalid_tool_calls\"\n    };\n  }\n  constructor(fields, /** @deprecated */\n  kwargs) {\n    let initParams;\n    if (typeof fields === \"string\") {\n      initParams = {\n        content: fields,\n        tool_calls: [],\n        invalid_tool_calls: [],\n        additional_kwargs: kwargs ?? {}\n      };\n    } else {\n      initParams = fields;\n      const rawToolCalls = initParams.additional_kwargs?.tool_calls;\n      const toolCalls = initParams.tool_calls;\n      if (!(rawToolCalls == null) && rawToolCalls.length > 0 && (toolCalls === undefined || toolCalls.length === 0)) {\n        console.warn([\"New LangChain packages are available that more efficiently handle\", \"tool calling.\\n\\nPlease upgrade your packages to versions that set\", \"message tool calls. e.g., `yarn add @langchain/anthropic`,\", \"yarn add @langchain/openai`, etc.\"].join(\" \"));\n      }\n      try {\n        if (!(rawToolCalls == null) && toolCalls === undefined) {\n          const [toolCalls, invalidToolCalls] = defaultToolCallParser(rawToolCalls);\n          initParams.tool_calls = toolCalls ?? [];\n          initParams.invalid_tool_calls = invalidToolCalls ?? [];\n        } else {\n          initParams.tool_calls = initParams.tool_calls ?? [];\n          initParams.invalid_tool_calls = initParams.invalid_tool_calls ?? [];\n        }\n      } catch (e) {\n        // Do nothing if parsing fails\n        initParams.tool_calls = [];\n        initParams.invalid_tool_calls = [];\n      }\n    }\n    // Sadly, TypeScript only allows super() calls at root if the class has\n    // properties with initializers, so we have to check types twice.\n    super(initParams);\n    // These are typed as optional to avoid breaking changes and allow for casting\n    // from BaseMessage.\n    Object.defineProperty(this, \"tool_calls\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: []\n    });\n    Object.defineProperty(this, \"invalid_tool_calls\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: []\n    });\n    /**\n     * If provided, token usage information associated with the message.\n     */\n    Object.defineProperty(this, \"usage_metadata\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    if (typeof initParams !== \"string\") {\n      this.tool_calls = initParams.tool_calls ?? this.tool_calls;\n      this.invalid_tool_calls = initParams.invalid_tool_calls ?? this.invalid_tool_calls;\n    }\n    this.usage_metadata = initParams.usage_metadata;\n  }\n  static lc_name() {\n    return \"AIMessage\";\n  }\n  _getType() {\n    return \"ai\";\n  }\n  get _printableFields() {\n    return {\n      ...super._printableFields,\n      tool_calls: this.tool_calls,\n      invalid_tool_calls: this.invalid_tool_calls,\n      usage_metadata: this.usage_metadata\n    };\n  }\n}\nexport function isAIMessage(x) {\n  return x._getType() === \"ai\";\n}\nexport function isAIMessageChunk(x) {\n  return x._getType() === \"ai\";\n}\n/**\n * Represents a chunk of an AI message, which can be concatenated with\n * other AI message chunks.\n */\nexport class AIMessageChunk extends BaseMessageChunk {\n  constructor(fields) {\n    let initParams;\n    if (typeof fields === \"string\") {\n      initParams = {\n        content: fields,\n        tool_calls: [],\n        invalid_tool_calls: [],\n        tool_call_chunks: []\n      };\n    } else if (fields.tool_call_chunks === undefined) {\n      initParams = {\n        ...fields,\n        tool_calls: fields.tool_calls ?? [],\n        invalid_tool_calls: [],\n        tool_call_chunks: [],\n        usage_metadata: fields.usage_metadata !== undefined ? fields.usage_metadata : undefined\n      };\n    } else {\n      const toolCalls = [];\n      const invalidToolCalls = [];\n      for (const toolCallChunk of fields.tool_call_chunks) {\n        let parsedArgs = {};\n        try {\n          parsedArgs = parsePartialJson(toolCallChunk.args || \"{}\");\n          if (parsedArgs === null || typeof parsedArgs !== \"object\" || Array.isArray(parsedArgs)) {\n            throw new Error(\"Malformed tool call chunk args.\");\n          }\n          toolCalls.push({\n            name: toolCallChunk.name ?? \"\",\n            args: parsedArgs,\n            id: toolCallChunk.id,\n            type: \"tool_call\"\n          });\n        } catch (e) {\n          invalidToolCalls.push({\n            name: toolCallChunk.name,\n            args: toolCallChunk.args,\n            id: toolCallChunk.id,\n            error: \"Malformed args.\",\n            type: \"invalid_tool_call\"\n          });\n        }\n      }\n      initParams = {\n        ...fields,\n        tool_calls: toolCalls,\n        invalid_tool_calls: invalidToolCalls,\n        usage_metadata: fields.usage_metadata !== undefined ? fields.usage_metadata : undefined\n      };\n    }\n    // Sadly, TypeScript only allows super() calls at root if the class has\n    // properties with initializers, so we have to check types twice.\n    super(initParams);\n    // Must redeclare tool call fields since there is no multiple inheritance in JS.\n    // These are typed as optional to avoid breaking changes and allow for casting\n    // from BaseMessage.\n    Object.defineProperty(this, \"tool_calls\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: []\n    });\n    Object.defineProperty(this, \"invalid_tool_calls\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: []\n    });\n    Object.defineProperty(this, \"tool_call_chunks\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: []\n    });\n    /**\n     * If provided, token usage information associated with the message.\n     */\n    Object.defineProperty(this, \"usage_metadata\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    this.tool_call_chunks = initParams.tool_call_chunks ?? this.tool_call_chunks;\n    this.tool_calls = initParams.tool_calls ?? this.tool_calls;\n    this.invalid_tool_calls = initParams.invalid_tool_calls ?? this.invalid_tool_calls;\n    this.usage_metadata = initParams.usage_metadata;\n  }\n  get lc_aliases() {\n    // exclude snake case conversion to pascal case\n    return {\n      ...super.lc_aliases,\n      tool_calls: \"tool_calls\",\n      invalid_tool_calls: \"invalid_tool_calls\",\n      tool_call_chunks: \"tool_call_chunks\"\n    };\n  }\n  static lc_name() {\n    return \"AIMessageChunk\";\n  }\n  _getType() {\n    return \"ai\";\n  }\n  get _printableFields() {\n    return {\n      ...super._printableFields,\n      tool_calls: this.tool_calls,\n      tool_call_chunks: this.tool_call_chunks,\n      invalid_tool_calls: this.invalid_tool_calls,\n      usage_metadata: this.usage_metadata\n    };\n  }\n  concat(chunk) {\n    const combinedFields = {\n      content: mergeContent(this.content, chunk.content),\n      additional_kwargs: _mergeDicts(this.additional_kwargs, chunk.additional_kwargs),\n      response_metadata: _mergeDicts(this.response_metadata, chunk.response_metadata),\n      tool_call_chunks: [],\n      id: this.id ?? chunk.id\n    };\n    if (this.tool_call_chunks !== undefined || chunk.tool_call_chunks !== undefined) {\n      const rawToolCalls = _mergeLists(this.tool_call_chunks, chunk.tool_call_chunks);\n      if (rawToolCalls !== undefined && rawToolCalls.length > 0) {\n        combinedFields.tool_call_chunks = rawToolCalls;\n      }\n    }\n    if (this.usage_metadata !== undefined || chunk.usage_metadata !== undefined) {\n      const inputTokenDetails = {\n        ...((this.usage_metadata?.input_token_details?.audio !== undefined || chunk.usage_metadata?.input_token_details?.audio !== undefined) && {\n          audio: (this.usage_metadata?.input_token_details?.audio ?? 0) + (chunk.usage_metadata?.input_token_details?.audio ?? 0)\n        }),\n        ...((this.usage_metadata?.input_token_details?.cache_read !== undefined || chunk.usage_metadata?.input_token_details?.cache_read !== undefined) && {\n          cache_read: (this.usage_metadata?.input_token_details?.cache_read ?? 0) + (chunk.usage_metadata?.input_token_details?.cache_read ?? 0)\n        }),\n        ...((this.usage_metadata?.input_token_details?.cache_creation !== undefined || chunk.usage_metadata?.input_token_details?.cache_creation !== undefined) && {\n          cache_creation: (this.usage_metadata?.input_token_details?.cache_creation ?? 0) + (chunk.usage_metadata?.input_token_details?.cache_creation ?? 0)\n        })\n      };\n      const outputTokenDetails = {\n        ...((this.usage_metadata?.output_token_details?.audio !== undefined || chunk.usage_metadata?.output_token_details?.audio !== undefined) && {\n          audio: (this.usage_metadata?.output_token_details?.audio ?? 0) + (chunk.usage_metadata?.output_token_details?.audio ?? 0)\n        }),\n        ...((this.usage_metadata?.output_token_details?.reasoning !== undefined || chunk.usage_metadata?.output_token_details?.reasoning !== undefined) && {\n          reasoning: (this.usage_metadata?.output_token_details?.reasoning ?? 0) + (chunk.usage_metadata?.output_token_details?.reasoning ?? 0)\n        })\n      };\n      const left = this.usage_metadata ?? {\n        input_tokens: 0,\n        output_tokens: 0,\n        total_tokens: 0\n      };\n      const right = chunk.usage_metadata ?? {\n        input_tokens: 0,\n        output_tokens: 0,\n        total_tokens: 0\n      };\n      const usage_metadata = {\n        input_tokens: left.input_tokens + right.input_tokens,\n        output_tokens: left.output_tokens + right.output_tokens,\n        total_tokens: left.total_tokens + right.total_tokens,\n        // Do not include `input_token_details` / `output_token_details` keys in combined fields\n        // unless their values are defined.\n        ...(Object.keys(inputTokenDetails).length > 0 && {\n          input_token_details: inputTokenDetails\n        }),\n        ...(Object.keys(outputTokenDetails).length > 0 && {\n          output_token_details: outputTokenDetails\n        })\n      };\n      combinedFields.usage_metadata = usage_metadata;\n    }\n    return new AIMessageChunk(combinedFields);\n  }\n}","map":{"version":3,"names":["parsePartialJson","BaseMessage","BaseMessageChunk","mergeContent","_mergeDicts","_mergeLists","defaultToolCallParser","AIMessage","lc_aliases","tool_calls","invalid_tool_calls","constructor","fields","kwargs","initParams","content","additional_kwargs","rawToolCalls","toolCalls","length","undefined","console","warn","join","invalidToolCalls","e","Object","defineProperty","enumerable","configurable","writable","value","usage_metadata","lc_name","_getType","_printableFields","isAIMessage","x","isAIMessageChunk","AIMessageChunk","tool_call_chunks","toolCallChunk","parsedArgs","args","Array","isArray","Error","push","name","id","type","error","concat","chunk","combinedFields","response_metadata","inputTokenDetails","input_token_details","audio","cache_read","cache_creation","outputTokenDetails","output_token_details","reasoning","left","input_tokens","output_tokens","total_tokens","right","keys"],"sources":["/Users/youngchen/Downloads/cs224g-triage/node_modules/@langchain/core/dist/messages/ai.js"],"sourcesContent":["import { parsePartialJson } from \"../utils/json.js\";\nimport { BaseMessage, BaseMessageChunk, mergeContent, _mergeDicts, _mergeLists, } from \"./base.js\";\nimport { defaultToolCallParser, } from \"./tool.js\";\n/**\n * Represents an AI message in a conversation.\n */\nexport class AIMessage extends BaseMessage {\n    get lc_aliases() {\n        // exclude snake case conversion to pascal case\n        return {\n            ...super.lc_aliases,\n            tool_calls: \"tool_calls\",\n            invalid_tool_calls: \"invalid_tool_calls\",\n        };\n    }\n    constructor(fields, \n    /** @deprecated */\n    kwargs) {\n        let initParams;\n        if (typeof fields === \"string\") {\n            initParams = {\n                content: fields,\n                tool_calls: [],\n                invalid_tool_calls: [],\n                additional_kwargs: kwargs ?? {},\n            };\n        }\n        else {\n            initParams = fields;\n            const rawToolCalls = initParams.additional_kwargs?.tool_calls;\n            const toolCalls = initParams.tool_calls;\n            if (!(rawToolCalls == null) &&\n                rawToolCalls.length > 0 &&\n                (toolCalls === undefined || toolCalls.length === 0)) {\n                console.warn([\n                    \"New LangChain packages are available that more efficiently handle\",\n                    \"tool calling.\\n\\nPlease upgrade your packages to versions that set\",\n                    \"message tool calls. e.g., `yarn add @langchain/anthropic`,\",\n                    \"yarn add @langchain/openai`, etc.\",\n                ].join(\" \"));\n            }\n            try {\n                if (!(rawToolCalls == null) && toolCalls === undefined) {\n                    const [toolCalls, invalidToolCalls] = defaultToolCallParser(rawToolCalls);\n                    initParams.tool_calls = toolCalls ?? [];\n                    initParams.invalid_tool_calls = invalidToolCalls ?? [];\n                }\n                else {\n                    initParams.tool_calls = initParams.tool_calls ?? [];\n                    initParams.invalid_tool_calls = initParams.invalid_tool_calls ?? [];\n                }\n            }\n            catch (e) {\n                // Do nothing if parsing fails\n                initParams.tool_calls = [];\n                initParams.invalid_tool_calls = [];\n            }\n        }\n        // Sadly, TypeScript only allows super() calls at root if the class has\n        // properties with initializers, so we have to check types twice.\n        super(initParams);\n        // These are typed as optional to avoid breaking changes and allow for casting\n        // from BaseMessage.\n        Object.defineProperty(this, \"tool_calls\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: []\n        });\n        Object.defineProperty(this, \"invalid_tool_calls\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: []\n        });\n        /**\n         * If provided, token usage information associated with the message.\n         */\n        Object.defineProperty(this, \"usage_metadata\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        if (typeof initParams !== \"string\") {\n            this.tool_calls = initParams.tool_calls ?? this.tool_calls;\n            this.invalid_tool_calls =\n                initParams.invalid_tool_calls ?? this.invalid_tool_calls;\n        }\n        this.usage_metadata = initParams.usage_metadata;\n    }\n    static lc_name() {\n        return \"AIMessage\";\n    }\n    _getType() {\n        return \"ai\";\n    }\n    get _printableFields() {\n        return {\n            ...super._printableFields,\n            tool_calls: this.tool_calls,\n            invalid_tool_calls: this.invalid_tool_calls,\n            usage_metadata: this.usage_metadata,\n        };\n    }\n}\nexport function isAIMessage(x) {\n    return x._getType() === \"ai\";\n}\nexport function isAIMessageChunk(x) {\n    return x._getType() === \"ai\";\n}\n/**\n * Represents a chunk of an AI message, which can be concatenated with\n * other AI message chunks.\n */\nexport class AIMessageChunk extends BaseMessageChunk {\n    constructor(fields) {\n        let initParams;\n        if (typeof fields === \"string\") {\n            initParams = {\n                content: fields,\n                tool_calls: [],\n                invalid_tool_calls: [],\n                tool_call_chunks: [],\n            };\n        }\n        else if (fields.tool_call_chunks === undefined) {\n            initParams = {\n                ...fields,\n                tool_calls: fields.tool_calls ?? [],\n                invalid_tool_calls: [],\n                tool_call_chunks: [],\n                usage_metadata: fields.usage_metadata !== undefined\n                    ? fields.usage_metadata\n                    : undefined,\n            };\n        }\n        else {\n            const toolCalls = [];\n            const invalidToolCalls = [];\n            for (const toolCallChunk of fields.tool_call_chunks) {\n                let parsedArgs = {};\n                try {\n                    parsedArgs = parsePartialJson(toolCallChunk.args || \"{}\");\n                    if (parsedArgs === null ||\n                        typeof parsedArgs !== \"object\" ||\n                        Array.isArray(parsedArgs)) {\n                        throw new Error(\"Malformed tool call chunk args.\");\n                    }\n                    toolCalls.push({\n                        name: toolCallChunk.name ?? \"\",\n                        args: parsedArgs,\n                        id: toolCallChunk.id,\n                        type: \"tool_call\",\n                    });\n                }\n                catch (e) {\n                    invalidToolCalls.push({\n                        name: toolCallChunk.name,\n                        args: toolCallChunk.args,\n                        id: toolCallChunk.id,\n                        error: \"Malformed args.\",\n                        type: \"invalid_tool_call\",\n                    });\n                }\n            }\n            initParams = {\n                ...fields,\n                tool_calls: toolCalls,\n                invalid_tool_calls: invalidToolCalls,\n                usage_metadata: fields.usage_metadata !== undefined\n                    ? fields.usage_metadata\n                    : undefined,\n            };\n        }\n        // Sadly, TypeScript only allows super() calls at root if the class has\n        // properties with initializers, so we have to check types twice.\n        super(initParams);\n        // Must redeclare tool call fields since there is no multiple inheritance in JS.\n        // These are typed as optional to avoid breaking changes and allow for casting\n        // from BaseMessage.\n        Object.defineProperty(this, \"tool_calls\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: []\n        });\n        Object.defineProperty(this, \"invalid_tool_calls\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: []\n        });\n        Object.defineProperty(this, \"tool_call_chunks\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: []\n        });\n        /**\n         * If provided, token usage information associated with the message.\n         */\n        Object.defineProperty(this, \"usage_metadata\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.tool_call_chunks =\n            initParams.tool_call_chunks ?? this.tool_call_chunks;\n        this.tool_calls = initParams.tool_calls ?? this.tool_calls;\n        this.invalid_tool_calls =\n            initParams.invalid_tool_calls ?? this.invalid_tool_calls;\n        this.usage_metadata = initParams.usage_metadata;\n    }\n    get lc_aliases() {\n        // exclude snake case conversion to pascal case\n        return {\n            ...super.lc_aliases,\n            tool_calls: \"tool_calls\",\n            invalid_tool_calls: \"invalid_tool_calls\",\n            tool_call_chunks: \"tool_call_chunks\",\n        };\n    }\n    static lc_name() {\n        return \"AIMessageChunk\";\n    }\n    _getType() {\n        return \"ai\";\n    }\n    get _printableFields() {\n        return {\n            ...super._printableFields,\n            tool_calls: this.tool_calls,\n            tool_call_chunks: this.tool_call_chunks,\n            invalid_tool_calls: this.invalid_tool_calls,\n            usage_metadata: this.usage_metadata,\n        };\n    }\n    concat(chunk) {\n        const combinedFields = {\n            content: mergeContent(this.content, chunk.content),\n            additional_kwargs: _mergeDicts(this.additional_kwargs, chunk.additional_kwargs),\n            response_metadata: _mergeDicts(this.response_metadata, chunk.response_metadata),\n            tool_call_chunks: [],\n            id: this.id ?? chunk.id,\n        };\n        if (this.tool_call_chunks !== undefined ||\n            chunk.tool_call_chunks !== undefined) {\n            const rawToolCalls = _mergeLists(this.tool_call_chunks, chunk.tool_call_chunks);\n            if (rawToolCalls !== undefined && rawToolCalls.length > 0) {\n                combinedFields.tool_call_chunks = rawToolCalls;\n            }\n        }\n        if (this.usage_metadata !== undefined ||\n            chunk.usage_metadata !== undefined) {\n            const inputTokenDetails = {\n                ...((this.usage_metadata?.input_token_details?.audio !== undefined ||\n                    chunk.usage_metadata?.input_token_details?.audio !== undefined) && {\n                    audio: (this.usage_metadata?.input_token_details?.audio ?? 0) +\n                        (chunk.usage_metadata?.input_token_details?.audio ?? 0),\n                }),\n                ...((this.usage_metadata?.input_token_details?.cache_read !==\n                    undefined ||\n                    chunk.usage_metadata?.input_token_details?.cache_read !==\n                        undefined) && {\n                    cache_read: (this.usage_metadata?.input_token_details?.cache_read ?? 0) +\n                        (chunk.usage_metadata?.input_token_details?.cache_read ?? 0),\n                }),\n                ...((this.usage_metadata?.input_token_details?.cache_creation !==\n                    undefined ||\n                    chunk.usage_metadata?.input_token_details?.cache_creation !==\n                        undefined) && {\n                    cache_creation: (this.usage_metadata?.input_token_details?.cache_creation ?? 0) +\n                        (chunk.usage_metadata?.input_token_details?.cache_creation ?? 0),\n                }),\n            };\n            const outputTokenDetails = {\n                ...((this.usage_metadata?.output_token_details?.audio !== undefined ||\n                    chunk.usage_metadata?.output_token_details?.audio !== undefined) && {\n                    audio: (this.usage_metadata?.output_token_details?.audio ?? 0) +\n                        (chunk.usage_metadata?.output_token_details?.audio ?? 0),\n                }),\n                ...((this.usage_metadata?.output_token_details?.reasoning !==\n                    undefined ||\n                    chunk.usage_metadata?.output_token_details?.reasoning !==\n                        undefined) && {\n                    reasoning: (this.usage_metadata?.output_token_details?.reasoning ?? 0) +\n                        (chunk.usage_metadata?.output_token_details?.reasoning ?? 0),\n                }),\n            };\n            const left = this.usage_metadata ?? {\n                input_tokens: 0,\n                output_tokens: 0,\n                total_tokens: 0,\n            };\n            const right = chunk.usage_metadata ?? {\n                input_tokens: 0,\n                output_tokens: 0,\n                total_tokens: 0,\n            };\n            const usage_metadata = {\n                input_tokens: left.input_tokens + right.input_tokens,\n                output_tokens: left.output_tokens + right.output_tokens,\n                total_tokens: left.total_tokens + right.total_tokens,\n                // Do not include `input_token_details` / `output_token_details` keys in combined fields\n                // unless their values are defined.\n                ...(Object.keys(inputTokenDetails).length > 0 && {\n                    input_token_details: inputTokenDetails,\n                }),\n                ...(Object.keys(outputTokenDetails).length > 0 && {\n                    output_token_details: outputTokenDetails,\n                }),\n            };\n            combinedFields.usage_metadata = usage_metadata;\n        }\n        return new AIMessageChunk(combinedFields);\n    }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}