{"ast":null,"code":"import { OutputParserException } from \"../base.js\";\nimport { parsePartialJson } from \"../json.js\";\nimport { BaseCumulativeTransformOutputParser } from \"../transform.js\";\nimport { isAIMessage } from \"../../messages/ai.js\";\nexport function parseToolCall(\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nrawToolCall, options) {\n  if (rawToolCall.function === undefined) {\n    return undefined;\n  }\n  let functionArgs;\n  if (options?.partial) {\n    try {\n      functionArgs = parsePartialJson(rawToolCall.function.arguments ?? \"{}\");\n    } catch (e) {\n      return undefined;\n    }\n  } else {\n    try {\n      functionArgs = JSON.parse(rawToolCall.function.arguments);\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    } catch (e) {\n      throw new OutputParserException([`Function \"${rawToolCall.function.name}\" arguments:`, ``, rawToolCall.function.arguments, ``, `are not valid JSON.`, `Error: ${e.message}`].join(\"\\n\"));\n    }\n  }\n  const parsedToolCall = {\n    name: rawToolCall.function.name,\n    args: functionArgs,\n    type: \"tool_call\"\n  };\n  if (options?.returnId) {\n    parsedToolCall.id = rawToolCall.id;\n  }\n  return parsedToolCall;\n}\nexport function convertLangChainToolCallToOpenAI(toolCall) {\n  if (toolCall.id === undefined) {\n    throw new Error(`All OpenAI tool calls must have an \"id\" field.`);\n  }\n  return {\n    id: toolCall.id,\n    type: \"function\",\n    function: {\n      name: toolCall.name,\n      arguments: JSON.stringify(toolCall.args)\n    }\n  };\n}\nexport function makeInvalidToolCall(\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nrawToolCall, errorMsg) {\n  return {\n    name: rawToolCall.function?.name,\n    args: rawToolCall.function?.arguments,\n    id: rawToolCall.id,\n    error: errorMsg,\n    type: \"invalid_tool_call\"\n  };\n}\n/**\n * Class for parsing the output of a tool-calling LLM into a JSON object.\n */\nexport class JsonOutputToolsParser extends BaseCumulativeTransformOutputParser {\n  static lc_name() {\n    return \"JsonOutputToolsParser\";\n  }\n  constructor(fields) {\n    super(fields);\n    Object.defineProperty(this, \"returnId\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: false\n    });\n    Object.defineProperty(this, \"lc_namespace\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: [\"langchain\", \"output_parsers\", \"openai_tools\"]\n    });\n    Object.defineProperty(this, \"lc_serializable\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: true\n    });\n    this.returnId = fields?.returnId ?? this.returnId;\n  }\n  _diff() {\n    throw new Error(\"Not supported.\");\n  }\n  async parse() {\n    throw new Error(\"Not implemented.\");\n  }\n  async parseResult(generations) {\n    const result = await this.parsePartialResult(generations, false);\n    return result;\n  }\n  /**\n   * Parses the output and returns a JSON object. If `argsOnly` is true,\n   * only the arguments of the function call are returned.\n   * @param generations The output of the LLM to parse.\n   * @returns A JSON object representation of the function call or its arguments.\n   */\n  async parsePartialResult(generations, partial = true\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  ) {\n    const message = generations[0].message;\n    let toolCalls;\n    if (isAIMessage(message) && message.tool_calls?.length) {\n      toolCalls = message.tool_calls.map(toolCall => {\n        const {\n          id,\n          ...rest\n        } = toolCall;\n        if (!this.returnId) {\n          return rest;\n        }\n        return {\n          id,\n          ...rest\n        };\n      });\n    } else if (message.additional_kwargs.tool_calls !== undefined) {\n      const rawToolCalls = JSON.parse(JSON.stringify(message.additional_kwargs.tool_calls));\n      toolCalls = rawToolCalls.map(rawToolCall => {\n        return parseToolCall(rawToolCall, {\n          returnId: this.returnId,\n          partial\n        });\n      });\n    }\n    if (!toolCalls) {\n      return [];\n    }\n    const parsedToolCalls = [];\n    for (const toolCall of toolCalls) {\n      if (toolCall !== undefined) {\n        const backwardsCompatibleToolCall = {\n          type: toolCall.name,\n          args: toolCall.args,\n          id: toolCall.id\n        };\n        parsedToolCalls.push(backwardsCompatibleToolCall);\n      }\n    }\n    return parsedToolCalls;\n  }\n}\n/**\n * Class for parsing the output of a tool-calling LLM into a JSON object if you are\n * expecting only a single tool to be called.\n */\nexport class JsonOutputKeyToolsParser extends JsonOutputToolsParser {\n  static lc_name() {\n    return \"JsonOutputKeyToolsParser\";\n  }\n  constructor(params) {\n    super(params);\n    Object.defineProperty(this, \"lc_namespace\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: [\"langchain\", \"output_parsers\", \"openai_tools\"]\n    });\n    Object.defineProperty(this, \"lc_serializable\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: true\n    });\n    Object.defineProperty(this, \"returnId\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: false\n    });\n    /** The type of tool calls to return. */\n    Object.defineProperty(this, \"keyName\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    /** Whether to return only the first tool call. */\n    Object.defineProperty(this, \"returnSingle\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: false\n    });\n    Object.defineProperty(this, \"zodSchema\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    this.keyName = params.keyName;\n    this.returnSingle = params.returnSingle ?? this.returnSingle;\n    this.zodSchema = params.zodSchema;\n  }\n  async _validateResult(result) {\n    if (this.zodSchema === undefined) {\n      return result;\n    }\n    const zodParsedResult = await this.zodSchema.safeParseAsync(result);\n    if (zodParsedResult.success) {\n      return zodParsedResult.data;\n    } else {\n      throw new OutputParserException(`Failed to parse. Text: \"${JSON.stringify(result, null, 2)}\". Error: ${JSON.stringify(zodParsedResult.error.errors)}`, JSON.stringify(result, null, 2));\n    }\n  }\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  async parsePartialResult(generations) {\n    const results = await super.parsePartialResult(generations);\n    const matchingResults = results.filter(result => result.type === this.keyName);\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    let returnedValues = matchingResults;\n    if (!matchingResults.length) {\n      return undefined;\n    }\n    if (!this.returnId) {\n      returnedValues = matchingResults.map(result => result.args);\n    }\n    if (this.returnSingle) {\n      return returnedValues[0];\n    }\n    return returnedValues;\n  }\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  async parseResult(generations) {\n    const results = await super.parsePartialResult(generations, false);\n    const matchingResults = results.filter(result => result.type === this.keyName);\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    let returnedValues = matchingResults;\n    if (!matchingResults.length) {\n      return undefined;\n    }\n    if (!this.returnId) {\n      returnedValues = matchingResults.map(result => result.args);\n    }\n    if (this.returnSingle) {\n      return this._validateResult(returnedValues[0]);\n    }\n    const toolCallResults = await Promise.all(returnedValues.map(value => this._validateResult(value)));\n    return toolCallResults;\n  }\n}","map":{"version":3,"names":["OutputParserException","parsePartialJson","BaseCumulativeTransformOutputParser","isAIMessage","parseToolCall","rawToolCall","options","function","undefined","functionArgs","partial","arguments","e","JSON","parse","name","message","join","parsedToolCall","args","type","returnId","id","convertLangChainToolCallToOpenAI","toolCall","Error","stringify","makeInvalidToolCall","errorMsg","error","JsonOutputToolsParser","lc_name","constructor","fields","Object","defineProperty","enumerable","configurable","writable","value","_diff","parseResult","generations","result","parsePartialResult","toolCalls","tool_calls","length","map","rest","additional_kwargs","rawToolCalls","parsedToolCalls","backwardsCompatibleToolCall","push","JsonOutputKeyToolsParser","params","keyName","returnSingle","zodSchema","_validateResult","zodParsedResult","safeParseAsync","success","data","errors","results","matchingResults","filter","returnedValues","toolCallResults","Promise","all"],"sources":["/Users/youngchen/Downloads/cs224g-triage/node_modules/@langchain/core/dist/output_parsers/openai_tools/json_output_tools_parsers.js"],"sourcesContent":["import { OutputParserException } from \"../base.js\";\nimport { parsePartialJson } from \"../json.js\";\nimport { BaseCumulativeTransformOutputParser, } from \"../transform.js\";\nimport { isAIMessage } from \"../../messages/ai.js\";\nexport function parseToolCall(\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nrawToolCall, options) {\n    if (rawToolCall.function === undefined) {\n        return undefined;\n    }\n    let functionArgs;\n    if (options?.partial) {\n        try {\n            functionArgs = parsePartialJson(rawToolCall.function.arguments ?? \"{}\");\n        }\n        catch (e) {\n            return undefined;\n        }\n    }\n    else {\n        try {\n            functionArgs = JSON.parse(rawToolCall.function.arguments);\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        }\n        catch (e) {\n            throw new OutputParserException([\n                `Function \"${rawToolCall.function.name}\" arguments:`,\n                ``,\n                rawToolCall.function.arguments,\n                ``,\n                `are not valid JSON.`,\n                `Error: ${e.message}`,\n            ].join(\"\\n\"));\n        }\n    }\n    const parsedToolCall = {\n        name: rawToolCall.function.name,\n        args: functionArgs,\n        type: \"tool_call\",\n    };\n    if (options?.returnId) {\n        parsedToolCall.id = rawToolCall.id;\n    }\n    return parsedToolCall;\n}\nexport function convertLangChainToolCallToOpenAI(toolCall) {\n    if (toolCall.id === undefined) {\n        throw new Error(`All OpenAI tool calls must have an \"id\" field.`);\n    }\n    return {\n        id: toolCall.id,\n        type: \"function\",\n        function: {\n            name: toolCall.name,\n            arguments: JSON.stringify(toolCall.args),\n        },\n    };\n}\nexport function makeInvalidToolCall(\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nrawToolCall, errorMsg) {\n    return {\n        name: rawToolCall.function?.name,\n        args: rawToolCall.function?.arguments,\n        id: rawToolCall.id,\n        error: errorMsg,\n        type: \"invalid_tool_call\",\n    };\n}\n/**\n * Class for parsing the output of a tool-calling LLM into a JSON object.\n */\nexport class JsonOutputToolsParser extends BaseCumulativeTransformOutputParser {\n    static lc_name() {\n        return \"JsonOutputToolsParser\";\n    }\n    constructor(fields) {\n        super(fields);\n        Object.defineProperty(this, \"returnId\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: false\n        });\n        Object.defineProperty(this, \"lc_namespace\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: [\"langchain\", \"output_parsers\", \"openai_tools\"]\n        });\n        Object.defineProperty(this, \"lc_serializable\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: true\n        });\n        this.returnId = fields?.returnId ?? this.returnId;\n    }\n    _diff() {\n        throw new Error(\"Not supported.\");\n    }\n    async parse() {\n        throw new Error(\"Not implemented.\");\n    }\n    async parseResult(generations) {\n        const result = await this.parsePartialResult(generations, false);\n        return result;\n    }\n    /**\n     * Parses the output and returns a JSON object. If `argsOnly` is true,\n     * only the arguments of the function call are returned.\n     * @param generations The output of the LLM to parse.\n     * @returns A JSON object representation of the function call or its arguments.\n     */\n    async parsePartialResult(generations, partial = true\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    ) {\n        const message = generations[0].message;\n        let toolCalls;\n        if (isAIMessage(message) && message.tool_calls?.length) {\n            toolCalls = message.tool_calls.map((toolCall) => {\n                const { id, ...rest } = toolCall;\n                if (!this.returnId) {\n                    return rest;\n                }\n                return {\n                    id,\n                    ...rest,\n                };\n            });\n        }\n        else if (message.additional_kwargs.tool_calls !== undefined) {\n            const rawToolCalls = JSON.parse(JSON.stringify(message.additional_kwargs.tool_calls));\n            toolCalls = rawToolCalls.map((rawToolCall) => {\n                return parseToolCall(rawToolCall, { returnId: this.returnId, partial });\n            });\n        }\n        if (!toolCalls) {\n            return [];\n        }\n        const parsedToolCalls = [];\n        for (const toolCall of toolCalls) {\n            if (toolCall !== undefined) {\n                const backwardsCompatibleToolCall = {\n                    type: toolCall.name,\n                    args: toolCall.args,\n                    id: toolCall.id,\n                };\n                parsedToolCalls.push(backwardsCompatibleToolCall);\n            }\n        }\n        return parsedToolCalls;\n    }\n}\n/**\n * Class for parsing the output of a tool-calling LLM into a JSON object if you are\n * expecting only a single tool to be called.\n */\nexport class JsonOutputKeyToolsParser extends JsonOutputToolsParser {\n    static lc_name() {\n        return \"JsonOutputKeyToolsParser\";\n    }\n    constructor(params) {\n        super(params);\n        Object.defineProperty(this, \"lc_namespace\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: [\"langchain\", \"output_parsers\", \"openai_tools\"]\n        });\n        Object.defineProperty(this, \"lc_serializable\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: true\n        });\n        Object.defineProperty(this, \"returnId\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: false\n        });\n        /** The type of tool calls to return. */\n        Object.defineProperty(this, \"keyName\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        /** Whether to return only the first tool call. */\n        Object.defineProperty(this, \"returnSingle\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: false\n        });\n        Object.defineProperty(this, \"zodSchema\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.keyName = params.keyName;\n        this.returnSingle = params.returnSingle ?? this.returnSingle;\n        this.zodSchema = params.zodSchema;\n    }\n    async _validateResult(result) {\n        if (this.zodSchema === undefined) {\n            return result;\n        }\n        const zodParsedResult = await this.zodSchema.safeParseAsync(result);\n        if (zodParsedResult.success) {\n            return zodParsedResult.data;\n        }\n        else {\n            throw new OutputParserException(`Failed to parse. Text: \"${JSON.stringify(result, null, 2)}\". Error: ${JSON.stringify(zodParsedResult.error.errors)}`, JSON.stringify(result, null, 2));\n        }\n    }\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    async parsePartialResult(generations) {\n        const results = await super.parsePartialResult(generations);\n        const matchingResults = results.filter((result) => result.type === this.keyName);\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        let returnedValues = matchingResults;\n        if (!matchingResults.length) {\n            return undefined;\n        }\n        if (!this.returnId) {\n            returnedValues = matchingResults.map((result) => result.args);\n        }\n        if (this.returnSingle) {\n            return returnedValues[0];\n        }\n        return returnedValues;\n    }\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    async parseResult(generations) {\n        const results = await super.parsePartialResult(generations, false);\n        const matchingResults = results.filter((result) => result.type === this.keyName);\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        let returnedValues = matchingResults;\n        if (!matchingResults.length) {\n            return undefined;\n        }\n        if (!this.returnId) {\n            returnedValues = matchingResults.map((result) => result.args);\n        }\n        if (this.returnSingle) {\n            return this._validateResult(returnedValues[0]);\n        }\n        const toolCallResults = await Promise.all(returnedValues.map((value) => this._validateResult(value)));\n        return toolCallResults;\n    }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}