{"ast":null,"code":"import { isRunTree, RunTree } from \"langsmith/run_trees\";\nimport { _CONTEXT_VARIABLES_KEY, getGlobalAsyncLocalStorageInstance } from \"./globals.js\";\n/**\n * Set a context variable. Context variables are scoped to any\n * child runnables called by the current runnable, or globally if set outside\n * of any runnable.\n *\n * @remarks\n * This function is only supported in environments that support AsyncLocalStorage,\n * including Node.js, Deno, and Cloudflare Workers.\n *\n * @example\n * ```ts\n * import { RunnableLambda } from \"@langchain/core/runnables\";\n * import {\n *   getContextVariable,\n *   setContextVariable\n * } from \"@langchain/core/context\";\n *\n * const nested = RunnableLambda.from(() => {\n *   // \"bar\" because it was set by a parent\n *   console.log(getContextVariable(\"foo\"));\n *\n *   // Override to \"baz\", but only for child runnables\n *   setContextVariable(\"foo\", \"baz\");\n *\n *   // Now \"baz\", but only for child runnables\n *   return getContextVariable(\"foo\");\n * });\n *\n * const runnable = RunnableLambda.from(async () => {\n *   // Set a context variable named \"foo\"\n *   setContextVariable(\"foo\", \"bar\");\n *\n *   const res = await nested.invoke({});\n *\n *   // Still \"bar\" since child changes do not affect parents\n *   console.log(getContextVariable(\"foo\"));\n *\n *   return res;\n * });\n *\n * // undefined, because context variable has not been set yet\n * console.log(getContextVariable(\"foo\"));\n *\n * // Final return value is \"baz\"\n * const result = await runnable.invoke({});\n * ```\n *\n * @param name The name of the context variable.\n * @param value The value to set.\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport function setContextVariable(name, value) {\n  // Avoid using global singleton due to circuluar dependency issues\n  const asyncLocalStorageInstance = getGlobalAsyncLocalStorageInstance();\n  if (asyncLocalStorageInstance === undefined) {\n    throw new Error(`Internal error: Global shared async local storage instance has not been initialized.`);\n  }\n  const runTree = asyncLocalStorageInstance.getStore();\n  const contextVars = {\n    ...runTree?.[_CONTEXT_VARIABLES_KEY]\n  };\n  contextVars[name] = value;\n  let newValue = {};\n  if (isRunTree(runTree)) {\n    newValue = new RunTree(runTree);\n  }\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  newValue[_CONTEXT_VARIABLES_KEY] = contextVars;\n  asyncLocalStorageInstance.enterWith(newValue);\n}\n/**\n * Get the value of a previously set context variable. Context variables\n * are scoped to any child runnables called by the current runnable,\n * or globally if set outside of any runnable.\n *\n * @remarks\n * This function is only supported in environments that support AsyncLocalStorage,\n * including Node.js, Deno, and Cloudflare Workers.\n *\n * @example\n * ```ts\n * import { RunnableLambda } from \"@langchain/core/runnables\";\n * import {\n *   getContextVariable,\n *   setContextVariable\n * } from \"@langchain/core/context\";\n *\n * const nested = RunnableLambda.from(() => {\n *   // \"bar\" because it was set by a parent\n *   console.log(getContextVariable(\"foo\"));\n *\n *   // Override to \"baz\", but only for child runnables\n *   setContextVariable(\"foo\", \"baz\");\n *\n *   // Now \"baz\", but only for child runnables\n *   return getContextVariable(\"foo\");\n * });\n *\n * const runnable = RunnableLambda.from(async () => {\n *   // Set a context variable named \"foo\"\n *   setContextVariable(\"foo\", \"bar\");\n *\n *   const res = await nested.invoke({});\n *\n *   // Still \"bar\" since child changes do not affect parents\n *   console.log(getContextVariable(\"foo\"));\n *\n *   return res;\n * });\n *\n * // undefined, because context variable has not been set yet\n * console.log(getContextVariable(\"foo\"));\n *\n * // Final return value is \"baz\"\n * const result = await runnable.invoke({});\n * ```\n *\n * @param name The name of the context variable.\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport function getContextVariable(name) {\n  // Avoid using global singleton due to circuluar dependency issues\n  const asyncLocalStorageInstance = getGlobalAsyncLocalStorageInstance();\n  if (asyncLocalStorageInstance === undefined) {\n    return undefined;\n  }\n  const runTree = asyncLocalStorageInstance.getStore();\n  return runTree?.[_CONTEXT_VARIABLES_KEY]?.[name];\n}\nconst LC_CONFIGURE_HOOKS_KEY = Symbol(\"lc:configure_hooks\");\nexport const _getConfigureHooks = () => getContextVariable(LC_CONFIGURE_HOOKS_KEY) || [];\n/**\n * Register a callback configure hook to automatically add callback handlers to all runs.\n *\n * There are two ways to use this:\n *\n * 1. Using a context variable:\n *    - Set `contextVar` to specify the variable name\n *    - Use `setContextVariable()` to store your handler instance\n *\n * 2. Using an environment variable:\n *    - Set both `envVar` and `handlerClass`\n *    - The handler will be instantiated when the env var is set to \"true\".\n *\n * @example\n * ```typescript\n * // Method 1: Using context variable\n * import {\n *   registerConfigureHook,\n *   setContextVariable\n * } from \"@langchain/core/context\";\n *\n * const tracer = new MyCallbackHandler();\n * registerConfigureHook({\n *   contextVar: \"my_tracer\",\n * });\n * setContextVariable(\"my_tracer\", tracer);\n *\n * // ...run code here\n *\n * // Method 2: Using environment variable\n * registerConfigureHook({\n *   handlerClass: MyCallbackHandler,\n *   envVar: \"MY_TRACER_ENABLED\",\n * });\n * process.env.MY_TRACER_ENABLED = \"true\";\n *\n * // ...run code here\n * ```\n *\n * @param config Configuration object for the hook\n * @param config.contextVar Name of the context variable containing the handler instance\n * @param config.inheritable Whether child runs should inherit this handler\n * @param config.handlerClass Optional callback handler class (required if using envVar)\n * @param config.envVar Optional environment variable name to control handler activation\n */\nexport const registerConfigureHook = config => {\n  if (config.envVar && !config.handlerClass) {\n    throw new Error(\"If envVar is set, handlerClass must also be set to a non-None value.\");\n  }\n  setContextVariable(LC_CONFIGURE_HOOKS_KEY, [..._getConfigureHooks(), config]);\n};","map":{"version":3,"names":["isRunTree","RunTree","_CONTEXT_VARIABLES_KEY","getGlobalAsyncLocalStorageInstance","setContextVariable","name","value","asyncLocalStorageInstance","undefined","Error","runTree","getStore","contextVars","newValue","enterWith","getContextVariable","LC_CONFIGURE_HOOKS_KEY","Symbol","_getConfigureHooks","registerConfigureHook","config","envVar","handlerClass"],"sources":["/Users/youngchen/Downloads/cs224g-triage/node_modules/@langchain/core/dist/singletons/async_local_storage/context.js"],"sourcesContent":["import { isRunTree, RunTree } from \"langsmith/run_trees\";\nimport { _CONTEXT_VARIABLES_KEY, getGlobalAsyncLocalStorageInstance, } from \"./globals.js\";\n/**\n * Set a context variable. Context variables are scoped to any\n * child runnables called by the current runnable, or globally if set outside\n * of any runnable.\n *\n * @remarks\n * This function is only supported in environments that support AsyncLocalStorage,\n * including Node.js, Deno, and Cloudflare Workers.\n *\n * @example\n * ```ts\n * import { RunnableLambda } from \"@langchain/core/runnables\";\n * import {\n *   getContextVariable,\n *   setContextVariable\n * } from \"@langchain/core/context\";\n *\n * const nested = RunnableLambda.from(() => {\n *   // \"bar\" because it was set by a parent\n *   console.log(getContextVariable(\"foo\"));\n *\n *   // Override to \"baz\", but only for child runnables\n *   setContextVariable(\"foo\", \"baz\");\n *\n *   // Now \"baz\", but only for child runnables\n *   return getContextVariable(\"foo\");\n * });\n *\n * const runnable = RunnableLambda.from(async () => {\n *   // Set a context variable named \"foo\"\n *   setContextVariable(\"foo\", \"bar\");\n *\n *   const res = await nested.invoke({});\n *\n *   // Still \"bar\" since child changes do not affect parents\n *   console.log(getContextVariable(\"foo\"));\n *\n *   return res;\n * });\n *\n * // undefined, because context variable has not been set yet\n * console.log(getContextVariable(\"foo\"));\n *\n * // Final return value is \"baz\"\n * const result = await runnable.invoke({});\n * ```\n *\n * @param name The name of the context variable.\n * @param value The value to set.\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport function setContextVariable(name, value) {\n    // Avoid using global singleton due to circuluar dependency issues\n    const asyncLocalStorageInstance = getGlobalAsyncLocalStorageInstance();\n    if (asyncLocalStorageInstance === undefined) {\n        throw new Error(`Internal error: Global shared async local storage instance has not been initialized.`);\n    }\n    const runTree = asyncLocalStorageInstance.getStore();\n    const contextVars = { ...runTree?.[_CONTEXT_VARIABLES_KEY] };\n    contextVars[name] = value;\n    let newValue = {};\n    if (isRunTree(runTree)) {\n        newValue = new RunTree(runTree);\n    }\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    newValue[_CONTEXT_VARIABLES_KEY] = contextVars;\n    asyncLocalStorageInstance.enterWith(newValue);\n}\n/**\n * Get the value of a previously set context variable. Context variables\n * are scoped to any child runnables called by the current runnable,\n * or globally if set outside of any runnable.\n *\n * @remarks\n * This function is only supported in environments that support AsyncLocalStorage,\n * including Node.js, Deno, and Cloudflare Workers.\n *\n * @example\n * ```ts\n * import { RunnableLambda } from \"@langchain/core/runnables\";\n * import {\n *   getContextVariable,\n *   setContextVariable\n * } from \"@langchain/core/context\";\n *\n * const nested = RunnableLambda.from(() => {\n *   // \"bar\" because it was set by a parent\n *   console.log(getContextVariable(\"foo\"));\n *\n *   // Override to \"baz\", but only for child runnables\n *   setContextVariable(\"foo\", \"baz\");\n *\n *   // Now \"baz\", but only for child runnables\n *   return getContextVariable(\"foo\");\n * });\n *\n * const runnable = RunnableLambda.from(async () => {\n *   // Set a context variable named \"foo\"\n *   setContextVariable(\"foo\", \"bar\");\n *\n *   const res = await nested.invoke({});\n *\n *   // Still \"bar\" since child changes do not affect parents\n *   console.log(getContextVariable(\"foo\"));\n *\n *   return res;\n * });\n *\n * // undefined, because context variable has not been set yet\n * console.log(getContextVariable(\"foo\"));\n *\n * // Final return value is \"baz\"\n * const result = await runnable.invoke({});\n * ```\n *\n * @param name The name of the context variable.\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport function getContextVariable(name) {\n    // Avoid using global singleton due to circuluar dependency issues\n    const asyncLocalStorageInstance = getGlobalAsyncLocalStorageInstance();\n    if (asyncLocalStorageInstance === undefined) {\n        return undefined;\n    }\n    const runTree = asyncLocalStorageInstance.getStore();\n    return runTree?.[_CONTEXT_VARIABLES_KEY]?.[name];\n}\nconst LC_CONFIGURE_HOOKS_KEY = Symbol(\"lc:configure_hooks\");\nexport const _getConfigureHooks = () => getContextVariable(LC_CONFIGURE_HOOKS_KEY) || [];\n/**\n * Register a callback configure hook to automatically add callback handlers to all runs.\n *\n * There are two ways to use this:\n *\n * 1. Using a context variable:\n *    - Set `contextVar` to specify the variable name\n *    - Use `setContextVariable()` to store your handler instance\n *\n * 2. Using an environment variable:\n *    - Set both `envVar` and `handlerClass`\n *    - The handler will be instantiated when the env var is set to \"true\".\n *\n * @example\n * ```typescript\n * // Method 1: Using context variable\n * import {\n *   registerConfigureHook,\n *   setContextVariable\n * } from \"@langchain/core/context\";\n *\n * const tracer = new MyCallbackHandler();\n * registerConfigureHook({\n *   contextVar: \"my_tracer\",\n * });\n * setContextVariable(\"my_tracer\", tracer);\n *\n * // ...run code here\n *\n * // Method 2: Using environment variable\n * registerConfigureHook({\n *   handlerClass: MyCallbackHandler,\n *   envVar: \"MY_TRACER_ENABLED\",\n * });\n * process.env.MY_TRACER_ENABLED = \"true\";\n *\n * // ...run code here\n * ```\n *\n * @param config Configuration object for the hook\n * @param config.contextVar Name of the context variable containing the handler instance\n * @param config.inheritable Whether child runs should inherit this handler\n * @param config.handlerClass Optional callback handler class (required if using envVar)\n * @param config.envVar Optional environment variable name to control handler activation\n */\nexport const registerConfigureHook = (config) => {\n    if (config.envVar && !config.handlerClass) {\n        throw new Error(\"If envVar is set, handlerClass must also be set to a non-None value.\");\n    }\n    setContextVariable(LC_CONFIGURE_HOOKS_KEY, [..._getConfigureHooks(), config]);\n};\n"],"mappings":"AAAA,SAASA,SAAS,EAAEC,OAAO,QAAQ,qBAAqB;AACxD,SAASC,sBAAsB,EAAEC,kCAAkC,QAAS,cAAc;AAC1F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,SAASC,kBAAkBA,CAACC,IAAI,EAAEC,KAAK,EAAE;EAC5C;EACA,MAAMC,yBAAyB,GAAGJ,kCAAkC,CAAC,CAAC;EACtE,IAAII,yBAAyB,KAAKC,SAAS,EAAE;IACzC,MAAM,IAAIC,KAAK,CAAC,sFAAsF,CAAC;EAC3G;EACA,MAAMC,OAAO,GAAGH,yBAAyB,CAACI,QAAQ,CAAC,CAAC;EACpD,MAAMC,WAAW,GAAG;IAAE,GAAGF,OAAO,GAAGR,sBAAsB;EAAE,CAAC;EAC5DU,WAAW,CAACP,IAAI,CAAC,GAAGC,KAAK;EACzB,IAAIO,QAAQ,GAAG,CAAC,CAAC;EACjB,IAAIb,SAAS,CAACU,OAAO,CAAC,EAAE;IACpBG,QAAQ,GAAG,IAAIZ,OAAO,CAACS,OAAO,CAAC;EACnC;EACA;EACAG,QAAQ,CAACX,sBAAsB,CAAC,GAAGU,WAAW;EAC9CL,yBAAyB,CAACO,SAAS,CAACD,QAAQ,CAAC;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,SAASE,kBAAkBA,CAACV,IAAI,EAAE;EACrC;EACA,MAAME,yBAAyB,GAAGJ,kCAAkC,CAAC,CAAC;EACtE,IAAII,yBAAyB,KAAKC,SAAS,EAAE;IACzC,OAAOA,SAAS;EACpB;EACA,MAAME,OAAO,GAAGH,yBAAyB,CAACI,QAAQ,CAAC,CAAC;EACpD,OAAOD,OAAO,GAAGR,sBAAsB,CAAC,GAAGG,IAAI,CAAC;AACpD;AACA,MAAMW,sBAAsB,GAAGC,MAAM,CAAC,oBAAoB,CAAC;AAC3D,OAAO,MAAMC,kBAAkB,GAAGA,CAAA,KAAMH,kBAAkB,CAACC,sBAAsB,CAAC,IAAI,EAAE;AACxF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,MAAMG,qBAAqB,GAAIC,MAAM,IAAK;EAC7C,IAAIA,MAAM,CAACC,MAAM,IAAI,CAACD,MAAM,CAACE,YAAY,EAAE;IACvC,MAAM,IAAIb,KAAK,CAAC,sEAAsE,CAAC;EAC3F;EACAL,kBAAkB,CAACY,sBAAsB,EAAE,CAAC,GAAGE,kBAAkB,CAAC,CAAC,EAAEE,MAAM,CAAC,CAAC;AACjF,CAAC","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}