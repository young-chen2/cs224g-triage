{"ast":null,"code":"import { BaseCumulativeTransformOutputParser } from \"./transform.js\";\nimport { compare } from \"../utils/json_patch.js\";\nimport { sax } from \"../utils/sax-js/sax.js\";\nexport const XML_FORMAT_INSTRUCTIONS = `The output should be formatted as a XML file.\n1. Output should conform to the tags below. \n2. If tags are not given, make them on your own.\n3. Remember to always open and close all the tags.\n\nAs an example, for the tags [\"foo\", \"bar\", \"baz\"]:\n1. String \"<foo>\\n   <bar>\\n      <baz></baz>\\n   </bar>\\n</foo>\" is a well-formatted instance of the schema. \n2. String \"<foo>\\n   <bar>\\n   </foo>\" is a badly-formatted instance.\n3. String \"<foo>\\n   <tag>\\n   </tag>\\n</foo>\" is a badly-formatted instance.\n\nHere are the output tags:\n\\`\\`\\`\n{tags}\n\\`\\`\\``;\nexport class XMLOutputParser extends BaseCumulativeTransformOutputParser {\n  constructor(fields) {\n    super(fields);\n    Object.defineProperty(this, \"tags\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, \"lc_namespace\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: [\"langchain_core\", \"output_parsers\"]\n    });\n    Object.defineProperty(this, \"lc_serializable\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: true\n    });\n    this.tags = fields?.tags;\n  }\n  static lc_name() {\n    return \"XMLOutputParser\";\n  }\n  _diff(prev, next) {\n    if (!next) {\n      return undefined;\n    }\n    if (!prev) {\n      return [{\n        op: \"replace\",\n        path: \"\",\n        value: next\n      }];\n    }\n    return compare(prev, next);\n  }\n  async parsePartialResult(generations) {\n    return parseXMLMarkdown(generations[0].text);\n  }\n  async parse(text) {\n    return parseXMLMarkdown(text);\n  }\n  getFormatInstructions() {\n    const withTags = !!(this.tags && this.tags.length > 0);\n    return withTags ? XML_FORMAT_INSTRUCTIONS.replace(\"{tags}\", this.tags?.join(\", \") ?? \"\") : XML_FORMAT_INSTRUCTIONS;\n  }\n}\nconst strip = text => text.split(\"\\n\").map(line => line.replace(/^\\s+/, \"\")).join(\"\\n\").trim();\nconst parseParsedResult = input => {\n  if (Object.keys(input).length === 0) {\n    return {};\n  }\n  const result = {};\n  if (input.children.length > 0) {\n    result[input.name] = input.children.map(parseParsedResult);\n    return result;\n  } else {\n    result[input.name] = input.text ?? undefined;\n    return result;\n  }\n};\nexport function parseXMLMarkdown(s) {\n  const cleanedString = strip(s);\n  const parser = sax.parser(true);\n  let parsedResult = {};\n  const elementStack = [];\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  parser.onopentag = node => {\n    const element = {\n      name: node.name,\n      attributes: node.attributes,\n      children: [],\n      text: \"\",\n      isSelfClosing: node.isSelfClosing\n    };\n    if (elementStack.length > 0) {\n      const parentElement = elementStack[elementStack.length - 1];\n      parentElement.children.push(element);\n    } else {\n      parsedResult = element;\n    }\n    if (!node.isSelfClosing) {\n      elementStack.push(element);\n    }\n  };\n  parser.onclosetag = () => {\n    if (elementStack.length > 0) {\n      const lastElement = elementStack.pop();\n      if (elementStack.length === 0 && lastElement) {\n        parsedResult = lastElement;\n      }\n    }\n  };\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  parser.ontext = text => {\n    if (elementStack.length > 0) {\n      const currentElement = elementStack[elementStack.length - 1];\n      currentElement.text += text;\n    }\n  };\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  parser.onattribute = attr => {\n    if (elementStack.length > 0) {\n      const currentElement = elementStack[elementStack.length - 1];\n      currentElement.attributes[attr.name] = attr.value;\n    }\n  };\n  // Try to find XML string within triple backticks.\n  const match = /```(xml)?(.*)```/s.exec(cleanedString);\n  const xmlString = match ? match[2] : cleanedString;\n  parser.write(xmlString).close();\n  // Remove the XML declaration if present\n  if (parsedResult && parsedResult.name === \"?xml\") {\n    parsedResult = parsedResult.children[0];\n  }\n  return parseParsedResult(parsedResult);\n}","map":{"version":3,"names":["BaseCumulativeTransformOutputParser","compare","sax","XML_FORMAT_INSTRUCTIONS","XMLOutputParser","constructor","fields","Object","defineProperty","enumerable","configurable","writable","value","tags","lc_name","_diff","prev","next","undefined","op","path","parsePartialResult","generations","parseXMLMarkdown","text","parse","getFormatInstructions","withTags","length","replace","join","strip","split","map","line","trim","parseParsedResult","input","keys","result","children","name","s","cleanedString","parser","parsedResult","elementStack","onopentag","node","element","attributes","isSelfClosing","parentElement","push","onclosetag","lastElement","pop","ontext","currentElement","onattribute","attr","match","exec","xmlString","write","close"],"sources":["/Users/youngchen/Downloads/cs224g-triage/node_modules/@langchain/core/dist/output_parsers/xml.js"],"sourcesContent":["import { BaseCumulativeTransformOutputParser, } from \"./transform.js\";\nimport { compare } from \"../utils/json_patch.js\";\nimport { sax } from \"../utils/sax-js/sax.js\";\nexport const XML_FORMAT_INSTRUCTIONS = `The output should be formatted as a XML file.\n1. Output should conform to the tags below. \n2. If tags are not given, make them on your own.\n3. Remember to always open and close all the tags.\n\nAs an example, for the tags [\"foo\", \"bar\", \"baz\"]:\n1. String \"<foo>\\n   <bar>\\n      <baz></baz>\\n   </bar>\\n</foo>\" is a well-formatted instance of the schema. \n2. String \"<foo>\\n   <bar>\\n   </foo>\" is a badly-formatted instance.\n3. String \"<foo>\\n   <tag>\\n   </tag>\\n</foo>\" is a badly-formatted instance.\n\nHere are the output tags:\n\\`\\`\\`\n{tags}\n\\`\\`\\``;\nexport class XMLOutputParser extends BaseCumulativeTransformOutputParser {\n    constructor(fields) {\n        super(fields);\n        Object.defineProperty(this, \"tags\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"lc_namespace\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: [\"langchain_core\", \"output_parsers\"]\n        });\n        Object.defineProperty(this, \"lc_serializable\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: true\n        });\n        this.tags = fields?.tags;\n    }\n    static lc_name() {\n        return \"XMLOutputParser\";\n    }\n    _diff(prev, next) {\n        if (!next) {\n            return undefined;\n        }\n        if (!prev) {\n            return [{ op: \"replace\", path: \"\", value: next }];\n        }\n        return compare(prev, next);\n    }\n    async parsePartialResult(generations) {\n        return parseXMLMarkdown(generations[0].text);\n    }\n    async parse(text) {\n        return parseXMLMarkdown(text);\n    }\n    getFormatInstructions() {\n        const withTags = !!(this.tags && this.tags.length > 0);\n        return withTags\n            ? XML_FORMAT_INSTRUCTIONS.replace(\"{tags}\", this.tags?.join(\", \") ?? \"\")\n            : XML_FORMAT_INSTRUCTIONS;\n    }\n}\nconst strip = (text) => text\n    .split(\"\\n\")\n    .map((line) => line.replace(/^\\s+/, \"\"))\n    .join(\"\\n\")\n    .trim();\nconst parseParsedResult = (input) => {\n    if (Object.keys(input).length === 0) {\n        return {};\n    }\n    const result = {};\n    if (input.children.length > 0) {\n        result[input.name] = input.children.map(parseParsedResult);\n        return result;\n    }\n    else {\n        result[input.name] = input.text ?? undefined;\n        return result;\n    }\n};\nexport function parseXMLMarkdown(s) {\n    const cleanedString = strip(s);\n    const parser = sax.parser(true);\n    let parsedResult = {};\n    const elementStack = [];\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    parser.onopentag = (node) => {\n        const element = {\n            name: node.name,\n            attributes: node.attributes,\n            children: [],\n            text: \"\",\n            isSelfClosing: node.isSelfClosing,\n        };\n        if (elementStack.length > 0) {\n            const parentElement = elementStack[elementStack.length - 1];\n            parentElement.children.push(element);\n        }\n        else {\n            parsedResult = element;\n        }\n        if (!node.isSelfClosing) {\n            elementStack.push(element);\n        }\n    };\n    parser.onclosetag = () => {\n        if (elementStack.length > 0) {\n            const lastElement = elementStack.pop();\n            if (elementStack.length === 0 && lastElement) {\n                parsedResult = lastElement;\n            }\n        }\n    };\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    parser.ontext = (text) => {\n        if (elementStack.length > 0) {\n            const currentElement = elementStack[elementStack.length - 1];\n            currentElement.text += text;\n        }\n    };\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    parser.onattribute = (attr) => {\n        if (elementStack.length > 0) {\n            const currentElement = elementStack[elementStack.length - 1];\n            currentElement.attributes[attr.name] = attr.value;\n        }\n    };\n    // Try to find XML string within triple backticks.\n    const match = /```(xml)?(.*)```/s.exec(cleanedString);\n    const xmlString = match ? match[2] : cleanedString;\n    parser.write(xmlString).close();\n    // Remove the XML declaration if present\n    if (parsedResult && parsedResult.name === \"?xml\") {\n        parsedResult = parsedResult.children[0];\n    }\n    return parseParsedResult(parsedResult);\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}