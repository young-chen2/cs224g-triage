{"ast":null,"code":"import { ChatOpenAI } from \"@langchain/openai\";\nimport { ChatPromptTemplate, HumanMessagePromptTemplate } from \"@langchain/core/prompts\";\nimport { OpenAPISpec } from \"../../util/openapi.js\";\nimport { BaseChain } from \"../base.js\";\nimport { LLMChain } from \"../llm_chain.js\";\nimport { SequentialChain } from \"../sequential_chain.js\";\nimport { JsonOutputFunctionsParser } from \"../../output_parsers/openai_functions.js\";\n/**\n * Formats a URL by replacing path parameters with their corresponding\n * values.\n * @param url The URL to format.\n * @param pathParams The path parameters to replace in the URL.\n * @returns The formatted URL.\n */\nfunction formatURL(url, pathParams) {\n  const expectedPathParamNames = [...url.matchAll(/{(.*?)}/g)].map(match => match[1]);\n  const newParams = {};\n  for (const paramName of expectedPathParamNames) {\n    const cleanParamName = paramName.replace(/^\\.;/, \"\").replace(/\\*$/, \"\");\n    const value = pathParams[cleanParamName];\n    let formattedValue;\n    if (Array.isArray(value)) {\n      if (paramName.startsWith(\".\")) {\n        const separator = paramName.endsWith(\"*\") ? \".\" : \",\";\n        formattedValue = `.${value.join(separator)}`;\n      } else if (paramName.startsWith(\",\")) {\n        const separator = paramName.endsWith(\"*\") ? `${cleanParamName}=` : \",\";\n        formattedValue = `${cleanParamName}=${value.join(separator)}`;\n      } else {\n        formattedValue = value.join(\",\");\n      }\n    } else if (typeof value === \"object\") {\n      const kvSeparator = paramName.endsWith(\"*\") ? \"=\" : \",\";\n      const kvStrings = Object.entries(value).map(([k, v]) => k + kvSeparator + v);\n      let entrySeparator;\n      if (paramName.startsWith(\".\")) {\n        entrySeparator = \".\";\n        formattedValue = \".\";\n      } else if (paramName.startsWith(\";\")) {\n        entrySeparator = \";\";\n        formattedValue = \";\";\n      } else {\n        entrySeparator = \",\";\n        formattedValue = \"\";\n      }\n      formattedValue += kvStrings.join(entrySeparator);\n    } else {\n      if (paramName.startsWith(\".\")) {\n        formattedValue = `.${value}`;\n      } else if (paramName.startsWith(\";\")) {\n        formattedValue = `;${cleanParamName}=${value}`;\n      } else {\n        formattedValue = value;\n      }\n    }\n    newParams[paramName] = formattedValue;\n  }\n  let formattedUrl = url;\n  for (const [key, newValue] of Object.entries(newParams)) {\n    formattedUrl = formattedUrl.replace(`{${key}}`, newValue);\n  }\n  return formattedUrl;\n}\n/**\n * Converts OpenAPI parameters to JSON schema format.\n * @param params The OpenAPI parameters to convert.\n * @param spec The OpenAPI specification that contains the parameters.\n * @returns The JSON schema representation of the OpenAPI parameters.\n */\nfunction convertOpenAPIParamsToJSONSchema(params, spec) {\n  return params.reduce((jsonSchema, param) => {\n    let schema;\n    if (param.schema) {\n      schema = spec.getSchema(param.schema);\n      // eslint-disable-next-line no-param-reassign\n      jsonSchema.properties[param.name] = convertOpenAPISchemaToJSONSchema(schema, spec);\n    } else if (param.content) {\n      const mediaTypeSchema = Object.values(param.content)[0].schema;\n      if (mediaTypeSchema) {\n        schema = spec.getSchema(mediaTypeSchema);\n      }\n      if (!schema) {\n        return jsonSchema;\n      }\n      if (schema.description === undefined) {\n        schema.description = param.description ?? \"\";\n      }\n      // eslint-disable-next-line no-param-reassign\n      jsonSchema.properties[param.name] = convertOpenAPISchemaToJSONSchema(schema, spec);\n    } else {\n      return jsonSchema;\n    }\n    if (param.required && Array.isArray(jsonSchema.required)) {\n      jsonSchema.required.push(param.name);\n    }\n    return jsonSchema;\n  }, {\n    type: \"object\",\n    properties: {},\n    required: [],\n    additionalProperties: {}\n  });\n}\n// OpenAI throws errors on extraneous schema properties, e.g. if \"required\" is set on individual ones\n/**\n * Converts OpenAPI schemas to JSON schema format.\n * @param schema The OpenAPI schema to convert.\n * @param spec The OpenAPI specification that contains the schema.\n * @returns The JSON schema representation of the OpenAPI schema.\n */\nexport function convertOpenAPISchemaToJSONSchema(schema, spec) {\n  if (schema.type === \"object\") {\n    return Object.keys(schema.properties ?? {}).reduce((jsonSchema, propertyName) => {\n      if (!schema.properties) {\n        return jsonSchema;\n      }\n      const openAPIProperty = spec.getSchema(schema.properties[propertyName]);\n      if (openAPIProperty.type === undefined) {\n        return jsonSchema;\n      }\n      // eslint-disable-next-line no-param-reassign\n      jsonSchema.properties[propertyName] = convertOpenAPISchemaToJSONSchema(openAPIProperty, spec);\n      if ((openAPIProperty.required || schema.required?.includes(propertyName)) && jsonSchema.required !== undefined) {\n        jsonSchema.required.push(propertyName);\n      }\n      return jsonSchema;\n    }, {\n      type: \"object\",\n      properties: {},\n      required: [],\n      additionalProperties: {}\n    });\n  }\n  if (schema.type === \"array\") {\n    return {\n      type: \"array\",\n      items: convertOpenAPISchemaToJSONSchema(schema.items ?? {}, spec),\n      minItems: schema.minItems,\n      maxItems: schema.maxItems\n    };\n  }\n  return {\n    type: schema.type ?? \"string\"\n  };\n}\n/**\n * Converts an OpenAPI specification to OpenAI functions.\n * @param spec The OpenAPI specification to convert.\n * @returns An object containing the OpenAI functions derived from the OpenAPI specification and a default execution method.\n */\nfunction convertOpenAPISpecToOpenAIFunctions(spec) {\n  if (!spec.document.paths) {\n    return {\n      openAIFunctions: []\n    };\n  }\n  const openAIFunctions = [];\n  const nameToCallMap = {};\n  for (const path of Object.keys(spec.document.paths)) {\n    const pathParameters = spec.getParametersForPath(path);\n    for (const method of spec.getMethodsForPath(path)) {\n      const operation = spec.getOperation(path, method);\n      if (!operation) {\n        return {\n          openAIFunctions: []\n        };\n      }\n      const operationParametersByLocation = pathParameters.concat(spec.getParametersForOperation(operation)).reduce((operationParams, param) => {\n        if (!operationParams[param.in]) {\n          // eslint-disable-next-line no-param-reassign\n          operationParams[param.in] = [];\n        }\n        operationParams[param.in].push(param);\n        return operationParams;\n      }, {});\n      const paramLocationToRequestArgNameMap = {\n        query: \"params\",\n        header: \"headers\",\n        cookie: \"cookies\",\n        path: \"path_params\"\n      };\n      const requestArgsSchema = {};\n      for (const paramLocation of Object.keys(paramLocationToRequestArgNameMap)) {\n        if (operationParametersByLocation[paramLocation]) {\n          requestArgsSchema[paramLocationToRequestArgNameMap[paramLocation]] = convertOpenAPIParamsToJSONSchema(operationParametersByLocation[paramLocation], spec);\n        }\n      }\n      const requestBody = spec.getRequestBodyForOperation(operation);\n      if (requestBody?.content !== undefined) {\n        const requestBodySchemas = {};\n        for (const [mediaType, mediaTypeObject] of Object.entries(requestBody.content)) {\n          if (mediaTypeObject.schema !== undefined) {\n            const schema = spec.getSchema(mediaTypeObject.schema);\n            requestBodySchemas[mediaType] = convertOpenAPISchemaToJSONSchema(schema, spec);\n          }\n        }\n        const mediaTypes = Object.keys(requestBodySchemas);\n        if (mediaTypes.length === 1) {\n          requestArgsSchema.data = requestBodySchemas[mediaTypes[0]];\n        } else if (mediaTypes.length > 1) {\n          requestArgsSchema.data = {\n            anyOf: Object.values(requestBodySchemas)\n          };\n        }\n      }\n      const openAIFunction = {\n        name: OpenAPISpec.getCleanedOperationId(operation, path, method),\n        description: operation.description ?? operation.summary ?? \"\",\n        parameters: {\n          type: \"object\",\n          properties: requestArgsSchema,\n          // All remaining top-level parameters are required\n          required: Object.keys(requestArgsSchema)\n        }\n      };\n      openAIFunctions.push(openAIFunction);\n      const baseUrl = (spec.baseUrl ?? \"\").endsWith(\"/\") ? (spec.baseUrl ?? \"\").slice(0, -1) : spec.baseUrl ?? \"\";\n      nameToCallMap[openAIFunction.name] = {\n        method,\n        url: baseUrl + path\n      };\n    }\n  }\n  return {\n    openAIFunctions,\n    defaultExecutionMethod: async (name,\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    requestArgs, options) => {\n      const {\n        headers: customHeaders,\n        params: customParams,\n        ...rest\n      } = options ?? {};\n      const {\n        method,\n        url\n      } = nameToCallMap[name];\n      const requestParams = requestArgs.params ?? {};\n      const nonEmptyParams = Object.keys(requestParams).reduce(\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      (filteredArgs, argName) => {\n        if (requestParams[argName] !== \"\" && requestParams[argName] !== null && requestParams[argName] !== undefined) {\n          // eslint-disable-next-line no-param-reassign\n          filteredArgs[argName] = requestParams[argName];\n        }\n        return filteredArgs;\n      }, {});\n      const queryString = new URLSearchParams({\n        ...nonEmptyParams,\n        ...customParams\n      }).toString();\n      const pathParams = requestArgs.path_params;\n      const formattedUrl = formatURL(url, pathParams) + (queryString.length ? `?${queryString}` : \"\");\n      const headers = {};\n      let body;\n      if (requestArgs.data !== undefined) {\n        let contentType = \"text/plain\";\n        if (typeof requestArgs.data !== \"string\") {\n          if (typeof requestArgs.data === \"object\") {\n            contentType = \"application/json\";\n          }\n          body = JSON.stringify(requestArgs.data);\n        } else {\n          body = requestArgs.data;\n        }\n        headers[\"content-type\"] = contentType;\n      }\n      const response = await fetch(formattedUrl, {\n        ...requestArgs,\n        method,\n        headers: {\n          ...headers,\n          ...requestArgs.headers,\n          ...customHeaders\n        },\n        body,\n        ...rest\n      });\n      let output;\n      if (response.status < 200 || response.status > 299) {\n        output = `${response.status}: ${response.statusText} for ${name} called with ${JSON.stringify(queryString)}`;\n      } else {\n        output = await response.text();\n      }\n      return output;\n    }\n  };\n}\n/**\n * A chain for making simple API requests.\n */\nclass SimpleRequestChain extends BaseChain {\n  static lc_name() {\n    return \"SimpleRequestChain\";\n  }\n  constructor(config) {\n    super();\n    Object.defineProperty(this, \"requestMethod\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, \"inputKey\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: \"function\"\n    });\n    Object.defineProperty(this, \"outputKey\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: \"response\"\n    });\n    this.requestMethod = config.requestMethod;\n  }\n  get inputKeys() {\n    return [this.inputKey];\n  }\n  get outputKeys() {\n    return [this.outputKey];\n  }\n  _chainType() {\n    return \"simple_request_chain\";\n  }\n  /** @ignore */\n  async _call(values, _runManager) {\n    const inputKeyValue = values[this.inputKey];\n    const methodName = inputKeyValue.name;\n    const args = inputKeyValue.arguments;\n    const response = await this.requestMethod(methodName, args);\n    return {\n      [this.outputKey]: response\n    };\n  }\n}\n/**\n * Create a chain for querying an API from a OpenAPI spec.\n * @param spec OpenAPISpec or url/file/text string corresponding to one.\n * @param options Custom options passed into the chain\n * @returns OpenAPIChain\n */\nexport async function createOpenAPIChain(spec, options = {}) {\n  let convertedSpec;\n  if (typeof spec === \"string\") {\n    try {\n      convertedSpec = await OpenAPISpec.fromURL(spec);\n    } catch (e) {\n      try {\n        convertedSpec = OpenAPISpec.fromString(spec);\n      } catch (e) {\n        throw new Error(`Unable to parse spec from source ${spec}.`);\n      }\n    }\n  } else {\n    convertedSpec = OpenAPISpec.fromObject(spec);\n  }\n  const {\n    openAIFunctions,\n    defaultExecutionMethod\n  } = convertOpenAPISpecToOpenAIFunctions(convertedSpec);\n  if (defaultExecutionMethod === undefined) {\n    throw new Error(`Could not parse any valid operations from the provided spec.`);\n  }\n  const {\n    llm = new ChatOpenAI({\n      modelName: \"gpt-3.5-turbo-0613\"\n    }),\n    prompt = ChatPromptTemplate.fromMessages([HumanMessagePromptTemplate.fromTemplate(\"Use the provided API's to respond to this user query:\\n\\n{query}\")]),\n    requestChain = new SimpleRequestChain({\n      requestMethod: async (name, args) => defaultExecutionMethod(name, args, {\n        headers: options.headers,\n        params: options.params\n      })\n    }),\n    llmChainInputs = {},\n    verbose,\n    ...rest\n  } = options;\n  const formatChain = new LLMChain({\n    llm,\n    prompt,\n    outputParser: new JsonOutputFunctionsParser({\n      argsOnly: false\n    }),\n    outputKey: \"function\",\n    llmKwargs: {\n      functions: openAIFunctions\n    },\n    ...llmChainInputs\n  });\n  return new SequentialChain({\n    chains: [formatChain, requestChain],\n    outputVariables: [\"response\"],\n    inputVariables: formatChain.inputKeys,\n    verbose,\n    ...rest\n  });\n}","map":{"version":3,"names":["ChatOpenAI","ChatPromptTemplate","HumanMessagePromptTemplate","OpenAPISpec","BaseChain","LLMChain","SequentialChain","JsonOutputFunctionsParser","formatURL","url","pathParams","expectedPathParamNames","matchAll","map","match","newParams","paramName","cleanParamName","replace","value","formattedValue","Array","isArray","startsWith","separator","endsWith","join","kvSeparator","kvStrings","Object","entries","k","v","entrySeparator","formattedUrl","key","newValue","convertOpenAPIParamsToJSONSchema","params","spec","reduce","jsonSchema","param","schema","getSchema","properties","name","convertOpenAPISchemaToJSONSchema","content","mediaTypeSchema","values","description","undefined","required","push","type","additionalProperties","keys","propertyName","openAPIProperty","includes","items","minItems","maxItems","convertOpenAPISpecToOpenAIFunctions","document","paths","openAIFunctions","nameToCallMap","path","pathParameters","getParametersForPath","method","getMethodsForPath","operation","getOperation","operationParametersByLocation","concat","getParametersForOperation","operationParams","in","paramLocationToRequestArgNameMap","query","header","cookie","requestArgsSchema","paramLocation","requestBody","getRequestBodyForOperation","requestBodySchemas","mediaType","mediaTypeObject","mediaTypes","length","data","anyOf","openAIFunction","getCleanedOperationId","summary","parameters","baseUrl","slice","defaultExecutionMethod","requestArgs","options","headers","customHeaders","customParams","rest","requestParams","nonEmptyParams","filteredArgs","argName","queryString","URLSearchParams","toString","path_params","body","contentType","JSON","stringify","response","fetch","output","status","statusText","text","SimpleRequestChain","lc_name","constructor","config","defineProperty","enumerable","configurable","writable","requestMethod","inputKeys","inputKey","outputKeys","outputKey","_chainType","_call","_runManager","inputKeyValue","methodName","args","arguments","createOpenAPIChain","convertedSpec","fromURL","e","fromString","Error","fromObject","llm","modelName","prompt","fromMessages","fromTemplate","requestChain","llmChainInputs","verbose","formatChain","outputParser","argsOnly","llmKwargs","functions","chains","outputVariables","inputVariables"],"sources":["/Users/youngchen/Downloads/cs224g-triage/node_modules/langchain/dist/chains/openai_functions/openapi.js"],"sourcesContent":["import { ChatOpenAI } from \"@langchain/openai\";\nimport { ChatPromptTemplate, HumanMessagePromptTemplate, } from \"@langchain/core/prompts\";\nimport { OpenAPISpec } from \"../../util/openapi.js\";\nimport { BaseChain } from \"../base.js\";\nimport { LLMChain } from \"../llm_chain.js\";\nimport { SequentialChain } from \"../sequential_chain.js\";\nimport { JsonOutputFunctionsParser } from \"../../output_parsers/openai_functions.js\";\n/**\n * Formats a URL by replacing path parameters with their corresponding\n * values.\n * @param url The URL to format.\n * @param pathParams The path parameters to replace in the URL.\n * @returns The formatted URL.\n */\nfunction formatURL(url, pathParams) {\n    const expectedPathParamNames = [...url.matchAll(/{(.*?)}/g)].map((match) => match[1]);\n    const newParams = {};\n    for (const paramName of expectedPathParamNames) {\n        const cleanParamName = paramName.replace(/^\\.;/, \"\").replace(/\\*$/, \"\");\n        const value = pathParams[cleanParamName];\n        let formattedValue;\n        if (Array.isArray(value)) {\n            if (paramName.startsWith(\".\")) {\n                const separator = paramName.endsWith(\"*\") ? \".\" : \",\";\n                formattedValue = `.${value.join(separator)}`;\n            }\n            else if (paramName.startsWith(\",\")) {\n                const separator = paramName.endsWith(\"*\") ? `${cleanParamName}=` : \",\";\n                formattedValue = `${cleanParamName}=${value.join(separator)}`;\n            }\n            else {\n                formattedValue = value.join(\",\");\n            }\n        }\n        else if (typeof value === \"object\") {\n            const kvSeparator = paramName.endsWith(\"*\") ? \"=\" : \",\";\n            const kvStrings = Object.entries(value).map(([k, v]) => k + kvSeparator + v);\n            let entrySeparator;\n            if (paramName.startsWith(\".\")) {\n                entrySeparator = \".\";\n                formattedValue = \".\";\n            }\n            else if (paramName.startsWith(\";\")) {\n                entrySeparator = \";\";\n                formattedValue = \";\";\n            }\n            else {\n                entrySeparator = \",\";\n                formattedValue = \"\";\n            }\n            formattedValue += kvStrings.join(entrySeparator);\n        }\n        else {\n            if (paramName.startsWith(\".\")) {\n                formattedValue = `.${value}`;\n            }\n            else if (paramName.startsWith(\";\")) {\n                formattedValue = `;${cleanParamName}=${value}`;\n            }\n            else {\n                formattedValue = value;\n            }\n        }\n        newParams[paramName] = formattedValue;\n    }\n    let formattedUrl = url;\n    for (const [key, newValue] of Object.entries(newParams)) {\n        formattedUrl = formattedUrl.replace(`{${key}}`, newValue);\n    }\n    return formattedUrl;\n}\n/**\n * Converts OpenAPI parameters to JSON schema format.\n * @param params The OpenAPI parameters to convert.\n * @param spec The OpenAPI specification that contains the parameters.\n * @returns The JSON schema representation of the OpenAPI parameters.\n */\nfunction convertOpenAPIParamsToJSONSchema(params, spec) {\n    return params.reduce((jsonSchema, param) => {\n        let schema;\n        if (param.schema) {\n            schema = spec.getSchema(param.schema);\n            // eslint-disable-next-line no-param-reassign\n            jsonSchema.properties[param.name] = convertOpenAPISchemaToJSONSchema(schema, spec);\n        }\n        else if (param.content) {\n            const mediaTypeSchema = Object.values(param.content)[0].schema;\n            if (mediaTypeSchema) {\n                schema = spec.getSchema(mediaTypeSchema);\n            }\n            if (!schema) {\n                return jsonSchema;\n            }\n            if (schema.description === undefined) {\n                schema.description = param.description ?? \"\";\n            }\n            // eslint-disable-next-line no-param-reassign\n            jsonSchema.properties[param.name] = convertOpenAPISchemaToJSONSchema(schema, spec);\n        }\n        else {\n            return jsonSchema;\n        }\n        if (param.required && Array.isArray(jsonSchema.required)) {\n            jsonSchema.required.push(param.name);\n        }\n        return jsonSchema;\n    }, {\n        type: \"object\",\n        properties: {},\n        required: [],\n        additionalProperties: {},\n    });\n}\n// OpenAI throws errors on extraneous schema properties, e.g. if \"required\" is set on individual ones\n/**\n * Converts OpenAPI schemas to JSON schema format.\n * @param schema The OpenAPI schema to convert.\n * @param spec The OpenAPI specification that contains the schema.\n * @returns The JSON schema representation of the OpenAPI schema.\n */\nexport function convertOpenAPISchemaToJSONSchema(schema, spec) {\n    if (schema.type === \"object\") {\n        return Object.keys(schema.properties ?? {}).reduce((jsonSchema, propertyName) => {\n            if (!schema.properties) {\n                return jsonSchema;\n            }\n            const openAPIProperty = spec.getSchema(schema.properties[propertyName]);\n            if (openAPIProperty.type === undefined) {\n                return jsonSchema;\n            }\n            // eslint-disable-next-line no-param-reassign\n            jsonSchema.properties[propertyName] = convertOpenAPISchemaToJSONSchema(openAPIProperty, spec);\n            if ((openAPIProperty.required ||\n                schema.required?.includes(propertyName)) &&\n                jsonSchema.required !== undefined) {\n                jsonSchema.required.push(propertyName);\n            }\n            return jsonSchema;\n        }, {\n            type: \"object\",\n            properties: {},\n            required: [],\n            additionalProperties: {},\n        });\n    }\n    if (schema.type === \"array\") {\n        return {\n            type: \"array\",\n            items: convertOpenAPISchemaToJSONSchema(schema.items ?? {}, spec),\n            minItems: schema.minItems,\n            maxItems: schema.maxItems,\n        };\n    }\n    return {\n        type: schema.type ?? \"string\",\n    };\n}\n/**\n * Converts an OpenAPI specification to OpenAI functions.\n * @param spec The OpenAPI specification to convert.\n * @returns An object containing the OpenAI functions derived from the OpenAPI specification and a default execution method.\n */\nfunction convertOpenAPISpecToOpenAIFunctions(spec) {\n    if (!spec.document.paths) {\n        return { openAIFunctions: [] };\n    }\n    const openAIFunctions = [];\n    const nameToCallMap = {};\n    for (const path of Object.keys(spec.document.paths)) {\n        const pathParameters = spec.getParametersForPath(path);\n        for (const method of spec.getMethodsForPath(path)) {\n            const operation = spec.getOperation(path, method);\n            if (!operation) {\n                return { openAIFunctions: [] };\n            }\n            const operationParametersByLocation = pathParameters\n                .concat(spec.getParametersForOperation(operation))\n                .reduce((operationParams, param) => {\n                if (!operationParams[param.in]) {\n                    // eslint-disable-next-line no-param-reassign\n                    operationParams[param.in] = [];\n                }\n                operationParams[param.in].push(param);\n                return operationParams;\n            }, {});\n            const paramLocationToRequestArgNameMap = {\n                query: \"params\",\n                header: \"headers\",\n                cookie: \"cookies\",\n                path: \"path_params\",\n            };\n            const requestArgsSchema = {};\n            for (const paramLocation of Object.keys(paramLocationToRequestArgNameMap)) {\n                if (operationParametersByLocation[paramLocation]) {\n                    requestArgsSchema[paramLocationToRequestArgNameMap[paramLocation]] =\n                        convertOpenAPIParamsToJSONSchema(operationParametersByLocation[paramLocation], spec);\n                }\n            }\n            const requestBody = spec.getRequestBodyForOperation(operation);\n            if (requestBody?.content !== undefined) {\n                const requestBodySchemas = {};\n                for (const [mediaType, mediaTypeObject] of Object.entries(requestBody.content)) {\n                    if (mediaTypeObject.schema !== undefined) {\n                        const schema = spec.getSchema(mediaTypeObject.schema);\n                        requestBodySchemas[mediaType] = convertOpenAPISchemaToJSONSchema(schema, spec);\n                    }\n                }\n                const mediaTypes = Object.keys(requestBodySchemas);\n                if (mediaTypes.length === 1) {\n                    requestArgsSchema.data = requestBodySchemas[mediaTypes[0]];\n                }\n                else if (mediaTypes.length > 1) {\n                    requestArgsSchema.data = {\n                        anyOf: Object.values(requestBodySchemas),\n                    };\n                }\n            }\n            const openAIFunction = {\n                name: OpenAPISpec.getCleanedOperationId(operation, path, method),\n                description: operation.description ?? operation.summary ?? \"\",\n                parameters: {\n                    type: \"object\",\n                    properties: requestArgsSchema,\n                    // All remaining top-level parameters are required\n                    required: Object.keys(requestArgsSchema),\n                },\n            };\n            openAIFunctions.push(openAIFunction);\n            const baseUrl = (spec.baseUrl ?? \"\").endsWith(\"/\")\n                ? (spec.baseUrl ?? \"\").slice(0, -1)\n                : spec.baseUrl ?? \"\";\n            nameToCallMap[openAIFunction.name] = {\n                method,\n                url: baseUrl + path,\n            };\n        }\n    }\n    return {\n        openAIFunctions,\n        defaultExecutionMethod: async (name, \n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        requestArgs, options) => {\n            const { headers: customHeaders, params: customParams, ...rest } = options ?? {};\n            const { method, url } = nameToCallMap[name];\n            const requestParams = requestArgs.params ?? {};\n            const nonEmptyParams = Object.keys(requestParams).reduce(\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n            (filteredArgs, argName) => {\n                if (requestParams[argName] !== \"\" &&\n                    requestParams[argName] !== null &&\n                    requestParams[argName] !== undefined) {\n                    // eslint-disable-next-line no-param-reassign\n                    filteredArgs[argName] = requestParams[argName];\n                }\n                return filteredArgs;\n            }, {});\n            const queryString = new URLSearchParams({\n                ...nonEmptyParams,\n                ...customParams,\n            }).toString();\n            const pathParams = requestArgs.path_params;\n            const formattedUrl = formatURL(url, pathParams) +\n                (queryString.length ? `?${queryString}` : \"\");\n            const headers = {};\n            let body;\n            if (requestArgs.data !== undefined) {\n                let contentType = \"text/plain\";\n                if (typeof requestArgs.data !== \"string\") {\n                    if (typeof requestArgs.data === \"object\") {\n                        contentType = \"application/json\";\n                    }\n                    body = JSON.stringify(requestArgs.data);\n                }\n                else {\n                    body = requestArgs.data;\n                }\n                headers[\"content-type\"] = contentType;\n            }\n            const response = await fetch(formattedUrl, {\n                ...requestArgs,\n                method,\n                headers: {\n                    ...headers,\n                    ...requestArgs.headers,\n                    ...customHeaders,\n                },\n                body,\n                ...rest,\n            });\n            let output;\n            if (response.status < 200 || response.status > 299) {\n                output = `${response.status}: ${response.statusText} for ${name} called with ${JSON.stringify(queryString)}`;\n            }\n            else {\n                output = await response.text();\n            }\n            return output;\n        },\n    };\n}\n/**\n * A chain for making simple API requests.\n */\nclass SimpleRequestChain extends BaseChain {\n    static lc_name() {\n        return \"SimpleRequestChain\";\n    }\n    constructor(config) {\n        super();\n        Object.defineProperty(this, \"requestMethod\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"inputKey\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: \"function\"\n        });\n        Object.defineProperty(this, \"outputKey\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: \"response\"\n        });\n        this.requestMethod = config.requestMethod;\n    }\n    get inputKeys() {\n        return [this.inputKey];\n    }\n    get outputKeys() {\n        return [this.outputKey];\n    }\n    _chainType() {\n        return \"simple_request_chain\";\n    }\n    /** @ignore */\n    async _call(values, _runManager) {\n        const inputKeyValue = values[this.inputKey];\n        const methodName = inputKeyValue.name;\n        const args = inputKeyValue.arguments;\n        const response = await this.requestMethod(methodName, args);\n        return { [this.outputKey]: response };\n    }\n}\n/**\n * Create a chain for querying an API from a OpenAPI spec.\n * @param spec OpenAPISpec or url/file/text string corresponding to one.\n * @param options Custom options passed into the chain\n * @returns OpenAPIChain\n */\nexport async function createOpenAPIChain(spec, options = {}) {\n    let convertedSpec;\n    if (typeof spec === \"string\") {\n        try {\n            convertedSpec = await OpenAPISpec.fromURL(spec);\n        }\n        catch (e) {\n            try {\n                convertedSpec = OpenAPISpec.fromString(spec);\n            }\n            catch (e) {\n                throw new Error(`Unable to parse spec from source ${spec}.`);\n            }\n        }\n    }\n    else {\n        convertedSpec = OpenAPISpec.fromObject(spec);\n    }\n    const { openAIFunctions, defaultExecutionMethod } = convertOpenAPISpecToOpenAIFunctions(convertedSpec);\n    if (defaultExecutionMethod === undefined) {\n        throw new Error(`Could not parse any valid operations from the provided spec.`);\n    }\n    const { llm = new ChatOpenAI({ modelName: \"gpt-3.5-turbo-0613\" }), prompt = ChatPromptTemplate.fromMessages([\n        HumanMessagePromptTemplate.fromTemplate(\"Use the provided API's to respond to this user query:\\n\\n{query}\"),\n    ]), requestChain = new SimpleRequestChain({\n        requestMethod: async (name, args) => defaultExecutionMethod(name, args, {\n            headers: options.headers,\n            params: options.params,\n        }),\n    }), llmChainInputs = {}, verbose, ...rest } = options;\n    const formatChain = new LLMChain({\n        llm,\n        prompt,\n        outputParser: new JsonOutputFunctionsParser({ argsOnly: false }),\n        outputKey: \"function\",\n        llmKwargs: { functions: openAIFunctions },\n        ...llmChainInputs,\n    });\n    return new SequentialChain({\n        chains: [formatChain, requestChain],\n        outputVariables: [\"response\"],\n        inputVariables: formatChain.inputKeys,\n        verbose,\n        ...rest,\n    });\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}