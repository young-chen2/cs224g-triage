{"ast":null,"code":"import { addLangChainErrorFields } from \"../errors/index.js\";\nimport { _isToolCall } from \"../tools/utils.js\";\nimport { AIMessage, AIMessageChunk } from \"./ai.js\";\nimport { isBaseMessage, _isMessageFieldWithRole } from \"./base.js\";\nimport { ChatMessage, ChatMessageChunk } from \"./chat.js\";\nimport { FunctionMessage, FunctionMessageChunk } from \"./function.js\";\nimport { HumanMessage, HumanMessageChunk } from \"./human.js\";\nimport { SystemMessage, SystemMessageChunk } from \"./system.js\";\nimport { ToolMessage } from \"./tool.js\";\nfunction _coerceToolCall(toolCall) {\n  if (_isToolCall(toolCall)) {\n    return toolCall;\n  } else if (typeof toolCall.id === \"string\" && toolCall.type === \"function\" && typeof toolCall.function === \"object\" && toolCall.function !== null && \"arguments\" in toolCall.function && typeof toolCall.function.arguments === \"string\" && \"name\" in toolCall.function && typeof toolCall.function.name === \"string\") {\n    // Handle OpenAI tool call format\n    return {\n      id: toolCall.id,\n      args: JSON.parse(toolCall.function.arguments),\n      name: toolCall.function.name,\n      type: \"tool_call\"\n    };\n  } else {\n    // TODO: Throw an error?\n    return toolCall;\n  }\n}\nfunction isSerializedConstructor(x) {\n  return typeof x === \"object\" && x != null && x.lc === 1 && Array.isArray(x.id) && x.kwargs != null && typeof x.kwargs === \"object\";\n}\nfunction _constructMessageFromParams(params) {\n  let type;\n  let rest;\n  // Support serialized messages\n  if (isSerializedConstructor(params)) {\n    const className = params.id.at(-1);\n    if (className === \"HumanMessage\" || className === \"HumanMessageChunk\") {\n      type = \"user\";\n    } else if (className === \"AIMessage\" || className === \"AIMessageChunk\") {\n      type = \"assistant\";\n    } else if (className === \"SystemMessage\" || className === \"SystemMessageChunk\") {\n      type = \"system\";\n    } else {\n      type = \"unknown\";\n    }\n    rest = params.kwargs;\n  } else {\n    const {\n      type: extractedType,\n      ...otherParams\n    } = params;\n    type = extractedType;\n    rest = otherParams;\n  }\n  if (type === \"human\" || type === \"user\") {\n    return new HumanMessage(rest);\n  } else if (type === \"ai\" || type === \"assistant\") {\n    const {\n      tool_calls: rawToolCalls,\n      ...other\n    } = rest;\n    if (!Array.isArray(rawToolCalls)) {\n      return new AIMessage(rest);\n    }\n    const tool_calls = rawToolCalls.map(_coerceToolCall);\n    return new AIMessage({\n      ...other,\n      tool_calls\n    });\n  } else if (type === \"system\") {\n    return new SystemMessage(rest);\n  } else if (type === \"developer\") {\n    return new SystemMessage({\n      ...rest,\n      additional_kwargs: {\n        ...rest.additional_kwargs,\n        __openai_role__: \"developer\"\n      }\n    });\n  } else if (type === \"tool\" && \"tool_call_id\" in rest) {\n    return new ToolMessage({\n      ...rest,\n      content: rest.content,\n      tool_call_id: rest.tool_call_id,\n      name: rest.name\n    });\n  } else {\n    const error = addLangChainErrorFields(new Error(`Unable to coerce message from array: only human, AI, system, developer, or tool message coercion is currently supported.\\n\\nReceived: ${JSON.stringify(params, null, 2)}`), \"MESSAGE_COERCION_FAILURE\");\n    throw error;\n  }\n}\nexport function coerceMessageLikeToMessage(messageLike) {\n  if (typeof messageLike === \"string\") {\n    return new HumanMessage(messageLike);\n  } else if (isBaseMessage(messageLike)) {\n    return messageLike;\n  }\n  if (Array.isArray(messageLike)) {\n    const [type, content] = messageLike;\n    return _constructMessageFromParams({\n      type,\n      content\n    });\n  } else if (_isMessageFieldWithRole(messageLike)) {\n    const {\n      role: type,\n      ...rest\n    } = messageLike;\n    return _constructMessageFromParams({\n      ...rest,\n      type\n    });\n  } else {\n    return _constructMessageFromParams(messageLike);\n  }\n}\n/**\n * This function is used by memory classes to get a string representation\n * of the chat message history, based on the message content and role.\n */\nexport function getBufferString(messages, humanPrefix = \"Human\", aiPrefix = \"AI\") {\n  const string_messages = [];\n  for (const m of messages) {\n    let role;\n    if (m._getType() === \"human\") {\n      role = humanPrefix;\n    } else if (m._getType() === \"ai\") {\n      role = aiPrefix;\n    } else if (m._getType() === \"system\") {\n      role = \"System\";\n    } else if (m._getType() === \"function\") {\n      role = \"Function\";\n    } else if (m._getType() === \"tool\") {\n      role = \"Tool\";\n    } else if (m._getType() === \"generic\") {\n      role = m.role;\n    } else {\n      throw new Error(`Got unsupported message type: ${m._getType()}`);\n    }\n    const nameStr = m.name ? `${m.name}, ` : \"\";\n    const readableContent = typeof m.content === \"string\" ? m.content : JSON.stringify(m.content, null, 2);\n    string_messages.push(`${role}: ${nameStr}${readableContent}`);\n  }\n  return string_messages.join(\"\\n\");\n}\n/**\n * Maps messages from an older format (V1) to the current `StoredMessage`\n * format. If the message is already in the `StoredMessage` format, it is\n * returned as is. Otherwise, it transforms the V1 message into a\n * `StoredMessage`. This function is important for maintaining\n * compatibility with older message formats.\n */\nfunction mapV1MessageToStoredMessage(message) {\n  // TODO: Remove this mapper when we deprecate the old message format.\n  if (message.data !== undefined) {\n    return message;\n  } else {\n    const v1Message = message;\n    return {\n      type: v1Message.type,\n      data: {\n        content: v1Message.text,\n        role: v1Message.role,\n        name: undefined,\n        tool_call_id: undefined\n      }\n    };\n  }\n}\nexport function mapStoredMessageToChatMessage(message) {\n  const storedMessage = mapV1MessageToStoredMessage(message);\n  switch (storedMessage.type) {\n    case \"human\":\n      return new HumanMessage(storedMessage.data);\n    case \"ai\":\n      return new AIMessage(storedMessage.data);\n    case \"system\":\n      return new SystemMessage(storedMessage.data);\n    case \"function\":\n      if (storedMessage.data.name === undefined) {\n        throw new Error(\"Name must be defined for function messages\");\n      }\n      return new FunctionMessage(storedMessage.data);\n    case \"tool\":\n      if (storedMessage.data.tool_call_id === undefined) {\n        throw new Error(\"Tool call ID must be defined for tool messages\");\n      }\n      return new ToolMessage(storedMessage.data);\n    case \"generic\":\n      {\n        if (storedMessage.data.role === undefined) {\n          throw new Error(\"Role must be defined for chat messages\");\n        }\n        return new ChatMessage(storedMessage.data);\n      }\n    default:\n      throw new Error(`Got unexpected type: ${storedMessage.type}`);\n  }\n}\n/**\n * Transforms an array of `StoredMessage` instances into an array of\n * `BaseMessage` instances. It uses the `mapV1MessageToStoredMessage`\n * function to ensure all messages are in the `StoredMessage` format, then\n * creates new instances of the appropriate `BaseMessage` subclass based\n * on the type of each message. This function is used to prepare stored\n * messages for use in a chat context.\n */\nexport function mapStoredMessagesToChatMessages(messages) {\n  return messages.map(mapStoredMessageToChatMessage);\n}\n/**\n * Transforms an array of `BaseMessage` instances into an array of\n * `StoredMessage` instances. It does this by calling the `toDict` method\n * on each `BaseMessage`, which returns a `StoredMessage`. This function\n * is used to prepare chat messages for storage.\n */\nexport function mapChatMessagesToStoredMessages(messages) {\n  return messages.map(message => message.toDict());\n}\nexport function convertToChunk(message) {\n  const type = message._getType();\n  if (type === \"human\") {\n    // eslint-disable-next-line @typescript-eslint/no-use-before-define\n    return new HumanMessageChunk({\n      ...message\n    });\n  } else if (type === \"ai\") {\n    let aiChunkFields = {\n      ...message\n    };\n    if (\"tool_calls\" in aiChunkFields) {\n      aiChunkFields = {\n        ...aiChunkFields,\n        tool_call_chunks: aiChunkFields.tool_calls?.map(tc => ({\n          ...tc,\n          type: \"tool_call_chunk\",\n          index: undefined,\n          args: JSON.stringify(tc.args)\n        }))\n      };\n    }\n    // eslint-disable-next-line @typescript-eslint/no-use-before-define\n    return new AIMessageChunk({\n      ...aiChunkFields\n    });\n  } else if (type === \"system\") {\n    // eslint-disable-next-line @typescript-eslint/no-use-before-define\n    return new SystemMessageChunk({\n      ...message\n    });\n  } else if (type === \"function\") {\n    // eslint-disable-next-line @typescript-eslint/no-use-before-define\n    return new FunctionMessageChunk({\n      ...message\n    });\n    // eslint-disable-next-line @typescript-eslint/no-use-before-define\n  } else if (ChatMessage.isInstance(message)) {\n    // eslint-disable-next-line @typescript-eslint/no-use-before-define\n    return new ChatMessageChunk({\n      ...message\n    });\n  } else {\n    throw new Error(\"Unknown message type.\");\n  }\n}","map":{"version":3,"names":["addLangChainErrorFields","_isToolCall","AIMessage","AIMessageChunk","isBaseMessage","_isMessageFieldWithRole","ChatMessage","ChatMessageChunk","FunctionMessage","FunctionMessageChunk","HumanMessage","HumanMessageChunk","SystemMessage","SystemMessageChunk","ToolMessage","_coerceToolCall","toolCall","id","type","function","arguments","name","args","JSON","parse","isSerializedConstructor","x","lc","Array","isArray","kwargs","_constructMessageFromParams","params","rest","className","at","extractedType","otherParams","tool_calls","rawToolCalls","other","map","additional_kwargs","__openai_role__","content","tool_call_id","error","Error","stringify","coerceMessageLikeToMessage","messageLike","role","getBufferString","messages","humanPrefix","aiPrefix","string_messages","m","_getType","nameStr","readableContent","push","join","mapV1MessageToStoredMessage","message","data","undefined","v1Message","text","mapStoredMessageToChatMessage","storedMessage","mapStoredMessagesToChatMessages","mapChatMessagesToStoredMessages","toDict","convertToChunk","aiChunkFields","tool_call_chunks","tc","index","isInstance"],"sources":["/Users/youngchen/Downloads/cs224g-triage/node_modules/@langchain/core/dist/messages/utils.js"],"sourcesContent":["import { addLangChainErrorFields } from \"../errors/index.js\";\nimport { _isToolCall } from \"../tools/utils.js\";\nimport { AIMessage, AIMessageChunk } from \"./ai.js\";\nimport { isBaseMessage, _isMessageFieldWithRole, } from \"./base.js\";\nimport { ChatMessage, ChatMessageChunk, } from \"./chat.js\";\nimport { FunctionMessage, FunctionMessageChunk, } from \"./function.js\";\nimport { HumanMessage, HumanMessageChunk } from \"./human.js\";\nimport { SystemMessage, SystemMessageChunk } from \"./system.js\";\nimport { ToolMessage, } from \"./tool.js\";\nfunction _coerceToolCall(toolCall) {\n    if (_isToolCall(toolCall)) {\n        return toolCall;\n    }\n    else if (typeof toolCall.id === \"string\" &&\n        toolCall.type === \"function\" &&\n        typeof toolCall.function === \"object\" &&\n        toolCall.function !== null &&\n        \"arguments\" in toolCall.function &&\n        typeof toolCall.function.arguments === \"string\" &&\n        \"name\" in toolCall.function &&\n        typeof toolCall.function.name === \"string\") {\n        // Handle OpenAI tool call format\n        return {\n            id: toolCall.id,\n            args: JSON.parse(toolCall.function.arguments),\n            name: toolCall.function.name,\n            type: \"tool_call\",\n        };\n    }\n    else {\n        // TODO: Throw an error?\n        return toolCall;\n    }\n}\nfunction isSerializedConstructor(x) {\n    return (typeof x === \"object\" &&\n        x != null &&\n        x.lc === 1 &&\n        Array.isArray(x.id) &&\n        x.kwargs != null &&\n        typeof x.kwargs === \"object\");\n}\nfunction _constructMessageFromParams(params) {\n    let type;\n    let rest;\n    // Support serialized messages\n    if (isSerializedConstructor(params)) {\n        const className = params.id.at(-1);\n        if (className === \"HumanMessage\" || className === \"HumanMessageChunk\") {\n            type = \"user\";\n        }\n        else if (className === \"AIMessage\" || className === \"AIMessageChunk\") {\n            type = \"assistant\";\n        }\n        else if (className === \"SystemMessage\" ||\n            className === \"SystemMessageChunk\") {\n            type = \"system\";\n        }\n        else {\n            type = \"unknown\";\n        }\n        rest = params.kwargs;\n    }\n    else {\n        const { type: extractedType, ...otherParams } = params;\n        type = extractedType;\n        rest = otherParams;\n    }\n    if (type === \"human\" || type === \"user\") {\n        return new HumanMessage(rest);\n    }\n    else if (type === \"ai\" || type === \"assistant\") {\n        const { tool_calls: rawToolCalls, ...other } = rest;\n        if (!Array.isArray(rawToolCalls)) {\n            return new AIMessage(rest);\n        }\n        const tool_calls = rawToolCalls.map(_coerceToolCall);\n        return new AIMessage({ ...other, tool_calls });\n    }\n    else if (type === \"system\") {\n        return new SystemMessage(rest);\n    }\n    else if (type === \"developer\") {\n        return new SystemMessage({\n            ...rest,\n            additional_kwargs: {\n                ...rest.additional_kwargs,\n                __openai_role__: \"developer\",\n            },\n        });\n    }\n    else if (type === \"tool\" && \"tool_call_id\" in rest) {\n        return new ToolMessage({\n            ...rest,\n            content: rest.content,\n            tool_call_id: rest.tool_call_id,\n            name: rest.name,\n        });\n    }\n    else {\n        const error = addLangChainErrorFields(new Error(`Unable to coerce message from array: only human, AI, system, developer, or tool message coercion is currently supported.\\n\\nReceived: ${JSON.stringify(params, null, 2)}`), \"MESSAGE_COERCION_FAILURE\");\n        throw error;\n    }\n}\nexport function coerceMessageLikeToMessage(messageLike) {\n    if (typeof messageLike === \"string\") {\n        return new HumanMessage(messageLike);\n    }\n    else if (isBaseMessage(messageLike)) {\n        return messageLike;\n    }\n    if (Array.isArray(messageLike)) {\n        const [type, content] = messageLike;\n        return _constructMessageFromParams({ type, content });\n    }\n    else if (_isMessageFieldWithRole(messageLike)) {\n        const { role: type, ...rest } = messageLike;\n        return _constructMessageFromParams({ ...rest, type });\n    }\n    else {\n        return _constructMessageFromParams(messageLike);\n    }\n}\n/**\n * This function is used by memory classes to get a string representation\n * of the chat message history, based on the message content and role.\n */\nexport function getBufferString(messages, humanPrefix = \"Human\", aiPrefix = \"AI\") {\n    const string_messages = [];\n    for (const m of messages) {\n        let role;\n        if (m._getType() === \"human\") {\n            role = humanPrefix;\n        }\n        else if (m._getType() === \"ai\") {\n            role = aiPrefix;\n        }\n        else if (m._getType() === \"system\") {\n            role = \"System\";\n        }\n        else if (m._getType() === \"function\") {\n            role = \"Function\";\n        }\n        else if (m._getType() === \"tool\") {\n            role = \"Tool\";\n        }\n        else if (m._getType() === \"generic\") {\n            role = m.role;\n        }\n        else {\n            throw new Error(`Got unsupported message type: ${m._getType()}`);\n        }\n        const nameStr = m.name ? `${m.name}, ` : \"\";\n        const readableContent = typeof m.content === \"string\"\n            ? m.content\n            : JSON.stringify(m.content, null, 2);\n        string_messages.push(`${role}: ${nameStr}${readableContent}`);\n    }\n    return string_messages.join(\"\\n\");\n}\n/**\n * Maps messages from an older format (V1) to the current `StoredMessage`\n * format. If the message is already in the `StoredMessage` format, it is\n * returned as is. Otherwise, it transforms the V1 message into a\n * `StoredMessage`. This function is important for maintaining\n * compatibility with older message formats.\n */\nfunction mapV1MessageToStoredMessage(message) {\n    // TODO: Remove this mapper when we deprecate the old message format.\n    if (message.data !== undefined) {\n        return message;\n    }\n    else {\n        const v1Message = message;\n        return {\n            type: v1Message.type,\n            data: {\n                content: v1Message.text,\n                role: v1Message.role,\n                name: undefined,\n                tool_call_id: undefined,\n            },\n        };\n    }\n}\nexport function mapStoredMessageToChatMessage(message) {\n    const storedMessage = mapV1MessageToStoredMessage(message);\n    switch (storedMessage.type) {\n        case \"human\":\n            return new HumanMessage(storedMessage.data);\n        case \"ai\":\n            return new AIMessage(storedMessage.data);\n        case \"system\":\n            return new SystemMessage(storedMessage.data);\n        case \"function\":\n            if (storedMessage.data.name === undefined) {\n                throw new Error(\"Name must be defined for function messages\");\n            }\n            return new FunctionMessage(storedMessage.data);\n        case \"tool\":\n            if (storedMessage.data.tool_call_id === undefined) {\n                throw new Error(\"Tool call ID must be defined for tool messages\");\n            }\n            return new ToolMessage(storedMessage.data);\n        case \"generic\": {\n            if (storedMessage.data.role === undefined) {\n                throw new Error(\"Role must be defined for chat messages\");\n            }\n            return new ChatMessage(storedMessage.data);\n        }\n        default:\n            throw new Error(`Got unexpected type: ${storedMessage.type}`);\n    }\n}\n/**\n * Transforms an array of `StoredMessage` instances into an array of\n * `BaseMessage` instances. It uses the `mapV1MessageToStoredMessage`\n * function to ensure all messages are in the `StoredMessage` format, then\n * creates new instances of the appropriate `BaseMessage` subclass based\n * on the type of each message. This function is used to prepare stored\n * messages for use in a chat context.\n */\nexport function mapStoredMessagesToChatMessages(messages) {\n    return messages.map(mapStoredMessageToChatMessage);\n}\n/**\n * Transforms an array of `BaseMessage` instances into an array of\n * `StoredMessage` instances. It does this by calling the `toDict` method\n * on each `BaseMessage`, which returns a `StoredMessage`. This function\n * is used to prepare chat messages for storage.\n */\nexport function mapChatMessagesToStoredMessages(messages) {\n    return messages.map((message) => message.toDict());\n}\nexport function convertToChunk(message) {\n    const type = message._getType();\n    if (type === \"human\") {\n        // eslint-disable-next-line @typescript-eslint/no-use-before-define\n        return new HumanMessageChunk({ ...message });\n    }\n    else if (type === \"ai\") {\n        let aiChunkFields = {\n            ...message,\n        };\n        if (\"tool_calls\" in aiChunkFields) {\n            aiChunkFields = {\n                ...aiChunkFields,\n                tool_call_chunks: aiChunkFields.tool_calls?.map((tc) => ({\n                    ...tc,\n                    type: \"tool_call_chunk\",\n                    index: undefined,\n                    args: JSON.stringify(tc.args),\n                })),\n            };\n        }\n        // eslint-disable-next-line @typescript-eslint/no-use-before-define\n        return new AIMessageChunk({ ...aiChunkFields });\n    }\n    else if (type === \"system\") {\n        // eslint-disable-next-line @typescript-eslint/no-use-before-define\n        return new SystemMessageChunk({ ...message });\n    }\n    else if (type === \"function\") {\n        // eslint-disable-next-line @typescript-eslint/no-use-before-define\n        return new FunctionMessageChunk({ ...message });\n        // eslint-disable-next-line @typescript-eslint/no-use-before-define\n    }\n    else if (ChatMessage.isInstance(message)) {\n        // eslint-disable-next-line @typescript-eslint/no-use-before-define\n        return new ChatMessageChunk({ ...message });\n    }\n    else {\n        throw new Error(\"Unknown message type.\");\n    }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}