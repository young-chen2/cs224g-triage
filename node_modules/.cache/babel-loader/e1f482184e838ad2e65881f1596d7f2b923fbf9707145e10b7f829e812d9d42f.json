{"ast":null,"code":"import { ZodFirstPartyTypeKind } from 'zod';\nimport { parseAnyDef } from \"./parsers/any.mjs\";\nimport { parseArrayDef } from \"./parsers/array.mjs\";\nimport { parseBigintDef } from \"./parsers/bigint.mjs\";\nimport { parseBooleanDef } from \"./parsers/boolean.mjs\";\nimport { parseBrandedDef } from \"./parsers/branded.mjs\";\nimport { parseCatchDef } from \"./parsers/catch.mjs\";\nimport { parseDateDef } from \"./parsers/date.mjs\";\nimport { parseDefaultDef } from \"./parsers/default.mjs\";\nimport { parseEffectsDef } from \"./parsers/effects.mjs\";\nimport { parseEnumDef } from \"./parsers/enum.mjs\";\nimport { parseIntersectionDef } from \"./parsers/intersection.mjs\";\nimport { parseLiteralDef } from \"./parsers/literal.mjs\";\nimport { parseMapDef } from \"./parsers/map.mjs\";\nimport { parseNativeEnumDef } from \"./parsers/nativeEnum.mjs\";\nimport { parseNeverDef } from \"./parsers/never.mjs\";\nimport { parseNullDef } from \"./parsers/null.mjs\";\nimport { parseNullableDef } from \"./parsers/nullable.mjs\";\nimport { parseNumberDef } from \"./parsers/number.mjs\";\nimport { parseObjectDef } from \"./parsers/object.mjs\";\nimport { parseOptionalDef } from \"./parsers/optional.mjs\";\nimport { parsePipelineDef } from \"./parsers/pipeline.mjs\";\nimport { parsePromiseDef } from \"./parsers/promise.mjs\";\nimport { parseRecordDef } from \"./parsers/record.mjs\";\nimport { parseSetDef } from \"./parsers/set.mjs\";\nimport { parseStringDef } from \"./parsers/string.mjs\";\nimport { parseTupleDef } from \"./parsers/tuple.mjs\";\nimport { parseUndefinedDef } from \"./parsers/undefined.mjs\";\nimport { parseUnionDef } from \"./parsers/union.mjs\";\nimport { parseUnknownDef } from \"./parsers/unknown.mjs\";\nimport { parseReadonlyDef } from \"./parsers/readonly.mjs\";\nimport { ignoreOverride } from \"./Options.mjs\";\nexport function parseDef(def, refs, forceResolution = false) {\n  const seenItem = refs.seen.get(def);\n  if (refs.override) {\n    const overrideResult = refs.override?.(def, refs, seenItem, forceResolution);\n    if (overrideResult !== ignoreOverride) {\n      return overrideResult;\n    }\n  }\n  if (seenItem && !forceResolution) {\n    const seenSchema = get$ref(seenItem, refs);\n    if (seenSchema !== undefined) {\n      if ('$ref' in seenSchema) {\n        refs.seenRefs.add(seenSchema.$ref);\n      }\n      return seenSchema;\n    }\n  }\n  const newItem = {\n    def,\n    path: refs.currentPath,\n    jsonSchema: undefined\n  };\n  refs.seen.set(def, newItem);\n  const jsonSchema = selectParser(def, def.typeName, refs, forceResolution);\n  if (jsonSchema) {\n    addMeta(def, refs, jsonSchema);\n  }\n  newItem.jsonSchema = jsonSchema;\n  return jsonSchema;\n}\nconst get$ref = (item, refs) => {\n  switch (refs.$refStrategy) {\n    case 'root':\n      return {\n        $ref: item.path.join('/')\n      };\n    // this case is needed as OpenAI strict mode doesn't support top-level `$ref`s, i.e.\n    // the top-level schema *must* be `{\"type\": \"object\", \"properties\": {...}}` but if we ever\n    // need to define a `$ref`, relative `$ref`s aren't supported, so we need to extract\n    // the schema to `#/definitions/` and reference that.\n    //\n    // e.g. if we need to reference a schema at\n    // `[\"#\",\"definitions\",\"contactPerson\",\"properties\",\"person1\",\"properties\",\"name\"]`\n    // then we'll extract it out to `contactPerson_properties_person1_properties_name`\n    case 'extract-to-root':\n      const name = item.path.slice(refs.basePath.length + 1).join('_');\n      // we don't need to extract the root schema in this case, as it's already\n      // been added to the definitions\n      if (name !== refs.name && refs.nameStrategy === 'duplicate-ref') {\n        refs.definitions[name] = item.def;\n      }\n      return {\n        $ref: [...refs.basePath, refs.definitionPath, name].join('/')\n      };\n    case 'relative':\n      return {\n        $ref: getRelativePath(refs.currentPath, item.path)\n      };\n    case 'none':\n    case 'seen':\n      {\n        if (item.path.length < refs.currentPath.length && item.path.every((value, index) => refs.currentPath[index] === value)) {\n          console.warn(`Recursive reference detected at ${refs.currentPath.join('/')}! Defaulting to any`);\n          return {};\n        }\n        return refs.$refStrategy === 'seen' ? {} : undefined;\n      }\n  }\n};\nconst getRelativePath = (pathA, pathB) => {\n  let i = 0;\n  for (; i < pathA.length && i < pathB.length; i++) {\n    if (pathA[i] !== pathB[i]) break;\n  }\n  return [(pathA.length - i).toString(), ...pathB.slice(i)].join('/');\n};\nconst selectParser = (def, typeName, refs, forceResolution) => {\n  switch (typeName) {\n    case ZodFirstPartyTypeKind.ZodString:\n      return parseStringDef(def, refs);\n    case ZodFirstPartyTypeKind.ZodNumber:\n      return parseNumberDef(def, refs);\n    case ZodFirstPartyTypeKind.ZodObject:\n      return parseObjectDef(def, refs);\n    case ZodFirstPartyTypeKind.ZodBigInt:\n      return parseBigintDef(def, refs);\n    case ZodFirstPartyTypeKind.ZodBoolean:\n      return parseBooleanDef();\n    case ZodFirstPartyTypeKind.ZodDate:\n      return parseDateDef(def, refs);\n    case ZodFirstPartyTypeKind.ZodUndefined:\n      return parseUndefinedDef();\n    case ZodFirstPartyTypeKind.ZodNull:\n      return parseNullDef(refs);\n    case ZodFirstPartyTypeKind.ZodArray:\n      return parseArrayDef(def, refs);\n    case ZodFirstPartyTypeKind.ZodUnion:\n    case ZodFirstPartyTypeKind.ZodDiscriminatedUnion:\n      return parseUnionDef(def, refs);\n    case ZodFirstPartyTypeKind.ZodIntersection:\n      return parseIntersectionDef(def, refs);\n    case ZodFirstPartyTypeKind.ZodTuple:\n      return parseTupleDef(def, refs);\n    case ZodFirstPartyTypeKind.ZodRecord:\n      return parseRecordDef(def, refs);\n    case ZodFirstPartyTypeKind.ZodLiteral:\n      return parseLiteralDef(def, refs);\n    case ZodFirstPartyTypeKind.ZodEnum:\n      return parseEnumDef(def);\n    case ZodFirstPartyTypeKind.ZodNativeEnum:\n      return parseNativeEnumDef(def);\n    case ZodFirstPartyTypeKind.ZodNullable:\n      return parseNullableDef(def, refs);\n    case ZodFirstPartyTypeKind.ZodOptional:\n      return parseOptionalDef(def, refs);\n    case ZodFirstPartyTypeKind.ZodMap:\n      return parseMapDef(def, refs);\n    case ZodFirstPartyTypeKind.ZodSet:\n      return parseSetDef(def, refs);\n    case ZodFirstPartyTypeKind.ZodLazy:\n      return parseDef(def.getter()._def, refs);\n    case ZodFirstPartyTypeKind.ZodPromise:\n      return parsePromiseDef(def, refs);\n    case ZodFirstPartyTypeKind.ZodNaN:\n    case ZodFirstPartyTypeKind.ZodNever:\n      return parseNeverDef();\n    case ZodFirstPartyTypeKind.ZodEffects:\n      return parseEffectsDef(def, refs, forceResolution);\n    case ZodFirstPartyTypeKind.ZodAny:\n      return parseAnyDef();\n    case ZodFirstPartyTypeKind.ZodUnknown:\n      return parseUnknownDef();\n    case ZodFirstPartyTypeKind.ZodDefault:\n      return parseDefaultDef(def, refs);\n    case ZodFirstPartyTypeKind.ZodBranded:\n      return parseBrandedDef(def, refs);\n    case ZodFirstPartyTypeKind.ZodReadonly:\n      return parseReadonlyDef(def, refs);\n    case ZodFirstPartyTypeKind.ZodCatch:\n      return parseCatchDef(def, refs);\n    case ZodFirstPartyTypeKind.ZodPipeline:\n      return parsePipelineDef(def, refs);\n    case ZodFirstPartyTypeKind.ZodFunction:\n    case ZodFirstPartyTypeKind.ZodVoid:\n    case ZodFirstPartyTypeKind.ZodSymbol:\n      return undefined;\n    default:\n      return (_ => undefined)(typeName);\n  }\n};\nconst addMeta = (def, refs, jsonSchema) => {\n  if (def.description) {\n    jsonSchema.description = def.description;\n    if (refs.markdownDescription) {\n      jsonSchema.markdownDescription = def.description;\n    }\n  }\n  return jsonSchema;\n};","map":{"version":3,"names":["ZodFirstPartyTypeKind","parseAnyDef","parseArrayDef","parseBigintDef","parseBooleanDef","parseBrandedDef","parseCatchDef","parseDateDef","parseDefaultDef","parseEffectsDef","parseEnumDef","parseIntersectionDef","parseLiteralDef","parseMapDef","parseNativeEnumDef","parseNeverDef","parseNullDef","parseNullableDef","parseNumberDef","parseObjectDef","parseOptionalDef","parsePipelineDef","parsePromiseDef","parseRecordDef","parseSetDef","parseStringDef","parseTupleDef","parseUndefinedDef","parseUnionDef","parseUnknownDef","parseReadonlyDef","ignoreOverride","parseDef","def","refs","forceResolution","seenItem","seen","get","override","overrideResult","seenSchema","get$ref","undefined","seenRefs","add","$ref","newItem","path","currentPath","jsonSchema","set","selectParser","typeName","addMeta","item","$refStrategy","join","name","slice","basePath","length","nameStrategy","definitions","definitionPath","getRelativePath","every","value","index","console","warn","pathA","pathB","i","toString","ZodString","ZodNumber","ZodObject","ZodBigInt","ZodBoolean","ZodDate","ZodUndefined","ZodNull","ZodArray","ZodUnion","ZodDiscriminatedUnion","ZodIntersection","ZodTuple","ZodRecord","ZodLiteral","ZodEnum","ZodNativeEnum","ZodNullable","ZodOptional","ZodMap","ZodSet","ZodLazy","getter","_def","ZodPromise","ZodNaN","ZodNever","ZodEffects","ZodAny","ZodUnknown","ZodDefault","ZodBranded","ZodReadonly","ZodCatch","ZodPipeline","ZodFunction","ZodVoid","ZodSymbol","_","description","markdownDescription"],"sources":["/Users/youngchen/Downloads/cs224g-triage/node_modules/openai/src/_vendor/zod-to-json-schema/parseDef.ts"],"sourcesContent":["import { ZodFirstPartyTypeKind, ZodTypeDef } from 'zod';\nimport { JsonSchema7AnyType, parseAnyDef } from './parsers/any';\nimport { JsonSchema7ArrayType, parseArrayDef } from './parsers/array';\nimport { JsonSchema7BigintType, parseBigintDef } from './parsers/bigint';\nimport { JsonSchema7BooleanType, parseBooleanDef } from './parsers/boolean';\nimport { parseBrandedDef } from './parsers/branded';\nimport { parseCatchDef } from './parsers/catch';\nimport { JsonSchema7DateType, parseDateDef } from './parsers/date';\nimport { parseDefaultDef } from './parsers/default';\nimport { parseEffectsDef } from './parsers/effects';\nimport { JsonSchema7EnumType, parseEnumDef } from './parsers/enum';\nimport { JsonSchema7AllOfType, parseIntersectionDef } from './parsers/intersection';\nimport { JsonSchema7LiteralType, parseLiteralDef } from './parsers/literal';\nimport { JsonSchema7MapType, parseMapDef } from './parsers/map';\nimport { JsonSchema7NativeEnumType, parseNativeEnumDef } from './parsers/nativeEnum';\nimport { JsonSchema7NeverType, parseNeverDef } from './parsers/never';\nimport { JsonSchema7NullType, parseNullDef } from './parsers/null';\nimport { JsonSchema7NullableType, parseNullableDef } from './parsers/nullable';\nimport { JsonSchema7NumberType, parseNumberDef } from './parsers/number';\nimport { JsonSchema7ObjectType, parseObjectDef } from './parsers/object';\nimport { parseOptionalDef } from './parsers/optional';\nimport { parsePipelineDef } from './parsers/pipeline';\nimport { parsePromiseDef } from './parsers/promise';\nimport { JsonSchema7RecordType, parseRecordDef } from './parsers/record';\nimport { JsonSchema7SetType, parseSetDef } from './parsers/set';\nimport { JsonSchema7StringType, parseStringDef } from './parsers/string';\nimport { JsonSchema7TupleType, parseTupleDef } from './parsers/tuple';\nimport { JsonSchema7UndefinedType, parseUndefinedDef } from './parsers/undefined';\nimport { JsonSchema7UnionType, parseUnionDef } from './parsers/union';\nimport { JsonSchema7UnknownType, parseUnknownDef } from './parsers/unknown';\nimport { Refs, Seen } from './Refs';\nimport { parseReadonlyDef } from './parsers/readonly';\nimport { ignoreOverride } from './Options';\n\ntype JsonSchema7RefType = { $ref: string };\ntype JsonSchema7Meta = {\n  title?: string;\n  default?: any;\n  description?: string;\n  markdownDescription?: string;\n};\n\nexport type JsonSchema7TypeUnion =\n  | JsonSchema7StringType\n  | JsonSchema7ArrayType\n  | JsonSchema7NumberType\n  | JsonSchema7BigintType\n  | JsonSchema7BooleanType\n  | JsonSchema7DateType\n  | JsonSchema7EnumType\n  | JsonSchema7LiteralType\n  | JsonSchema7NativeEnumType\n  | JsonSchema7NullType\n  | JsonSchema7NumberType\n  | JsonSchema7ObjectType\n  | JsonSchema7RecordType\n  | JsonSchema7TupleType\n  | JsonSchema7UnionType\n  | JsonSchema7UndefinedType\n  | JsonSchema7RefType\n  | JsonSchema7NeverType\n  | JsonSchema7MapType\n  | JsonSchema7AnyType\n  | JsonSchema7NullableType\n  | JsonSchema7AllOfType\n  | JsonSchema7UnknownType\n  | JsonSchema7SetType;\n\nexport type JsonSchema7Type = JsonSchema7TypeUnion & JsonSchema7Meta;\n\nexport function parseDef(\n  def: ZodTypeDef,\n  refs: Refs,\n  forceResolution = false, // Forces a new schema to be instantiated even though its def has been seen. Used for improving refs in definitions. See https://github.com/StefanTerdell/zod-to-json-schema/pull/61.\n): JsonSchema7Type | undefined {\n  const seenItem = refs.seen.get(def);\n\n  if (refs.override) {\n    const overrideResult = refs.override?.(def, refs, seenItem, forceResolution);\n\n    if (overrideResult !== ignoreOverride) {\n      return overrideResult;\n    }\n  }\n\n  if (seenItem && !forceResolution) {\n    const seenSchema = get$ref(seenItem, refs);\n\n    if (seenSchema !== undefined) {\n      if ('$ref' in seenSchema) {\n        refs.seenRefs.add(seenSchema.$ref);\n      }\n\n      return seenSchema;\n    }\n  }\n\n  const newItem: Seen = { def, path: refs.currentPath, jsonSchema: undefined };\n\n  refs.seen.set(def, newItem);\n\n  const jsonSchema = selectParser(def, (def as any).typeName, refs, forceResolution);\n\n  if (jsonSchema) {\n    addMeta(def, refs, jsonSchema);\n  }\n\n  newItem.jsonSchema = jsonSchema;\n\n  return jsonSchema;\n}\n\nconst get$ref = (\n  item: Seen,\n  refs: Refs,\n):\n  | {\n      $ref: string;\n    }\n  | {}\n  | undefined => {\n  switch (refs.$refStrategy) {\n    case 'root':\n      return { $ref: item.path.join('/') };\n    // this case is needed as OpenAI strict mode doesn't support top-level `$ref`s, i.e.\n    // the top-level schema *must* be `{\"type\": \"object\", \"properties\": {...}}` but if we ever\n    // need to define a `$ref`, relative `$ref`s aren't supported, so we need to extract\n    // the schema to `#/definitions/` and reference that.\n    //\n    // e.g. if we need to reference a schema at\n    // `[\"#\",\"definitions\",\"contactPerson\",\"properties\",\"person1\",\"properties\",\"name\"]`\n    // then we'll extract it out to `contactPerson_properties_person1_properties_name`\n    case 'extract-to-root':\n      const name = item.path.slice(refs.basePath.length + 1).join('_');\n\n      // we don't need to extract the root schema in this case, as it's already\n      // been added to the definitions\n      if (name !== refs.name && refs.nameStrategy === 'duplicate-ref') {\n        refs.definitions[name] = item.def;\n      }\n\n      return { $ref: [...refs.basePath, refs.definitionPath, name].join('/') };\n    case 'relative':\n      return { $ref: getRelativePath(refs.currentPath, item.path) };\n    case 'none':\n    case 'seen': {\n      if (\n        item.path.length < refs.currentPath.length &&\n        item.path.every((value, index) => refs.currentPath[index] === value)\n      ) {\n        console.warn(`Recursive reference detected at ${refs.currentPath.join('/')}! Defaulting to any`);\n\n        return {};\n      }\n\n      return refs.$refStrategy === 'seen' ? {} : undefined;\n    }\n  }\n};\n\nconst getRelativePath = (pathA: string[], pathB: string[]) => {\n  let i = 0;\n  for (; i < pathA.length && i < pathB.length; i++) {\n    if (pathA[i] !== pathB[i]) break;\n  }\n  return [(pathA.length - i).toString(), ...pathB.slice(i)].join('/');\n};\n\nconst selectParser = (\n  def: any,\n  typeName: ZodFirstPartyTypeKind,\n  refs: Refs,\n  forceResolution: boolean,\n): JsonSchema7Type | undefined => {\n  switch (typeName) {\n    case ZodFirstPartyTypeKind.ZodString:\n      return parseStringDef(def, refs);\n    case ZodFirstPartyTypeKind.ZodNumber:\n      return parseNumberDef(def, refs);\n    case ZodFirstPartyTypeKind.ZodObject:\n      return parseObjectDef(def, refs);\n    case ZodFirstPartyTypeKind.ZodBigInt:\n      return parseBigintDef(def, refs);\n    case ZodFirstPartyTypeKind.ZodBoolean:\n      return parseBooleanDef();\n    case ZodFirstPartyTypeKind.ZodDate:\n      return parseDateDef(def, refs);\n    case ZodFirstPartyTypeKind.ZodUndefined:\n      return parseUndefinedDef();\n    case ZodFirstPartyTypeKind.ZodNull:\n      return parseNullDef(refs);\n    case ZodFirstPartyTypeKind.ZodArray:\n      return parseArrayDef(def, refs);\n    case ZodFirstPartyTypeKind.ZodUnion:\n    case ZodFirstPartyTypeKind.ZodDiscriminatedUnion:\n      return parseUnionDef(def, refs);\n    case ZodFirstPartyTypeKind.ZodIntersection:\n      return parseIntersectionDef(def, refs);\n    case ZodFirstPartyTypeKind.ZodTuple:\n      return parseTupleDef(def, refs);\n    case ZodFirstPartyTypeKind.ZodRecord:\n      return parseRecordDef(def, refs);\n    case ZodFirstPartyTypeKind.ZodLiteral:\n      return parseLiteralDef(def, refs);\n    case ZodFirstPartyTypeKind.ZodEnum:\n      return parseEnumDef(def);\n    case ZodFirstPartyTypeKind.ZodNativeEnum:\n      return parseNativeEnumDef(def);\n    case ZodFirstPartyTypeKind.ZodNullable:\n      return parseNullableDef(def, refs);\n    case ZodFirstPartyTypeKind.ZodOptional:\n      return parseOptionalDef(def, refs);\n    case ZodFirstPartyTypeKind.ZodMap:\n      return parseMapDef(def, refs);\n    case ZodFirstPartyTypeKind.ZodSet:\n      return parseSetDef(def, refs);\n    case ZodFirstPartyTypeKind.ZodLazy:\n      return parseDef(def.getter()._def, refs);\n    case ZodFirstPartyTypeKind.ZodPromise:\n      return parsePromiseDef(def, refs);\n    case ZodFirstPartyTypeKind.ZodNaN:\n    case ZodFirstPartyTypeKind.ZodNever:\n      return parseNeverDef();\n    case ZodFirstPartyTypeKind.ZodEffects:\n      return parseEffectsDef(def, refs, forceResolution);\n    case ZodFirstPartyTypeKind.ZodAny:\n      return parseAnyDef();\n    case ZodFirstPartyTypeKind.ZodUnknown:\n      return parseUnknownDef();\n    case ZodFirstPartyTypeKind.ZodDefault:\n      return parseDefaultDef(def, refs);\n    case ZodFirstPartyTypeKind.ZodBranded:\n      return parseBrandedDef(def, refs);\n    case ZodFirstPartyTypeKind.ZodReadonly:\n      return parseReadonlyDef(def, refs);\n    case ZodFirstPartyTypeKind.ZodCatch:\n      return parseCatchDef(def, refs);\n    case ZodFirstPartyTypeKind.ZodPipeline:\n      return parsePipelineDef(def, refs);\n    case ZodFirstPartyTypeKind.ZodFunction:\n    case ZodFirstPartyTypeKind.ZodVoid:\n    case ZodFirstPartyTypeKind.ZodSymbol:\n      return undefined;\n    default:\n      return ((_: never) => undefined)(typeName);\n  }\n};\n\nconst addMeta = (def: ZodTypeDef, refs: Refs, jsonSchema: JsonSchema7Type): JsonSchema7Type => {\n  if (def.description) {\n    jsonSchema.description = def.description;\n\n    if (refs.markdownDescription) {\n      jsonSchema.markdownDescription = def.description;\n    }\n  }\n  return jsonSchema;\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}