{"ast":null,"code":"import { parseDef } from \"../parseDef.js\";\nexport const primitiveMappings = {\n  ZodString: \"string\",\n  ZodNumber: \"number\",\n  ZodBigInt: \"integer\",\n  ZodBoolean: \"boolean\",\n  ZodNull: \"null\"\n};\nexport function parseUnionDef(def, refs) {\n  if (refs.target === \"openApi3\") return asAnyOf(def, refs);\n  const options = def.options instanceof Map ? Array.from(def.options.values()) : def.options;\n  // This blocks tries to look ahead a bit to produce nicer looking schemas with type array instead of anyOf.\n  if (options.every(x => x._def.typeName in primitiveMappings && (!x._def.checks || !x._def.checks.length))) {\n    // all types in union are primitive and lack checks, so might as well squash into {type: [...]}\n    const types = options.reduce((types, x) => {\n      const type = primitiveMappings[x._def.typeName]; //Can be safely casted due to row 43\n      return type && !types.includes(type) ? [...types, type] : types;\n    }, []);\n    return {\n      type: types.length > 1 ? types : types[0]\n    };\n  } else if (options.every(x => x._def.typeName === \"ZodLiteral\" && !x.description)) {\n    // all options literals\n    const types = options.reduce((acc, x) => {\n      const type = typeof x._def.value;\n      switch (type) {\n        case \"string\":\n        case \"number\":\n        case \"boolean\":\n          return [...acc, type];\n        case \"bigint\":\n          return [...acc, \"integer\"];\n        case \"object\":\n          if (x._def.value === null) return [...acc, \"null\"];\n        case \"symbol\":\n        case \"undefined\":\n        case \"function\":\n        default:\n          return acc;\n      }\n    }, []);\n    if (types.length === options.length) {\n      // all the literals are primitive, as far as null can be considered primitive\n      const uniqueTypes = types.filter((x, i, a) => a.indexOf(x) === i);\n      return {\n        type: uniqueTypes.length > 1 ? uniqueTypes : uniqueTypes[0],\n        enum: options.reduce((acc, x) => {\n          return acc.includes(x._def.value) ? acc : [...acc, x._def.value];\n        }, [])\n      };\n    }\n  } else if (options.every(x => x._def.typeName === \"ZodEnum\")) {\n    return {\n      type: \"string\",\n      enum: options.reduce((acc, x) => [...acc, ...x._def.values.filter(x => !acc.includes(x))], [])\n    };\n  }\n  return asAnyOf(def, refs);\n}\nconst asAnyOf = (def, refs) => {\n  const anyOf = (def.options instanceof Map ? Array.from(def.options.values()) : def.options).map((x, i) => parseDef(x._def, {\n    ...refs,\n    currentPath: [...refs.currentPath, \"anyOf\", `${i}`]\n  })).filter(x => !!x && (!refs.strictUnions || typeof x === \"object\" && Object.keys(x).length > 0));\n  return anyOf.length ? {\n    anyOf\n  } : undefined;\n};","map":{"version":3,"names":["parseDef","primitiveMappings","ZodString","ZodNumber","ZodBigInt","ZodBoolean","ZodNull","parseUnionDef","def","refs","target","asAnyOf","options","Map","Array","from","values","every","x","_def","typeName","checks","length","types","reduce","type","includes","description","acc","value","uniqueTypes","filter","i","a","indexOf","enum","anyOf","map","currentPath","strictUnions","Object","keys","undefined"],"sources":["/Users/youngchen/Downloads/cs224g-triage/node_modules/zod-to-json-schema/dist/esm/parsers/union.js"],"sourcesContent":["import { parseDef } from \"../parseDef.js\";\nexport const primitiveMappings = {\n    ZodString: \"string\",\n    ZodNumber: \"number\",\n    ZodBigInt: \"integer\",\n    ZodBoolean: \"boolean\",\n    ZodNull: \"null\",\n};\nexport function parseUnionDef(def, refs) {\n    if (refs.target === \"openApi3\")\n        return asAnyOf(def, refs);\n    const options = def.options instanceof Map ? Array.from(def.options.values()) : def.options;\n    // This blocks tries to look ahead a bit to produce nicer looking schemas with type array instead of anyOf.\n    if (options.every((x) => x._def.typeName in primitiveMappings &&\n        (!x._def.checks || !x._def.checks.length))) {\n        // all types in union are primitive and lack checks, so might as well squash into {type: [...]}\n        const types = options.reduce((types, x) => {\n            const type = primitiveMappings[x._def.typeName]; //Can be safely casted due to row 43\n            return type && !types.includes(type) ? [...types, type] : types;\n        }, []);\n        return {\n            type: types.length > 1 ? types : types[0],\n        };\n    }\n    else if (options.every((x) => x._def.typeName === \"ZodLiteral\" && !x.description)) {\n        // all options literals\n        const types = options.reduce((acc, x) => {\n            const type = typeof x._def.value;\n            switch (type) {\n                case \"string\":\n                case \"number\":\n                case \"boolean\":\n                    return [...acc, type];\n                case \"bigint\":\n                    return [...acc, \"integer\"];\n                case \"object\":\n                    if (x._def.value === null)\n                        return [...acc, \"null\"];\n                case \"symbol\":\n                case \"undefined\":\n                case \"function\":\n                default:\n                    return acc;\n            }\n        }, []);\n        if (types.length === options.length) {\n            // all the literals are primitive, as far as null can be considered primitive\n            const uniqueTypes = types.filter((x, i, a) => a.indexOf(x) === i);\n            return {\n                type: uniqueTypes.length > 1 ? uniqueTypes : uniqueTypes[0],\n                enum: options.reduce((acc, x) => {\n                    return acc.includes(x._def.value) ? acc : [...acc, x._def.value];\n                }, []),\n            };\n        }\n    }\n    else if (options.every((x) => x._def.typeName === \"ZodEnum\")) {\n        return {\n            type: \"string\",\n            enum: options.reduce((acc, x) => [\n                ...acc,\n                ...x._def.values.filter((x) => !acc.includes(x)),\n            ], []),\n        };\n    }\n    return asAnyOf(def, refs);\n}\nconst asAnyOf = (def, refs) => {\n    const anyOf = (def.options instanceof Map\n        ? Array.from(def.options.values())\n        : def.options)\n        .map((x, i) => parseDef(x._def, {\n        ...refs,\n        currentPath: [...refs.currentPath, \"anyOf\", `${i}`],\n    }))\n        .filter((x) => !!x &&\n        (!refs.strictUnions ||\n            (typeof x === \"object\" && Object.keys(x).length > 0)));\n    return anyOf.length ? { anyOf } : undefined;\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}