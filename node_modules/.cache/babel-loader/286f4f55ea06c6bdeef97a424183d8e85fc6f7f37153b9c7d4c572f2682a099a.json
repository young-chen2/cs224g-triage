{"ast":null,"code":"import { RunnableLambda } from \"../runnables/base.js\";\nimport { AIMessage, AIMessageChunk } from \"./ai.js\";\nimport { isBaseMessageChunk } from \"./base.js\";\nimport { ChatMessage, ChatMessageChunk } from \"./chat.js\";\nimport { FunctionMessage, FunctionMessageChunk } from \"./function.js\";\nimport { HumanMessage, HumanMessageChunk } from \"./human.js\";\nimport { RemoveMessage } from \"./modifier.js\";\nimport { SystemMessage, SystemMessageChunk } from \"./system.js\";\nimport { ToolMessage, ToolMessageChunk } from \"./tool.js\";\nimport { convertToChunk } from \"./utils.js\";\nconst _isMessageType = (msg, types) => {\n  const typesAsStrings = [...new Set(types?.map(t => {\n    if (typeof t === \"string\") {\n      return t;\n    }\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    const instantiatedMsgClass = new t({});\n    if (!(\"getType\" in instantiatedMsgClass) || typeof instantiatedMsgClass.getType !== \"function\") {\n      throw new Error(\"Invalid type provided.\");\n    }\n    return instantiatedMsgClass.getType();\n  }))];\n  const msgType = msg.getType();\n  return typesAsStrings.some(t => t === msgType);\n};\nexport function filterMessages(messagesOrOptions, options) {\n  if (Array.isArray(messagesOrOptions)) {\n    return _filterMessages(messagesOrOptions, options);\n  }\n  return RunnableLambda.from(input => {\n    return _filterMessages(input, messagesOrOptions);\n  });\n}\nfunction _filterMessages(messages, options = {}) {\n  const {\n    includeNames,\n    excludeNames,\n    includeTypes,\n    excludeTypes,\n    includeIds,\n    excludeIds\n  } = options;\n  const filtered = [];\n  for (const msg of messages) {\n    if (excludeNames && msg.name && excludeNames.includes(msg.name)) {\n      continue;\n    } else if (excludeTypes && _isMessageType(msg, excludeTypes)) {\n      continue;\n    } else if (excludeIds && msg.id && excludeIds.includes(msg.id)) {\n      continue;\n    }\n    // default to inclusion when no inclusion criteria given.\n    if (!(includeTypes || includeIds || includeNames)) {\n      filtered.push(msg);\n    } else if (includeNames && msg.name && includeNames.some(iName => iName === msg.name)) {\n      filtered.push(msg);\n    } else if (includeTypes && _isMessageType(msg, includeTypes)) {\n      filtered.push(msg);\n    } else if (includeIds && msg.id && includeIds.some(id => id === msg.id)) {\n      filtered.push(msg);\n    }\n  }\n  return filtered;\n}\nexport function mergeMessageRuns(messages) {\n  if (Array.isArray(messages)) {\n    return _mergeMessageRuns(messages);\n  }\n  return RunnableLambda.from(_mergeMessageRuns);\n}\nfunction _mergeMessageRuns(messages) {\n  if (!messages.length) {\n    return [];\n  }\n  const merged = [];\n  for (const msg of messages) {\n    const curr = msg;\n    const last = merged.pop();\n    if (!last) {\n      merged.push(curr);\n    } else if (curr.getType() === \"tool\" || !(curr.getType() === last.getType())) {\n      merged.push(last, curr);\n    } else {\n      const lastChunk = convertToChunk(last);\n      const currChunk = convertToChunk(curr);\n      const mergedChunks = lastChunk.concat(currChunk);\n      if (typeof lastChunk.content === \"string\" && typeof currChunk.content === \"string\") {\n        mergedChunks.content = `${lastChunk.content}\\n${currChunk.content}`;\n      }\n      merged.push(_chunkToMsg(mergedChunks));\n    }\n  }\n  return merged;\n}\nexport function trimMessages(messagesOrOptions, options) {\n  if (Array.isArray(messagesOrOptions)) {\n    const messages = messagesOrOptions;\n    if (!options) {\n      throw new Error(\"Options parameter is required when providing messages.\");\n    }\n    return _trimMessagesHelper(messages, options);\n  } else {\n    const trimmerOptions = messagesOrOptions;\n    return RunnableLambda.from(input => _trimMessagesHelper(input, trimmerOptions)).withConfig({\n      runName: \"trim_messages\"\n    });\n  }\n}\nasync function _trimMessagesHelper(messages, options) {\n  const {\n    maxTokens,\n    tokenCounter,\n    strategy = \"last\",\n    allowPartial = false,\n    endOn,\n    startOn,\n    includeSystem = false,\n    textSplitter\n  } = options;\n  if (startOn && strategy === \"first\") {\n    throw new Error(\"`startOn` should only be specified if `strategy` is 'last'.\");\n  }\n  if (includeSystem && strategy === \"first\") {\n    throw new Error(\"`includeSystem` should only be specified if `strategy` is 'last'.\");\n  }\n  let listTokenCounter;\n  if (\"getNumTokens\" in tokenCounter) {\n    listTokenCounter = async msgs => {\n      const tokenCounts = await Promise.all(msgs.map(msg => tokenCounter.getNumTokens(msg.content)));\n      return tokenCounts.reduce((sum, count) => sum + count, 0);\n    };\n  } else {\n    listTokenCounter = async msgs => tokenCounter(msgs);\n  }\n  let textSplitterFunc = defaultTextSplitter;\n  if (textSplitter) {\n    if (\"splitText\" in textSplitter) {\n      textSplitterFunc = textSplitter.splitText;\n    } else {\n      textSplitterFunc = async text => textSplitter(text);\n    }\n  }\n  if (strategy === \"first\") {\n    return _firstMaxTokens(messages, {\n      maxTokens,\n      tokenCounter: listTokenCounter,\n      textSplitter: textSplitterFunc,\n      partialStrategy: allowPartial ? \"first\" : undefined,\n      endOn\n    });\n  } else if (strategy === \"last\") {\n    return _lastMaxTokens(messages, {\n      maxTokens,\n      tokenCounter: listTokenCounter,\n      textSplitter: textSplitterFunc,\n      allowPartial,\n      includeSystem,\n      startOn,\n      endOn\n    });\n  } else {\n    throw new Error(`Unrecognized strategy: '${strategy}'. Must be one of 'first' or 'last'.`);\n  }\n}\nasync function _firstMaxTokens(messages, options) {\n  const {\n    maxTokens,\n    tokenCounter,\n    textSplitter,\n    partialStrategy,\n    endOn\n  } = options;\n  let messagesCopy = [...messages];\n  let idx = 0;\n  for (let i = 0; i < messagesCopy.length; i += 1) {\n    const remainingMessages = i > 0 ? messagesCopy.slice(0, -i) : messagesCopy;\n    if ((await tokenCounter(remainingMessages)) <= maxTokens) {\n      idx = messagesCopy.length - i;\n      break;\n    }\n  }\n  if (idx < messagesCopy.length - 1 && partialStrategy) {\n    let includedPartial = false;\n    if (Array.isArray(messagesCopy[idx].content)) {\n      const excluded = messagesCopy[idx];\n      if (typeof excluded.content === \"string\") {\n        throw new Error(\"Expected content to be an array.\");\n      }\n      const numBlock = excluded.content.length;\n      const reversedContent = partialStrategy === \"last\" ? [...excluded.content].reverse() : excluded.content;\n      for (let i = 1; i <= numBlock; i += 1) {\n        const partialContent = partialStrategy === \"first\" ? reversedContent.slice(0, i) : reversedContent.slice(-i);\n        const fields = Object.fromEntries(Object.entries(excluded).filter(([k]) => k !== \"type\" && !k.startsWith(\"lc_\")));\n        const updatedMessage = _switchTypeToMessage(excluded.getType(), {\n          ...fields,\n          content: partialContent\n        });\n        const slicedMessages = [...messagesCopy.slice(0, idx), updatedMessage];\n        if ((await tokenCounter(slicedMessages)) <= maxTokens) {\n          messagesCopy = slicedMessages;\n          idx += 1;\n          includedPartial = true;\n        } else {\n          break;\n        }\n      }\n      if (includedPartial && partialStrategy === \"last\") {\n        excluded.content = [...reversedContent].reverse();\n      }\n    }\n    if (!includedPartial) {\n      const excluded = messagesCopy[idx];\n      let text;\n      if (Array.isArray(excluded.content) && excluded.content.some(block => typeof block === \"string\" || block.type === \"text\")) {\n        const textBlock = excluded.content.find(block => block.type === \"text\" && block.text);\n        text = textBlock?.text;\n      } else if (typeof excluded.content === \"string\") {\n        text = excluded.content;\n      }\n      if (text) {\n        const splitTexts = await textSplitter(text);\n        const numSplits = splitTexts.length;\n        if (partialStrategy === \"last\") {\n          splitTexts.reverse();\n        }\n        for (let _ = 0; _ < numSplits - 1; _ += 1) {\n          splitTexts.pop();\n          excluded.content = splitTexts.join(\"\");\n          if ((await tokenCounter([...messagesCopy.slice(0, idx), excluded])) <= maxTokens) {\n            if (partialStrategy === \"last\") {\n              excluded.content = [...splitTexts].reverse().join(\"\");\n            }\n            messagesCopy = [...messagesCopy.slice(0, idx), excluded];\n            idx += 1;\n            break;\n          }\n        }\n      }\n    }\n  }\n  if (endOn) {\n    const endOnArr = Array.isArray(endOn) ? endOn : [endOn];\n    while (idx > 0 && !_isMessageType(messagesCopy[idx - 1], endOnArr)) {\n      idx -= 1;\n    }\n  }\n  return messagesCopy.slice(0, idx);\n}\nasync function _lastMaxTokens(messages, options) {\n  const {\n    allowPartial = false,\n    includeSystem = false,\n    endOn,\n    startOn,\n    ...rest\n  } = options;\n  // Create a copy of messages to avoid mutation\n  let messagesCopy = messages.map(message => {\n    const fields = Object.fromEntries(Object.entries(message).filter(([k]) => k !== \"type\" && !k.startsWith(\"lc_\")));\n    return _switchTypeToMessage(message.getType(), fields, isBaseMessageChunk(message));\n  });\n  if (endOn) {\n    const endOnArr = Array.isArray(endOn) ? endOn : [endOn];\n    while (messagesCopy.length > 0 && !_isMessageType(messagesCopy[messagesCopy.length - 1], endOnArr)) {\n      messagesCopy = messagesCopy.slice(0, -1);\n    }\n  }\n  const swappedSystem = includeSystem && messagesCopy[0]?.getType() === \"system\";\n  let reversed_ = swappedSystem ? messagesCopy.slice(0, 1).concat(messagesCopy.slice(1).reverse()) : messagesCopy.reverse();\n  reversed_ = await _firstMaxTokens(reversed_, {\n    ...rest,\n    partialStrategy: allowPartial ? \"last\" : undefined,\n    endOn: startOn\n  });\n  if (swappedSystem) {\n    return [reversed_[0], ...reversed_.slice(1).reverse()];\n  } else {\n    return reversed_.reverse();\n  }\n}\nconst _MSG_CHUNK_MAP = {\n  human: {\n    message: HumanMessage,\n    messageChunk: HumanMessageChunk\n  },\n  ai: {\n    message: AIMessage,\n    messageChunk: AIMessageChunk\n  },\n  system: {\n    message: SystemMessage,\n    messageChunk: SystemMessageChunk\n  },\n  developer: {\n    message: SystemMessage,\n    messageChunk: SystemMessageChunk\n  },\n  tool: {\n    message: ToolMessage,\n    messageChunk: ToolMessageChunk\n  },\n  function: {\n    message: FunctionMessage,\n    messageChunk: FunctionMessageChunk\n  },\n  generic: {\n    message: ChatMessage,\n    messageChunk: ChatMessageChunk\n  },\n  remove: {\n    message: RemoveMessage,\n    messageChunk: RemoveMessage // RemoveMessage does not have a chunk class.\n  }\n};\nfunction _switchTypeToMessage(messageType, fields, returnChunk) {\n  let chunk;\n  let msg;\n  switch (messageType) {\n    case \"human\":\n      if (returnChunk) {\n        chunk = new HumanMessageChunk(fields);\n      } else {\n        msg = new HumanMessage(fields);\n      }\n      break;\n    case \"ai\":\n      if (returnChunk) {\n        let aiChunkFields = {\n          ...fields\n        };\n        if (\"tool_calls\" in aiChunkFields) {\n          aiChunkFields = {\n            ...aiChunkFields,\n            tool_call_chunks: aiChunkFields.tool_calls?.map(tc => ({\n              ...tc,\n              type: \"tool_call_chunk\",\n              index: undefined,\n              args: JSON.stringify(tc.args)\n            }))\n          };\n        }\n        chunk = new AIMessageChunk(aiChunkFields);\n      } else {\n        msg = new AIMessage(fields);\n      }\n      break;\n    case \"system\":\n      if (returnChunk) {\n        chunk = new SystemMessageChunk(fields);\n      } else {\n        msg = new SystemMessage(fields);\n      }\n      break;\n    case \"developer\":\n      if (returnChunk) {\n        chunk = new SystemMessageChunk({\n          ...fields,\n          additional_kwargs: {\n            ...fields.additional_kwargs,\n            __openai_role__: \"developer\"\n          }\n        });\n      } else {\n        msg = new SystemMessage({\n          ...fields,\n          additional_kwargs: {\n            ...fields.additional_kwargs,\n            __openai_role__: \"developer\"\n          }\n        });\n      }\n      break;\n    case \"tool\":\n      if (\"tool_call_id\" in fields) {\n        if (returnChunk) {\n          chunk = new ToolMessageChunk(fields);\n        } else {\n          msg = new ToolMessage(fields);\n        }\n      } else {\n        throw new Error(\"Can not convert ToolMessage to ToolMessageChunk if 'tool_call_id' field is not defined.\");\n      }\n      break;\n    case \"function\":\n      if (returnChunk) {\n        chunk = new FunctionMessageChunk(fields);\n      } else {\n        if (!fields.name) {\n          throw new Error(\"FunctionMessage must have a 'name' field\");\n        }\n        msg = new FunctionMessage(fields);\n      }\n      break;\n    case \"generic\":\n      if (\"role\" in fields) {\n        if (returnChunk) {\n          chunk = new ChatMessageChunk(fields);\n        } else {\n          msg = new ChatMessage(fields);\n        }\n      } else {\n        throw new Error(\"Can not convert ChatMessage to ChatMessageChunk if 'role' field is not defined.\");\n      }\n      break;\n    default:\n      throw new Error(`Unrecognized message type ${messageType}`);\n  }\n  if (returnChunk && chunk) {\n    return chunk;\n  }\n  if (msg) {\n    return msg;\n  }\n  throw new Error(`Unrecognized message type ${messageType}`);\n}\nfunction _chunkToMsg(chunk) {\n  const chunkType = chunk.getType();\n  let msg;\n  const fields = Object.fromEntries(Object.entries(chunk).filter(([k]) => ![\"type\", \"tool_call_chunks\"].includes(k) && !k.startsWith(\"lc_\")));\n  if (chunkType in _MSG_CHUNK_MAP) {\n    msg = _switchTypeToMessage(chunkType, fields);\n  }\n  if (!msg) {\n    throw new Error(`Unrecognized message chunk class ${chunkType}. Supported classes are ${Object.keys(_MSG_CHUNK_MAP)}`);\n  }\n  return msg;\n}\n/**\n * The default text splitter function that splits text by newlines.\n *\n * @param {string} text\n * @returns A promise that resolves to an array of strings split by newlines.\n */\nexport function defaultTextSplitter(text) {\n  const splits = text.split(\"\\n\");\n  return Promise.resolve([...splits.slice(0, -1).map(s => `${s}\\n`), splits[splits.length - 1]]);\n}","map":{"version":3,"names":["RunnableLambda","AIMessage","AIMessageChunk","isBaseMessageChunk","ChatMessage","ChatMessageChunk","FunctionMessage","FunctionMessageChunk","HumanMessage","HumanMessageChunk","RemoveMessage","SystemMessage","SystemMessageChunk","ToolMessage","ToolMessageChunk","convertToChunk","_isMessageType","msg","types","typesAsStrings","Set","map","t","instantiatedMsgClass","getType","Error","msgType","some","filterMessages","messagesOrOptions","options","Array","isArray","_filterMessages","from","input","messages","includeNames","excludeNames","includeTypes","excludeTypes","includeIds","excludeIds","filtered","name","includes","id","push","iName","mergeMessageRuns","_mergeMessageRuns","length","merged","curr","last","pop","lastChunk","currChunk","mergedChunks","concat","content","_chunkToMsg","trimMessages","_trimMessagesHelper","trimmerOptions","withConfig","runName","maxTokens","tokenCounter","strategy","allowPartial","endOn","startOn","includeSystem","textSplitter","listTokenCounter","msgs","tokenCounts","Promise","all","getNumTokens","reduce","sum","count","textSplitterFunc","defaultTextSplitter","splitText","text","_firstMaxTokens","partialStrategy","undefined","_lastMaxTokens","messagesCopy","idx","i","remainingMessages","slice","includedPartial","excluded","numBlock","reversedContent","reverse","partialContent","fields","Object","fromEntries","entries","filter","k","startsWith","updatedMessage","_switchTypeToMessage","slicedMessages","block","type","textBlock","find","splitTexts","numSplits","_","join","endOnArr","rest","message","swappedSystem","reversed_","_MSG_CHUNK_MAP","human","messageChunk","ai","system","developer","tool","function","generic","remove","messageType","returnChunk","chunk","aiChunkFields","tool_call_chunks","tool_calls","tc","index","args","JSON","stringify","additional_kwargs","__openai_role__","chunkType","keys","splits","split","resolve","s"],"sources":["/Users/youngchen/Downloads/cs224g-triage/node_modules/@langchain/core/dist/messages/transformers.js"],"sourcesContent":["import { RunnableLambda } from \"../runnables/base.js\";\nimport { AIMessage, AIMessageChunk } from \"./ai.js\";\nimport { isBaseMessageChunk, } from \"./base.js\";\nimport { ChatMessage, ChatMessageChunk, } from \"./chat.js\";\nimport { FunctionMessage, FunctionMessageChunk, } from \"./function.js\";\nimport { HumanMessage, HumanMessageChunk } from \"./human.js\";\nimport { RemoveMessage } from \"./modifier.js\";\nimport { SystemMessage, SystemMessageChunk } from \"./system.js\";\nimport { ToolMessage, ToolMessageChunk, } from \"./tool.js\";\nimport { convertToChunk } from \"./utils.js\";\nconst _isMessageType = (msg, types) => {\n    const typesAsStrings = [\n        ...new Set(types?.map((t) => {\n            if (typeof t === \"string\") {\n                return t;\n            }\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n            const instantiatedMsgClass = new t({});\n            if (!(\"getType\" in instantiatedMsgClass) ||\n                typeof instantiatedMsgClass.getType !== \"function\") {\n                throw new Error(\"Invalid type provided.\");\n            }\n            return instantiatedMsgClass.getType();\n        })),\n    ];\n    const msgType = msg.getType();\n    return typesAsStrings.some((t) => t === msgType);\n};\nexport function filterMessages(messagesOrOptions, options) {\n    if (Array.isArray(messagesOrOptions)) {\n        return _filterMessages(messagesOrOptions, options);\n    }\n    return RunnableLambda.from((input) => {\n        return _filterMessages(input, messagesOrOptions);\n    });\n}\nfunction _filterMessages(messages, options = {}) {\n    const { includeNames, excludeNames, includeTypes, excludeTypes, includeIds, excludeIds, } = options;\n    const filtered = [];\n    for (const msg of messages) {\n        if (excludeNames && msg.name && excludeNames.includes(msg.name)) {\n            continue;\n        }\n        else if (excludeTypes && _isMessageType(msg, excludeTypes)) {\n            continue;\n        }\n        else if (excludeIds && msg.id && excludeIds.includes(msg.id)) {\n            continue;\n        }\n        // default to inclusion when no inclusion criteria given.\n        if (!(includeTypes || includeIds || includeNames)) {\n            filtered.push(msg);\n        }\n        else if (includeNames &&\n            msg.name &&\n            includeNames.some((iName) => iName === msg.name)) {\n            filtered.push(msg);\n        }\n        else if (includeTypes && _isMessageType(msg, includeTypes)) {\n            filtered.push(msg);\n        }\n        else if (includeIds && msg.id && includeIds.some((id) => id === msg.id)) {\n            filtered.push(msg);\n        }\n    }\n    return filtered;\n}\nexport function mergeMessageRuns(messages) {\n    if (Array.isArray(messages)) {\n        return _mergeMessageRuns(messages);\n    }\n    return RunnableLambda.from(_mergeMessageRuns);\n}\nfunction _mergeMessageRuns(messages) {\n    if (!messages.length) {\n        return [];\n    }\n    const merged = [];\n    for (const msg of messages) {\n        const curr = msg;\n        const last = merged.pop();\n        if (!last) {\n            merged.push(curr);\n        }\n        else if (curr.getType() === \"tool\" ||\n            !(curr.getType() === last.getType())) {\n            merged.push(last, curr);\n        }\n        else {\n            const lastChunk = convertToChunk(last);\n            const currChunk = convertToChunk(curr);\n            const mergedChunks = lastChunk.concat(currChunk);\n            if (typeof lastChunk.content === \"string\" &&\n                typeof currChunk.content === \"string\") {\n                mergedChunks.content = `${lastChunk.content}\\n${currChunk.content}`;\n            }\n            merged.push(_chunkToMsg(mergedChunks));\n        }\n    }\n    return merged;\n}\nexport function trimMessages(messagesOrOptions, options) {\n    if (Array.isArray(messagesOrOptions)) {\n        const messages = messagesOrOptions;\n        if (!options) {\n            throw new Error(\"Options parameter is required when providing messages.\");\n        }\n        return _trimMessagesHelper(messages, options);\n    }\n    else {\n        const trimmerOptions = messagesOrOptions;\n        return RunnableLambda.from((input) => _trimMessagesHelper(input, trimmerOptions)).withConfig({\n            runName: \"trim_messages\",\n        });\n    }\n}\nasync function _trimMessagesHelper(messages, options) {\n    const { maxTokens, tokenCounter, strategy = \"last\", allowPartial = false, endOn, startOn, includeSystem = false, textSplitter, } = options;\n    if (startOn && strategy === \"first\") {\n        throw new Error(\"`startOn` should only be specified if `strategy` is 'last'.\");\n    }\n    if (includeSystem && strategy === \"first\") {\n        throw new Error(\"`includeSystem` should only be specified if `strategy` is 'last'.\");\n    }\n    let listTokenCounter;\n    if (\"getNumTokens\" in tokenCounter) {\n        listTokenCounter = async (msgs) => {\n            const tokenCounts = await Promise.all(msgs.map((msg) => tokenCounter.getNumTokens(msg.content)));\n            return tokenCounts.reduce((sum, count) => sum + count, 0);\n        };\n    }\n    else {\n        listTokenCounter = async (msgs) => tokenCounter(msgs);\n    }\n    let textSplitterFunc = defaultTextSplitter;\n    if (textSplitter) {\n        if (\"splitText\" in textSplitter) {\n            textSplitterFunc = textSplitter.splitText;\n        }\n        else {\n            textSplitterFunc = async (text) => textSplitter(text);\n        }\n    }\n    if (strategy === \"first\") {\n        return _firstMaxTokens(messages, {\n            maxTokens,\n            tokenCounter: listTokenCounter,\n            textSplitter: textSplitterFunc,\n            partialStrategy: allowPartial ? \"first\" : undefined,\n            endOn,\n        });\n    }\n    else if (strategy === \"last\") {\n        return _lastMaxTokens(messages, {\n            maxTokens,\n            tokenCounter: listTokenCounter,\n            textSplitter: textSplitterFunc,\n            allowPartial,\n            includeSystem,\n            startOn,\n            endOn,\n        });\n    }\n    else {\n        throw new Error(`Unrecognized strategy: '${strategy}'. Must be one of 'first' or 'last'.`);\n    }\n}\nasync function _firstMaxTokens(messages, options) {\n    const { maxTokens, tokenCounter, textSplitter, partialStrategy, endOn } = options;\n    let messagesCopy = [...messages];\n    let idx = 0;\n    for (let i = 0; i < messagesCopy.length; i += 1) {\n        const remainingMessages = i > 0 ? messagesCopy.slice(0, -i) : messagesCopy;\n        if ((await tokenCounter(remainingMessages)) <= maxTokens) {\n            idx = messagesCopy.length - i;\n            break;\n        }\n    }\n    if (idx < messagesCopy.length - 1 && partialStrategy) {\n        let includedPartial = false;\n        if (Array.isArray(messagesCopy[idx].content)) {\n            const excluded = messagesCopy[idx];\n            if (typeof excluded.content === \"string\") {\n                throw new Error(\"Expected content to be an array.\");\n            }\n            const numBlock = excluded.content.length;\n            const reversedContent = partialStrategy === \"last\"\n                ? [...excluded.content].reverse()\n                : excluded.content;\n            for (let i = 1; i <= numBlock; i += 1) {\n                const partialContent = partialStrategy === \"first\"\n                    ? reversedContent.slice(0, i)\n                    : reversedContent.slice(-i);\n                const fields = Object.fromEntries(Object.entries(excluded).filter(([k]) => k !== \"type\" && !k.startsWith(\"lc_\")));\n                const updatedMessage = _switchTypeToMessage(excluded.getType(), {\n                    ...fields,\n                    content: partialContent,\n                });\n                const slicedMessages = [...messagesCopy.slice(0, idx), updatedMessage];\n                if ((await tokenCounter(slicedMessages)) <= maxTokens) {\n                    messagesCopy = slicedMessages;\n                    idx += 1;\n                    includedPartial = true;\n                }\n                else {\n                    break;\n                }\n            }\n            if (includedPartial && partialStrategy === \"last\") {\n                excluded.content = [...reversedContent].reverse();\n            }\n        }\n        if (!includedPartial) {\n            const excluded = messagesCopy[idx];\n            let text;\n            if (Array.isArray(excluded.content) &&\n                excluded.content.some((block) => typeof block === \"string\" || block.type === \"text\")) {\n                const textBlock = excluded.content.find((block) => block.type === \"text\" && block.text);\n                text = textBlock?.text;\n            }\n            else if (typeof excluded.content === \"string\") {\n                text = excluded.content;\n            }\n            if (text) {\n                const splitTexts = await textSplitter(text);\n                const numSplits = splitTexts.length;\n                if (partialStrategy === \"last\") {\n                    splitTexts.reverse();\n                }\n                for (let _ = 0; _ < numSplits - 1; _ += 1) {\n                    splitTexts.pop();\n                    excluded.content = splitTexts.join(\"\");\n                    if ((await tokenCounter([...messagesCopy.slice(0, idx), excluded])) <=\n                        maxTokens) {\n                        if (partialStrategy === \"last\") {\n                            excluded.content = [...splitTexts].reverse().join(\"\");\n                        }\n                        messagesCopy = [...messagesCopy.slice(0, idx), excluded];\n                        idx += 1;\n                        break;\n                    }\n                }\n            }\n        }\n    }\n    if (endOn) {\n        const endOnArr = Array.isArray(endOn) ? endOn : [endOn];\n        while (idx > 0 && !_isMessageType(messagesCopy[idx - 1], endOnArr)) {\n            idx -= 1;\n        }\n    }\n    return messagesCopy.slice(0, idx);\n}\nasync function _lastMaxTokens(messages, options) {\n    const { allowPartial = false, includeSystem = false, endOn, startOn, ...rest } = options;\n    // Create a copy of messages to avoid mutation\n    let messagesCopy = messages.map((message) => {\n        const fields = Object.fromEntries(Object.entries(message).filter(([k]) => k !== \"type\" && !k.startsWith(\"lc_\")));\n        return _switchTypeToMessage(message.getType(), fields, isBaseMessageChunk(message));\n    });\n    if (endOn) {\n        const endOnArr = Array.isArray(endOn) ? endOn : [endOn];\n        while (messagesCopy.length > 0 &&\n            !_isMessageType(messagesCopy[messagesCopy.length - 1], endOnArr)) {\n            messagesCopy = messagesCopy.slice(0, -1);\n        }\n    }\n    const swappedSystem = includeSystem && messagesCopy[0]?.getType() === \"system\";\n    let reversed_ = swappedSystem\n        ? messagesCopy.slice(0, 1).concat(messagesCopy.slice(1).reverse())\n        : messagesCopy.reverse();\n    reversed_ = await _firstMaxTokens(reversed_, {\n        ...rest,\n        partialStrategy: allowPartial ? \"last\" : undefined,\n        endOn: startOn,\n    });\n    if (swappedSystem) {\n        return [reversed_[0], ...reversed_.slice(1).reverse()];\n    }\n    else {\n        return reversed_.reverse();\n    }\n}\nconst _MSG_CHUNK_MAP = {\n    human: {\n        message: HumanMessage,\n        messageChunk: HumanMessageChunk,\n    },\n    ai: {\n        message: AIMessage,\n        messageChunk: AIMessageChunk,\n    },\n    system: {\n        message: SystemMessage,\n        messageChunk: SystemMessageChunk,\n    },\n    developer: {\n        message: SystemMessage,\n        messageChunk: SystemMessageChunk,\n    },\n    tool: {\n        message: ToolMessage,\n        messageChunk: ToolMessageChunk,\n    },\n    function: {\n        message: FunctionMessage,\n        messageChunk: FunctionMessageChunk,\n    },\n    generic: {\n        message: ChatMessage,\n        messageChunk: ChatMessageChunk,\n    },\n    remove: {\n        message: RemoveMessage,\n        messageChunk: RemoveMessage, // RemoveMessage does not have a chunk class.\n    },\n};\nfunction _switchTypeToMessage(messageType, fields, returnChunk) {\n    let chunk;\n    let msg;\n    switch (messageType) {\n        case \"human\":\n            if (returnChunk) {\n                chunk = new HumanMessageChunk(fields);\n            }\n            else {\n                msg = new HumanMessage(fields);\n            }\n            break;\n        case \"ai\":\n            if (returnChunk) {\n                let aiChunkFields = {\n                    ...fields,\n                };\n                if (\"tool_calls\" in aiChunkFields) {\n                    aiChunkFields = {\n                        ...aiChunkFields,\n                        tool_call_chunks: aiChunkFields.tool_calls?.map((tc) => ({\n                            ...tc,\n                            type: \"tool_call_chunk\",\n                            index: undefined,\n                            args: JSON.stringify(tc.args),\n                        })),\n                    };\n                }\n                chunk = new AIMessageChunk(aiChunkFields);\n            }\n            else {\n                msg = new AIMessage(fields);\n            }\n            break;\n        case \"system\":\n            if (returnChunk) {\n                chunk = new SystemMessageChunk(fields);\n            }\n            else {\n                msg = new SystemMessage(fields);\n            }\n            break;\n        case \"developer\":\n            if (returnChunk) {\n                chunk = new SystemMessageChunk({\n                    ...fields,\n                    additional_kwargs: {\n                        ...fields.additional_kwargs,\n                        __openai_role__: \"developer\",\n                    },\n                });\n            }\n            else {\n                msg = new SystemMessage({\n                    ...fields,\n                    additional_kwargs: {\n                        ...fields.additional_kwargs,\n                        __openai_role__: \"developer\",\n                    },\n                });\n            }\n            break;\n        case \"tool\":\n            if (\"tool_call_id\" in fields) {\n                if (returnChunk) {\n                    chunk = new ToolMessageChunk(fields);\n                }\n                else {\n                    msg = new ToolMessage(fields);\n                }\n            }\n            else {\n                throw new Error(\"Can not convert ToolMessage to ToolMessageChunk if 'tool_call_id' field is not defined.\");\n            }\n            break;\n        case \"function\":\n            if (returnChunk) {\n                chunk = new FunctionMessageChunk(fields);\n            }\n            else {\n                if (!fields.name) {\n                    throw new Error(\"FunctionMessage must have a 'name' field\");\n                }\n                msg = new FunctionMessage(fields);\n            }\n            break;\n        case \"generic\":\n            if (\"role\" in fields) {\n                if (returnChunk) {\n                    chunk = new ChatMessageChunk(fields);\n                }\n                else {\n                    msg = new ChatMessage(fields);\n                }\n            }\n            else {\n                throw new Error(\"Can not convert ChatMessage to ChatMessageChunk if 'role' field is not defined.\");\n            }\n            break;\n        default:\n            throw new Error(`Unrecognized message type ${messageType}`);\n    }\n    if (returnChunk && chunk) {\n        return chunk;\n    }\n    if (msg) {\n        return msg;\n    }\n    throw new Error(`Unrecognized message type ${messageType}`);\n}\nfunction _chunkToMsg(chunk) {\n    const chunkType = chunk.getType();\n    let msg;\n    const fields = Object.fromEntries(Object.entries(chunk).filter(([k]) => ![\"type\", \"tool_call_chunks\"].includes(k) && !k.startsWith(\"lc_\")));\n    if (chunkType in _MSG_CHUNK_MAP) {\n        msg = _switchTypeToMessage(chunkType, fields);\n    }\n    if (!msg) {\n        throw new Error(`Unrecognized message chunk class ${chunkType}. Supported classes are ${Object.keys(_MSG_CHUNK_MAP)}`);\n    }\n    return msg;\n}\n/**\n * The default text splitter function that splits text by newlines.\n *\n * @param {string} text\n * @returns A promise that resolves to an array of strings split by newlines.\n */\nexport function defaultTextSplitter(text) {\n    const splits = text.split(\"\\n\");\n    return Promise.resolve([\n        ...splits.slice(0, -1).map((s) => `${s}\\n`),\n        splits[splits.length - 1],\n    ]);\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}