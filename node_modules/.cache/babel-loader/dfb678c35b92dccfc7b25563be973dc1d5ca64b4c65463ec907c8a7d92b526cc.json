{"ast":null,"code":"import { setResponseValueAndErrors } from \"../errorMessages.js\";\nlet emojiRegex = undefined;\n/**\n * Generated from the regular expressions found here as of 2024-05-22:\n * https://github.com/colinhacks/zod/blob/master/src/types.ts.\n *\n * Expressions with /i flag have been changed accordingly.\n */\nexport const zodPatterns = {\n  /**\n   * `c` was changed to `[cC]` to replicate /i flag\n   */\n  cuid: /^[cC][^\\s-]{8,}$/,\n  cuid2: /^[0-9a-z]+$/,\n  ulid: /^[0-9A-HJKMNP-TV-Z]{26}$/,\n  /**\n   * `a-z` was added to replicate /i flag\n   */\n  email: /^(?!\\.)(?!.*\\.\\.)([a-zA-Z0-9_'+\\-\\.]*)[a-zA-Z0-9_+-]@([a-zA-Z0-9][a-zA-Z0-9\\-]*\\.)+[a-zA-Z]{2,}$/,\n  /**\n   * Constructed a valid Unicode RegExp\n   *\n   * Lazily instantiate since this type of regex isn't supported\n   * in all envs (e.g. React Native).\n   *\n   * See:\n   * https://github.com/colinhacks/zod/issues/2433\n   * Fix in Zod:\n   * https://github.com/colinhacks/zod/commit/9340fd51e48576a75adc919bff65dbc4a5d4c99b\n   */\n  emoji: () => {\n    if (emojiRegex === undefined) {\n      emojiRegex = RegExp(\"^(\\\\p{Extended_Pictographic}|\\\\p{Emoji_Component})+$\", \"u\");\n    }\n    return emojiRegex;\n  },\n  /**\n   * Unused\n   */\n  uuid: /^[0-9a-fA-F]{8}\\b-[0-9a-fA-F]{4}\\b-[0-9a-fA-F]{4}\\b-[0-9a-fA-F]{4}\\b-[0-9a-fA-F]{12}$/,\n  /**\n   * Unused\n   */\n  ipv4: /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/,\n  ipv4Cidr: /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\\/(3[0-2]|[12]?[0-9])$/,\n  /**\n   * Unused\n   */\n  ipv6: /^(([a-f0-9]{1,4}:){7}|::([a-f0-9]{1,4}:){0,6}|([a-f0-9]{1,4}:){1}:([a-f0-9]{1,4}:){0,5}|([a-f0-9]{1,4}:){2}:([a-f0-9]{1,4}:){0,4}|([a-f0-9]{1,4}:){3}:([a-f0-9]{1,4}:){0,3}|([a-f0-9]{1,4}:){4}:([a-f0-9]{1,4}:){0,2}|([a-f0-9]{1,4}:){5}:([a-f0-9]{1,4}:){0,1})([a-f0-9]{1,4}|(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2})))$/,\n  ipv6Cidr: /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))\\/(12[0-8]|1[01][0-9]|[1-9]?[0-9])$/,\n  base64: /^([0-9a-zA-Z+/]{4})*(([0-9a-zA-Z+/]{2}==)|([0-9a-zA-Z+/]{3}=))?$/,\n  base64url: /^([0-9a-zA-Z-_]{4})*(([0-9a-zA-Z-_]{2}(==)?)|([0-9a-zA-Z-_]{3}(=)?))?$/,\n  nanoid: /^[a-zA-Z0-9_-]{21}$/,\n  jwt: /^[A-Za-z0-9-_]+\\.[A-Za-z0-9-_]+\\.[A-Za-z0-9-_]*$/\n};\nexport function parseStringDef(def, refs) {\n  const res = {\n    type: \"string\"\n  };\n  if (def.checks) {\n    for (const check of def.checks) {\n      switch (check.kind) {\n        case \"min\":\n          setResponseValueAndErrors(res, \"minLength\", typeof res.minLength === \"number\" ? Math.max(res.minLength, check.value) : check.value, check.message, refs);\n          break;\n        case \"max\":\n          setResponseValueAndErrors(res, \"maxLength\", typeof res.maxLength === \"number\" ? Math.min(res.maxLength, check.value) : check.value, check.message, refs);\n          break;\n        case \"email\":\n          switch (refs.emailStrategy) {\n            case \"format:email\":\n              addFormat(res, \"email\", check.message, refs);\n              break;\n            case \"format:idn-email\":\n              addFormat(res, \"idn-email\", check.message, refs);\n              break;\n            case \"pattern:zod\":\n              addPattern(res, zodPatterns.email, check.message, refs);\n              break;\n          }\n          break;\n        case \"url\":\n          addFormat(res, \"uri\", check.message, refs);\n          break;\n        case \"uuid\":\n          addFormat(res, \"uuid\", check.message, refs);\n          break;\n        case \"regex\":\n          addPattern(res, check.regex, check.message, refs);\n          break;\n        case \"cuid\":\n          addPattern(res, zodPatterns.cuid, check.message, refs);\n          break;\n        case \"cuid2\":\n          addPattern(res, zodPatterns.cuid2, check.message, refs);\n          break;\n        case \"startsWith\":\n          addPattern(res, RegExp(`^${escapeLiteralCheckValue(check.value, refs)}`), check.message, refs);\n          break;\n        case \"endsWith\":\n          addPattern(res, RegExp(`${escapeLiteralCheckValue(check.value, refs)}$`), check.message, refs);\n          break;\n        case \"datetime\":\n          addFormat(res, \"date-time\", check.message, refs);\n          break;\n        case \"date\":\n          addFormat(res, \"date\", check.message, refs);\n          break;\n        case \"time\":\n          addFormat(res, \"time\", check.message, refs);\n          break;\n        case \"duration\":\n          addFormat(res, \"duration\", check.message, refs);\n          break;\n        case \"length\":\n          setResponseValueAndErrors(res, \"minLength\", typeof res.minLength === \"number\" ? Math.max(res.minLength, check.value) : check.value, check.message, refs);\n          setResponseValueAndErrors(res, \"maxLength\", typeof res.maxLength === \"number\" ? Math.min(res.maxLength, check.value) : check.value, check.message, refs);\n          break;\n        case \"includes\":\n          {\n            addPattern(res, RegExp(escapeLiteralCheckValue(check.value, refs)), check.message, refs);\n            break;\n          }\n        case \"ip\":\n          {\n            if (check.version !== \"v6\") {\n              addFormat(res, \"ipv4\", check.message, refs);\n            }\n            if (check.version !== \"v4\") {\n              addFormat(res, \"ipv6\", check.message, refs);\n            }\n            break;\n          }\n        case \"base64url\":\n          addPattern(res, zodPatterns.base64url, check.message, refs);\n          break;\n        case \"jwt\":\n          addPattern(res, zodPatterns.jwt, check.message, refs);\n          break;\n        case \"cidr\":\n          {\n            if (check.version !== \"v6\") {\n              addPattern(res, zodPatterns.ipv4Cidr, check.message, refs);\n            }\n            if (check.version !== \"v4\") {\n              addPattern(res, zodPatterns.ipv6Cidr, check.message, refs);\n            }\n            break;\n          }\n        case \"emoji\":\n          addPattern(res, zodPatterns.emoji(), check.message, refs);\n          break;\n        case \"ulid\":\n          {\n            addPattern(res, zodPatterns.ulid, check.message, refs);\n            break;\n          }\n        case \"base64\":\n          {\n            switch (refs.base64Strategy) {\n              case \"format:binary\":\n                {\n                  addFormat(res, \"binary\", check.message, refs);\n                  break;\n                }\n              case \"contentEncoding:base64\":\n                {\n                  setResponseValueAndErrors(res, \"contentEncoding\", \"base64\", check.message, refs);\n                  break;\n                }\n              case \"pattern:zod\":\n                {\n                  addPattern(res, zodPatterns.base64, check.message, refs);\n                  break;\n                }\n            }\n            break;\n          }\n        case \"nanoid\":\n          {\n            addPattern(res, zodPatterns.nanoid, check.message, refs);\n          }\n        case \"toLowerCase\":\n        case \"toUpperCase\":\n        case \"trim\":\n          break;\n        default:\n          /* c8 ignore next */\n          (_ => {})(check);\n      }\n    }\n  }\n  return res;\n}\nfunction escapeLiteralCheckValue(literal, refs) {\n  return refs.patternStrategy === \"escape\" ? escapeNonAlphaNumeric(literal) : literal;\n}\nconst ALPHA_NUMERIC = new Set(\"ABCDEFGHIJKLMNOPQRSTUVXYZabcdefghijklmnopqrstuvxyz0123456789\");\nfunction escapeNonAlphaNumeric(source) {\n  let result = \"\";\n  for (let i = 0; i < source.length; i++) {\n    if (!ALPHA_NUMERIC.has(source[i])) {\n      result += \"\\\\\";\n    }\n    result += source[i];\n  }\n  return result;\n}\n// Adds a \"format\" keyword to the schema. If a format exists, both formats will be joined in an allOf-node, along with subsequent ones.\nfunction addFormat(schema, value, message, refs) {\n  if (schema.format || schema.anyOf?.some(x => x.format)) {\n    if (!schema.anyOf) {\n      schema.anyOf = [];\n    }\n    if (schema.format) {\n      schema.anyOf.push({\n        format: schema.format,\n        ...(schema.errorMessage && refs.errorMessages && {\n          errorMessage: {\n            format: schema.errorMessage.format\n          }\n        })\n      });\n      delete schema.format;\n      if (schema.errorMessage) {\n        delete schema.errorMessage.format;\n        if (Object.keys(schema.errorMessage).length === 0) {\n          delete schema.errorMessage;\n        }\n      }\n    }\n    schema.anyOf.push({\n      format: value,\n      ...(message && refs.errorMessages && {\n        errorMessage: {\n          format: message\n        }\n      })\n    });\n  } else {\n    setResponseValueAndErrors(schema, \"format\", value, message, refs);\n  }\n}\n// Adds a \"pattern\" keyword to the schema. If a pattern exists, both patterns will be joined in an allOf-node, along with subsequent ones.\nfunction addPattern(schema, regex, message, refs) {\n  if (schema.pattern || schema.allOf?.some(x => x.pattern)) {\n    if (!schema.allOf) {\n      schema.allOf = [];\n    }\n    if (schema.pattern) {\n      schema.allOf.push({\n        pattern: schema.pattern,\n        ...(schema.errorMessage && refs.errorMessages && {\n          errorMessage: {\n            pattern: schema.errorMessage.pattern\n          }\n        })\n      });\n      delete schema.pattern;\n      if (schema.errorMessage) {\n        delete schema.errorMessage.pattern;\n        if (Object.keys(schema.errorMessage).length === 0) {\n          delete schema.errorMessage;\n        }\n      }\n    }\n    schema.allOf.push({\n      pattern: stringifyRegExpWithFlags(regex, refs),\n      ...(message && refs.errorMessages && {\n        errorMessage: {\n          pattern: message\n        }\n      })\n    });\n  } else {\n    setResponseValueAndErrors(schema, \"pattern\", stringifyRegExpWithFlags(regex, refs), message, refs);\n  }\n}\n// Mutate z.string.regex() in a best attempt to accommodate for regex flags when applyRegexFlags is true\nfunction stringifyRegExpWithFlags(regex, refs) {\n  if (!refs.applyRegexFlags || !regex.flags) {\n    return regex.source;\n  }\n  // Currently handled flags\n  const flags = {\n    i: regex.flags.includes(\"i\"),\n    m: regex.flags.includes(\"m\"),\n    s: regex.flags.includes(\"s\") // `.` matches newlines\n  };\n  // The general principle here is to step through each character, one at a time, applying mutations as flags require. We keep track when the current character is escaped, and when it's inside a group /like [this]/ or (also) a range like /[a-z]/. The following is fairly brittle imperative code; edit at your peril!\n  const source = flags.i ? regex.source.toLowerCase() : regex.source;\n  let pattern = \"\";\n  let isEscaped = false;\n  let inCharGroup = false;\n  let inCharRange = false;\n  for (let i = 0; i < source.length; i++) {\n    if (isEscaped) {\n      pattern += source[i];\n      isEscaped = false;\n      continue;\n    }\n    if (flags.i) {\n      if (inCharGroup) {\n        if (source[i].match(/[a-z]/)) {\n          if (inCharRange) {\n            pattern += source[i];\n            pattern += `${source[i - 2]}-${source[i]}`.toUpperCase();\n            inCharRange = false;\n          } else if (source[i + 1] === \"-\" && source[i + 2]?.match(/[a-z]/)) {\n            pattern += source[i];\n            inCharRange = true;\n          } else {\n            pattern += `${source[i]}${source[i].toUpperCase()}`;\n          }\n          continue;\n        }\n      } else if (source[i].match(/[a-z]/)) {\n        pattern += `[${source[i]}${source[i].toUpperCase()}]`;\n        continue;\n      }\n    }\n    if (flags.m) {\n      if (source[i] === \"^\") {\n        pattern += `(^|(?<=[\\r\\n]))`;\n        continue;\n      } else if (source[i] === \"$\") {\n        pattern += `($|(?=[\\r\\n]))`;\n        continue;\n      }\n    }\n    if (flags.s && source[i] === \".\") {\n      pattern += inCharGroup ? `${source[i]}\\r\\n` : `[${source[i]}\\r\\n]`;\n      continue;\n    }\n    pattern += source[i];\n    if (source[i] === \"\\\\\") {\n      isEscaped = true;\n    } else if (inCharGroup && source[i] === \"]\") {\n      inCharGroup = false;\n    } else if (!inCharGroup && source[i] === \"[\") {\n      inCharGroup = true;\n    }\n  }\n  try {\n    new RegExp(pattern);\n  } catch {\n    console.warn(`Could not convert regex pattern at ${refs.currentPath.join(\"/\")} to a flag-independent form! Falling back to the flag-ignorant source`);\n    return regex.source;\n  }\n  return pattern;\n}","map":{"version":3,"names":["setResponseValueAndErrors","emojiRegex","undefined","zodPatterns","cuid","cuid2","ulid","email","emoji","RegExp","uuid","ipv4","ipv4Cidr","ipv6","ipv6Cidr","base64","base64url","nanoid","jwt","parseStringDef","def","refs","res","type","checks","check","kind","minLength","Math","max","value","message","maxLength","min","emailStrategy","addFormat","addPattern","regex","escapeLiteralCheckValue","version","base64Strategy","_","literal","patternStrategy","escapeNonAlphaNumeric","ALPHA_NUMERIC","Set","source","result","i","length","has","schema","format","anyOf","some","x","push","errorMessage","errorMessages","Object","keys","pattern","allOf","stringifyRegExpWithFlags","applyRegexFlags","flags","includes","m","s","toLowerCase","isEscaped","inCharGroup","inCharRange","match","toUpperCase","console","warn","currentPath","join"],"sources":["/Users/youngchen/Downloads/cs224g-triage/node_modules/zod-to-json-schema/dist/esm/parsers/string.js"],"sourcesContent":["import { setResponseValueAndErrors } from \"../errorMessages.js\";\nlet emojiRegex = undefined;\n/**\n * Generated from the regular expressions found here as of 2024-05-22:\n * https://github.com/colinhacks/zod/blob/master/src/types.ts.\n *\n * Expressions with /i flag have been changed accordingly.\n */\nexport const zodPatterns = {\n    /**\n     * `c` was changed to `[cC]` to replicate /i flag\n     */\n    cuid: /^[cC][^\\s-]{8,}$/,\n    cuid2: /^[0-9a-z]+$/,\n    ulid: /^[0-9A-HJKMNP-TV-Z]{26}$/,\n    /**\n     * `a-z` was added to replicate /i flag\n     */\n    email: /^(?!\\.)(?!.*\\.\\.)([a-zA-Z0-9_'+\\-\\.]*)[a-zA-Z0-9_+-]@([a-zA-Z0-9][a-zA-Z0-9\\-]*\\.)+[a-zA-Z]{2,}$/,\n    /**\n     * Constructed a valid Unicode RegExp\n     *\n     * Lazily instantiate since this type of regex isn't supported\n     * in all envs (e.g. React Native).\n     *\n     * See:\n     * https://github.com/colinhacks/zod/issues/2433\n     * Fix in Zod:\n     * https://github.com/colinhacks/zod/commit/9340fd51e48576a75adc919bff65dbc4a5d4c99b\n     */\n    emoji: () => {\n        if (emojiRegex === undefined) {\n            emojiRegex = RegExp(\"^(\\\\p{Extended_Pictographic}|\\\\p{Emoji_Component})+$\", \"u\");\n        }\n        return emojiRegex;\n    },\n    /**\n     * Unused\n     */\n    uuid: /^[0-9a-fA-F]{8}\\b-[0-9a-fA-F]{4}\\b-[0-9a-fA-F]{4}\\b-[0-9a-fA-F]{4}\\b-[0-9a-fA-F]{12}$/,\n    /**\n     * Unused\n     */\n    ipv4: /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/,\n    ipv4Cidr: /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\\/(3[0-2]|[12]?[0-9])$/,\n    /**\n     * Unused\n     */\n    ipv6: /^(([a-f0-9]{1,4}:){7}|::([a-f0-9]{1,4}:){0,6}|([a-f0-9]{1,4}:){1}:([a-f0-9]{1,4}:){0,5}|([a-f0-9]{1,4}:){2}:([a-f0-9]{1,4}:){0,4}|([a-f0-9]{1,4}:){3}:([a-f0-9]{1,4}:){0,3}|([a-f0-9]{1,4}:){4}:([a-f0-9]{1,4}:){0,2}|([a-f0-9]{1,4}:){5}:([a-f0-9]{1,4}:){0,1})([a-f0-9]{1,4}|(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2})))$/,\n    ipv6Cidr: /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))\\/(12[0-8]|1[01][0-9]|[1-9]?[0-9])$/,\n    base64: /^([0-9a-zA-Z+/]{4})*(([0-9a-zA-Z+/]{2}==)|([0-9a-zA-Z+/]{3}=))?$/,\n    base64url: /^([0-9a-zA-Z-_]{4})*(([0-9a-zA-Z-_]{2}(==)?)|([0-9a-zA-Z-_]{3}(=)?))?$/,\n    nanoid: /^[a-zA-Z0-9_-]{21}$/,\n    jwt: /^[A-Za-z0-9-_]+\\.[A-Za-z0-9-_]+\\.[A-Za-z0-9-_]*$/,\n};\nexport function parseStringDef(def, refs) {\n    const res = {\n        type: \"string\",\n    };\n    if (def.checks) {\n        for (const check of def.checks) {\n            switch (check.kind) {\n                case \"min\":\n                    setResponseValueAndErrors(res, \"minLength\", typeof res.minLength === \"number\"\n                        ? Math.max(res.minLength, check.value)\n                        : check.value, check.message, refs);\n                    break;\n                case \"max\":\n                    setResponseValueAndErrors(res, \"maxLength\", typeof res.maxLength === \"number\"\n                        ? Math.min(res.maxLength, check.value)\n                        : check.value, check.message, refs);\n                    break;\n                case \"email\":\n                    switch (refs.emailStrategy) {\n                        case \"format:email\":\n                            addFormat(res, \"email\", check.message, refs);\n                            break;\n                        case \"format:idn-email\":\n                            addFormat(res, \"idn-email\", check.message, refs);\n                            break;\n                        case \"pattern:zod\":\n                            addPattern(res, zodPatterns.email, check.message, refs);\n                            break;\n                    }\n                    break;\n                case \"url\":\n                    addFormat(res, \"uri\", check.message, refs);\n                    break;\n                case \"uuid\":\n                    addFormat(res, \"uuid\", check.message, refs);\n                    break;\n                case \"regex\":\n                    addPattern(res, check.regex, check.message, refs);\n                    break;\n                case \"cuid\":\n                    addPattern(res, zodPatterns.cuid, check.message, refs);\n                    break;\n                case \"cuid2\":\n                    addPattern(res, zodPatterns.cuid2, check.message, refs);\n                    break;\n                case \"startsWith\":\n                    addPattern(res, RegExp(`^${escapeLiteralCheckValue(check.value, refs)}`), check.message, refs);\n                    break;\n                case \"endsWith\":\n                    addPattern(res, RegExp(`${escapeLiteralCheckValue(check.value, refs)}$`), check.message, refs);\n                    break;\n                case \"datetime\":\n                    addFormat(res, \"date-time\", check.message, refs);\n                    break;\n                case \"date\":\n                    addFormat(res, \"date\", check.message, refs);\n                    break;\n                case \"time\":\n                    addFormat(res, \"time\", check.message, refs);\n                    break;\n                case \"duration\":\n                    addFormat(res, \"duration\", check.message, refs);\n                    break;\n                case \"length\":\n                    setResponseValueAndErrors(res, \"minLength\", typeof res.minLength === \"number\"\n                        ? Math.max(res.minLength, check.value)\n                        : check.value, check.message, refs);\n                    setResponseValueAndErrors(res, \"maxLength\", typeof res.maxLength === \"number\"\n                        ? Math.min(res.maxLength, check.value)\n                        : check.value, check.message, refs);\n                    break;\n                case \"includes\": {\n                    addPattern(res, RegExp(escapeLiteralCheckValue(check.value, refs)), check.message, refs);\n                    break;\n                }\n                case \"ip\": {\n                    if (check.version !== \"v6\") {\n                        addFormat(res, \"ipv4\", check.message, refs);\n                    }\n                    if (check.version !== \"v4\") {\n                        addFormat(res, \"ipv6\", check.message, refs);\n                    }\n                    break;\n                }\n                case \"base64url\":\n                    addPattern(res, zodPatterns.base64url, check.message, refs);\n                    break;\n                case \"jwt\":\n                    addPattern(res, zodPatterns.jwt, check.message, refs);\n                    break;\n                case \"cidr\": {\n                    if (check.version !== \"v6\") {\n                        addPattern(res, zodPatterns.ipv4Cidr, check.message, refs);\n                    }\n                    if (check.version !== \"v4\") {\n                        addPattern(res, zodPatterns.ipv6Cidr, check.message, refs);\n                    }\n                    break;\n                }\n                case \"emoji\":\n                    addPattern(res, zodPatterns.emoji(), check.message, refs);\n                    break;\n                case \"ulid\": {\n                    addPattern(res, zodPatterns.ulid, check.message, refs);\n                    break;\n                }\n                case \"base64\": {\n                    switch (refs.base64Strategy) {\n                        case \"format:binary\": {\n                            addFormat(res, \"binary\", check.message, refs);\n                            break;\n                        }\n                        case \"contentEncoding:base64\": {\n                            setResponseValueAndErrors(res, \"contentEncoding\", \"base64\", check.message, refs);\n                            break;\n                        }\n                        case \"pattern:zod\": {\n                            addPattern(res, zodPatterns.base64, check.message, refs);\n                            break;\n                        }\n                    }\n                    break;\n                }\n                case \"nanoid\": {\n                    addPattern(res, zodPatterns.nanoid, check.message, refs);\n                }\n                case \"toLowerCase\":\n                case \"toUpperCase\":\n                case \"trim\":\n                    break;\n                default:\n                    /* c8 ignore next */\n                    ((_) => { })(check);\n            }\n        }\n    }\n    return res;\n}\nfunction escapeLiteralCheckValue(literal, refs) {\n    return refs.patternStrategy === \"escape\"\n        ? escapeNonAlphaNumeric(literal)\n        : literal;\n}\nconst ALPHA_NUMERIC = new Set(\"ABCDEFGHIJKLMNOPQRSTUVXYZabcdefghijklmnopqrstuvxyz0123456789\");\nfunction escapeNonAlphaNumeric(source) {\n    let result = \"\";\n    for (let i = 0; i < source.length; i++) {\n        if (!ALPHA_NUMERIC.has(source[i])) {\n            result += \"\\\\\";\n        }\n        result += source[i];\n    }\n    return result;\n}\n// Adds a \"format\" keyword to the schema. If a format exists, both formats will be joined in an allOf-node, along with subsequent ones.\nfunction addFormat(schema, value, message, refs) {\n    if (schema.format || schema.anyOf?.some((x) => x.format)) {\n        if (!schema.anyOf) {\n            schema.anyOf = [];\n        }\n        if (schema.format) {\n            schema.anyOf.push({\n                format: schema.format,\n                ...(schema.errorMessage &&\n                    refs.errorMessages && {\n                    errorMessage: { format: schema.errorMessage.format },\n                }),\n            });\n            delete schema.format;\n            if (schema.errorMessage) {\n                delete schema.errorMessage.format;\n                if (Object.keys(schema.errorMessage).length === 0) {\n                    delete schema.errorMessage;\n                }\n            }\n        }\n        schema.anyOf.push({\n            format: value,\n            ...(message &&\n                refs.errorMessages && { errorMessage: { format: message } }),\n        });\n    }\n    else {\n        setResponseValueAndErrors(schema, \"format\", value, message, refs);\n    }\n}\n// Adds a \"pattern\" keyword to the schema. If a pattern exists, both patterns will be joined in an allOf-node, along with subsequent ones.\nfunction addPattern(schema, regex, message, refs) {\n    if (schema.pattern || schema.allOf?.some((x) => x.pattern)) {\n        if (!schema.allOf) {\n            schema.allOf = [];\n        }\n        if (schema.pattern) {\n            schema.allOf.push({\n                pattern: schema.pattern,\n                ...(schema.errorMessage &&\n                    refs.errorMessages && {\n                    errorMessage: { pattern: schema.errorMessage.pattern },\n                }),\n            });\n            delete schema.pattern;\n            if (schema.errorMessage) {\n                delete schema.errorMessage.pattern;\n                if (Object.keys(schema.errorMessage).length === 0) {\n                    delete schema.errorMessage;\n                }\n            }\n        }\n        schema.allOf.push({\n            pattern: stringifyRegExpWithFlags(regex, refs),\n            ...(message &&\n                refs.errorMessages && { errorMessage: { pattern: message } }),\n        });\n    }\n    else {\n        setResponseValueAndErrors(schema, \"pattern\", stringifyRegExpWithFlags(regex, refs), message, refs);\n    }\n}\n// Mutate z.string.regex() in a best attempt to accommodate for regex flags when applyRegexFlags is true\nfunction stringifyRegExpWithFlags(regex, refs) {\n    if (!refs.applyRegexFlags || !regex.flags) {\n        return regex.source;\n    }\n    // Currently handled flags\n    const flags = {\n        i: regex.flags.includes(\"i\"),\n        m: regex.flags.includes(\"m\"),\n        s: regex.flags.includes(\"s\"), // `.` matches newlines\n    };\n    // The general principle here is to step through each character, one at a time, applying mutations as flags require. We keep track when the current character is escaped, and when it's inside a group /like [this]/ or (also) a range like /[a-z]/. The following is fairly brittle imperative code; edit at your peril!\n    const source = flags.i ? regex.source.toLowerCase() : regex.source;\n    let pattern = \"\";\n    let isEscaped = false;\n    let inCharGroup = false;\n    let inCharRange = false;\n    for (let i = 0; i < source.length; i++) {\n        if (isEscaped) {\n            pattern += source[i];\n            isEscaped = false;\n            continue;\n        }\n        if (flags.i) {\n            if (inCharGroup) {\n                if (source[i].match(/[a-z]/)) {\n                    if (inCharRange) {\n                        pattern += source[i];\n                        pattern += `${source[i - 2]}-${source[i]}`.toUpperCase();\n                        inCharRange = false;\n                    }\n                    else if (source[i + 1] === \"-\" && source[i + 2]?.match(/[a-z]/)) {\n                        pattern += source[i];\n                        inCharRange = true;\n                    }\n                    else {\n                        pattern += `${source[i]}${source[i].toUpperCase()}`;\n                    }\n                    continue;\n                }\n            }\n            else if (source[i].match(/[a-z]/)) {\n                pattern += `[${source[i]}${source[i].toUpperCase()}]`;\n                continue;\n            }\n        }\n        if (flags.m) {\n            if (source[i] === \"^\") {\n                pattern += `(^|(?<=[\\r\\n]))`;\n                continue;\n            }\n            else if (source[i] === \"$\") {\n                pattern += `($|(?=[\\r\\n]))`;\n                continue;\n            }\n        }\n        if (flags.s && source[i] === \".\") {\n            pattern += inCharGroup ? `${source[i]}\\r\\n` : `[${source[i]}\\r\\n]`;\n            continue;\n        }\n        pattern += source[i];\n        if (source[i] === \"\\\\\") {\n            isEscaped = true;\n        }\n        else if (inCharGroup && source[i] === \"]\") {\n            inCharGroup = false;\n        }\n        else if (!inCharGroup && source[i] === \"[\") {\n            inCharGroup = true;\n        }\n    }\n    try {\n        new RegExp(pattern);\n    }\n    catch {\n        console.warn(`Could not convert regex pattern at ${refs.currentPath.join(\"/\")} to a flag-independent form! Falling back to the flag-ignorant source`);\n        return regex.source;\n    }\n    return pattern;\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}