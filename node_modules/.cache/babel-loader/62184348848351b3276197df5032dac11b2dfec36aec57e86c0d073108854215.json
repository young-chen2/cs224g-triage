{"ast":null,"code":"import { parseDef } from \"./parseDef.mjs\";\nimport { getRefs } from \"./Refs.mjs\";\nimport { zodDef, isEmptyObj } from \"./util.mjs\";\nconst zodToJsonSchema = (schema, options) => {\n  const refs = getRefs(options);\n  const name = typeof options === 'string' ? options : options?.nameStrategy === 'title' ? undefined : options?.name;\n  const main = parseDef(schema._def, name === undefined ? refs : {\n    ...refs,\n    currentPath: [...refs.basePath, refs.definitionPath, name]\n  }, false) ?? {};\n  const title = typeof options === 'object' && options.name !== undefined && options.nameStrategy === 'title' ? options.name : undefined;\n  if (title !== undefined) {\n    main.title = title;\n  }\n  const definitions = (() => {\n    if (isEmptyObj(refs.definitions)) {\n      return undefined;\n    }\n    const definitions = {};\n    const processedDefinitions = new Set();\n    // the call to `parseDef()` here might itself add more entries to `.definitions`\n    // so we need to continually evaluate definitions until we've resolved all of them\n    //\n    // we have a generous iteration limit here to avoid blowing up the stack if there\n    // are any bugs that would otherwise result in us iterating indefinitely\n    for (let i = 0; i < 500; i++) {\n      const newDefinitions = Object.entries(refs.definitions).filter(([key]) => !processedDefinitions.has(key));\n      if (newDefinitions.length === 0) break;\n      for (const [key, schema] of newDefinitions) {\n        definitions[key] = parseDef(zodDef(schema), {\n          ...refs,\n          currentPath: [...refs.basePath, refs.definitionPath, key]\n        }, true) ?? {};\n        processedDefinitions.add(key);\n      }\n    }\n    return definitions;\n  })();\n  const combined = name === undefined ? definitions ? {\n    ...main,\n    [refs.definitionPath]: definitions\n  } : main : refs.nameStrategy === 'duplicate-ref' ? {\n    ...main,\n    ...(definitions || refs.seenRefs.size ? {\n      [refs.definitionPath]: {\n        ...definitions,\n        // only actually duplicate the schema definition if it was ever referenced\n        // otherwise the duplication is completely pointless\n        ...(refs.seenRefs.size ? {\n          [name]: main\n        } : undefined)\n      }\n    } : undefined)\n  } : {\n    $ref: [...(refs.$refStrategy === 'relative' ? [] : refs.basePath), refs.definitionPath, name].join('/'),\n    [refs.definitionPath]: {\n      ...definitions,\n      [name]: main\n    }\n  };\n  if (refs.target === 'jsonSchema7') {\n    combined.$schema = 'http://json-schema.org/draft-07/schema#';\n  } else if (refs.target === 'jsonSchema2019-09') {\n    combined.$schema = 'https://json-schema.org/draft/2019-09/schema#';\n  }\n  return combined;\n};\nexport { zodToJsonSchema };","map":{"version":3,"names":["parseDef","getRefs","zodDef","isEmptyObj","zodToJsonSchema","schema","options","refs","name","nameStrategy","undefined","main","_def","currentPath","basePath","definitionPath","title","definitions","processedDefinitions","Set","i","newDefinitions","Object","entries","filter","key","has","length","add","combined","seenRefs","size","$ref","$refStrategy","join","target","$schema"],"sources":["/Users/youngchen/Downloads/cs224g-triage/node_modules/openai/src/_vendor/zod-to-json-schema/zodToJsonSchema.ts"],"sourcesContent":["import { ZodSchema } from 'zod';\nimport { Options, Targets } from './Options';\nimport { JsonSchema7Type, parseDef } from './parseDef';\nimport { getRefs } from './Refs';\nimport { zodDef, isEmptyObj } from './util';\n\nconst zodToJsonSchema = <Target extends Targets = 'jsonSchema7'>(\n  schema: ZodSchema<any>,\n  options?: Partial<Options<Target>> | string,\n): (Target extends 'jsonSchema7' ? JsonSchema7Type : object) & {\n  $schema?: string;\n  definitions?: {\n    [key: string]: Target extends 'jsonSchema7' ? JsonSchema7Type\n    : Target extends 'jsonSchema2019-09' ? JsonSchema7Type\n    : object;\n  };\n} => {\n  const refs = getRefs(options);\n\n  const name =\n    typeof options === 'string' ? options\n    : options?.nameStrategy === 'title' ? undefined\n    : options?.name;\n\n  const main =\n    parseDef(\n      schema._def,\n      name === undefined ? refs : (\n        {\n          ...refs,\n          currentPath: [...refs.basePath, refs.definitionPath, name],\n        }\n      ),\n      false,\n    ) ?? {};\n\n  const title =\n    typeof options === 'object' && options.name !== undefined && options.nameStrategy === 'title' ?\n      options.name\n    : undefined;\n\n  if (title !== undefined) {\n    main.title = title;\n  }\n\n  const definitions = (() => {\n    if (isEmptyObj(refs.definitions)) {\n      return undefined;\n    }\n\n    const definitions: Record<string, any> = {};\n    const processedDefinitions = new Set();\n\n    // the call to `parseDef()` here might itself add more entries to `.definitions`\n    // so we need to continually evaluate definitions until we've resolved all of them\n    //\n    // we have a generous iteration limit here to avoid blowing up the stack if there\n    // are any bugs that would otherwise result in us iterating indefinitely\n    for (let i = 0; i < 500; i++) {\n      const newDefinitions = Object.entries(refs.definitions).filter(\n        ([key]) => !processedDefinitions.has(key),\n      );\n      if (newDefinitions.length === 0) break;\n\n      for (const [key, schema] of newDefinitions) {\n        definitions[key] =\n          parseDef(\n            zodDef(schema),\n            { ...refs, currentPath: [...refs.basePath, refs.definitionPath, key] },\n            true,\n          ) ?? {};\n        processedDefinitions.add(key);\n      }\n    }\n\n    return definitions;\n  })();\n\n  const combined: ReturnType<typeof zodToJsonSchema<Target>> =\n    name === undefined ?\n      definitions ?\n        {\n          ...main,\n          [refs.definitionPath]: definitions,\n        }\n      : main\n    : refs.nameStrategy === 'duplicate-ref' ?\n      {\n        ...main,\n        ...(definitions || refs.seenRefs.size ?\n          {\n            [refs.definitionPath]: {\n              ...definitions,\n              // only actually duplicate the schema definition if it was ever referenced\n              // otherwise the duplication is completely pointless\n              ...(refs.seenRefs.size ? { [name]: main } : undefined),\n            },\n          }\n        : undefined),\n      }\n    : {\n        $ref: [...(refs.$refStrategy === 'relative' ? [] : refs.basePath), refs.definitionPath, name].join(\n          '/',\n        ),\n        [refs.definitionPath]: {\n          ...definitions,\n          [name]: main,\n        },\n      };\n\n  if (refs.target === 'jsonSchema7') {\n    combined.$schema = 'http://json-schema.org/draft-07/schema#';\n  } else if (refs.target === 'jsonSchema2019-09') {\n    combined.$schema = 'https://json-schema.org/draft/2019-09/schema#';\n  }\n\n  return combined;\n};\n\nexport { zodToJsonSchema };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}