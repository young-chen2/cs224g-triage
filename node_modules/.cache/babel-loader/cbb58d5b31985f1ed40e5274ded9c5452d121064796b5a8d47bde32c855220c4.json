{"ast":null,"code":"import { setResponseValueAndErrors } from \"../errorMessages.mjs\";\nlet emojiRegex;\n/**\n * Generated from the regular expressions found here as of 2024-05-22:\n * https://github.com/colinhacks/zod/blob/master/src/types.ts.\n *\n * Expressions with /i flag have been changed accordingly.\n */\nexport const zodPatterns = {\n  /**\n   * `c` was changed to `[cC]` to replicate /i flag\n   */\n  cuid: /^[cC][^\\s-]{8,}$/,\n  cuid2: /^[0-9a-z]+$/,\n  ulid: /^[0-9A-HJKMNP-TV-Z]{26}$/,\n  /**\n   * `a-z` was added to replicate /i flag\n   */\n  email: /^(?!\\.)(?!.*\\.\\.)([a-zA-Z0-9_'+\\-\\.]*)[a-zA-Z0-9_+-]@([a-zA-Z0-9][a-zA-Z0-9\\-]*\\.)+[a-zA-Z]{2,}$/,\n  /**\n   * Constructed a valid Unicode RegExp\n   *\n   * Lazily instantiate since this type of regex isn't supported\n   * in all envs (e.g. React Native).\n   *\n   * See:\n   * https://github.com/colinhacks/zod/issues/2433\n   * Fix in Zod:\n   * https://github.com/colinhacks/zod/commit/9340fd51e48576a75adc919bff65dbc4a5d4c99b\n   */\n  emoji: () => {\n    if (emojiRegex === undefined) {\n      emojiRegex = RegExp('^(\\\\p{Extended_Pictographic}|\\\\p{Emoji_Component})+$', 'u');\n    }\n    return emojiRegex;\n  },\n  /**\n   * Unused\n   */\n  uuid: /^[0-9a-fA-F]{8}\\b-[0-9a-fA-F]{4}\\b-[0-9a-fA-F]{4}\\b-[0-9a-fA-F]{4}\\b-[0-9a-fA-F]{12}$/,\n  /**\n   * Unused\n   */\n  ipv4: /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/,\n  /**\n   * Unused\n   */\n  ipv6: /^(([a-f0-9]{1,4}:){7}|::([a-f0-9]{1,4}:){0,6}|([a-f0-9]{1,4}:){1}:([a-f0-9]{1,4}:){0,5}|([a-f0-9]{1,4}:){2}:([a-f0-9]{1,4}:){0,4}|([a-f0-9]{1,4}:){3}:([a-f0-9]{1,4}:){0,3}|([a-f0-9]{1,4}:){4}:([a-f0-9]{1,4}:){0,2}|([a-f0-9]{1,4}:){5}:([a-f0-9]{1,4}:){0,1})([a-f0-9]{1,4}|(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2})))$/,\n  base64: /^([0-9a-zA-Z+/]{4})*(([0-9a-zA-Z+/]{2}==)|([0-9a-zA-Z+/]{3}=))?$/,\n  nanoid: /^[a-zA-Z0-9_-]{21}$/\n};\nexport function parseStringDef(def, refs) {\n  const res = {\n    type: 'string'\n  };\n  function processPattern(value) {\n    return refs.patternStrategy === 'escape' ? escapeNonAlphaNumeric(value) : value;\n  }\n  if (def.checks) {\n    for (const check of def.checks) {\n      switch (check.kind) {\n        case 'min':\n          setResponseValueAndErrors(res, 'minLength', typeof res.minLength === 'number' ? Math.max(res.minLength, check.value) : check.value, check.message, refs);\n          break;\n        case 'max':\n          setResponseValueAndErrors(res, 'maxLength', typeof res.maxLength === 'number' ? Math.min(res.maxLength, check.value) : check.value, check.message, refs);\n          break;\n        case 'email':\n          switch (refs.emailStrategy) {\n            case 'format:email':\n              addFormat(res, 'email', check.message, refs);\n              break;\n            case 'format:idn-email':\n              addFormat(res, 'idn-email', check.message, refs);\n              break;\n            case 'pattern:zod':\n              addPattern(res, zodPatterns.email, check.message, refs);\n              break;\n          }\n          break;\n        case 'url':\n          addFormat(res, 'uri', check.message, refs);\n          break;\n        case 'uuid':\n          addFormat(res, 'uuid', check.message, refs);\n          break;\n        case 'regex':\n          addPattern(res, check.regex, check.message, refs);\n          break;\n        case 'cuid':\n          addPattern(res, zodPatterns.cuid, check.message, refs);\n          break;\n        case 'cuid2':\n          addPattern(res, zodPatterns.cuid2, check.message, refs);\n          break;\n        case 'startsWith':\n          addPattern(res, RegExp(`^${processPattern(check.value)}`), check.message, refs);\n          break;\n        case 'endsWith':\n          addPattern(res, RegExp(`${processPattern(check.value)}$`), check.message, refs);\n          break;\n        case 'datetime':\n          addFormat(res, 'date-time', check.message, refs);\n          break;\n        case 'date':\n          addFormat(res, 'date', check.message, refs);\n          break;\n        case 'time':\n          addFormat(res, 'time', check.message, refs);\n          break;\n        case 'duration':\n          addFormat(res, 'duration', check.message, refs);\n          break;\n        case 'length':\n          setResponseValueAndErrors(res, 'minLength', typeof res.minLength === 'number' ? Math.max(res.minLength, check.value) : check.value, check.message, refs);\n          setResponseValueAndErrors(res, 'maxLength', typeof res.maxLength === 'number' ? Math.min(res.maxLength, check.value) : check.value, check.message, refs);\n          break;\n        case 'includes':\n          {\n            addPattern(res, RegExp(processPattern(check.value)), check.message, refs);\n            break;\n          }\n        case 'ip':\n          {\n            if (check.version !== 'v6') {\n              addFormat(res, 'ipv4', check.message, refs);\n            }\n            if (check.version !== 'v4') {\n              addFormat(res, 'ipv6', check.message, refs);\n            }\n            break;\n          }\n        case 'emoji':\n          addPattern(res, zodPatterns.emoji, check.message, refs);\n          break;\n        case 'ulid':\n          {\n            addPattern(res, zodPatterns.ulid, check.message, refs);\n            break;\n          }\n        case 'base64':\n          {\n            switch (refs.base64Strategy) {\n              case 'format:binary':\n                {\n                  addFormat(res, 'binary', check.message, refs);\n                  break;\n                }\n              case 'contentEncoding:base64':\n                {\n                  setResponseValueAndErrors(res, 'contentEncoding', 'base64', check.message, refs);\n                  break;\n                }\n              case 'pattern:zod':\n                {\n                  addPattern(res, zodPatterns.base64, check.message, refs);\n                  break;\n                }\n            }\n            break;\n          }\n        case 'nanoid':\n          {\n            addPattern(res, zodPatterns.nanoid, check.message, refs);\n          }\n        case 'toLowerCase':\n        case 'toUpperCase':\n        case 'trim':\n          break;\n        default:\n          (_ => {})(check);\n      }\n    }\n  }\n  return res;\n}\nconst escapeNonAlphaNumeric = value => Array.from(value).map(c => /[a-zA-Z0-9]/.test(c) ? c : `\\\\${c}`).join('');\nconst addFormat = (schema, value, message, refs) => {\n  if (schema.format || schema.anyOf?.some(x => x.format)) {\n    if (!schema.anyOf) {\n      schema.anyOf = [];\n    }\n    if (schema.format) {\n      schema.anyOf.push({\n        format: schema.format,\n        ...(schema.errorMessage && refs.errorMessages && {\n          errorMessage: {\n            format: schema.errorMessage.format\n          }\n        })\n      });\n      delete schema.format;\n      if (schema.errorMessage) {\n        delete schema.errorMessage.format;\n        if (Object.keys(schema.errorMessage).length === 0) {\n          delete schema.errorMessage;\n        }\n      }\n    }\n    schema.anyOf.push({\n      format: value,\n      ...(message && refs.errorMessages && {\n        errorMessage: {\n          format: message\n        }\n      })\n    });\n  } else {\n    setResponseValueAndErrors(schema, 'format', value, message, refs);\n  }\n};\nconst addPattern = (schema, regex, message, refs) => {\n  if (schema.pattern || schema.allOf?.some(x => x.pattern)) {\n    if (!schema.allOf) {\n      schema.allOf = [];\n    }\n    if (schema.pattern) {\n      schema.allOf.push({\n        pattern: schema.pattern,\n        ...(schema.errorMessage && refs.errorMessages && {\n          errorMessage: {\n            pattern: schema.errorMessage.pattern\n          }\n        })\n      });\n      delete schema.pattern;\n      if (schema.errorMessage) {\n        delete schema.errorMessage.pattern;\n        if (Object.keys(schema.errorMessage).length === 0) {\n          delete schema.errorMessage;\n        }\n      }\n    }\n    schema.allOf.push({\n      pattern: processRegExp(regex, refs),\n      ...(message && refs.errorMessages && {\n        errorMessage: {\n          pattern: message\n        }\n      })\n    });\n  } else {\n    setResponseValueAndErrors(schema, 'pattern', processRegExp(regex, refs), message, refs);\n  }\n};\n// Mutate z.string.regex() in a best attempt to accommodate for regex flags when applyRegexFlags is true\nconst processRegExp = (regexOrFunction, refs) => {\n  const regex = typeof regexOrFunction === 'function' ? regexOrFunction() : regexOrFunction;\n  if (!refs.applyRegexFlags || !regex.flags) return regex.source;\n  // Currently handled flags\n  const flags = {\n    i: regex.flags.includes('i'),\n    m: regex.flags.includes('m'),\n    s: regex.flags.includes('s') // `.` matches newlines\n  };\n  // The general principle here is to step through each character, one at a time, applying mutations as flags require. We keep track when the current character is escaped, and when it's inside a group /like [this]/ or (also) a range like /[a-z]/. The following is fairly brittle imperative code; edit at your peril!\n  const source = flags.i ? regex.source.toLowerCase() : regex.source;\n  let pattern = '';\n  let isEscaped = false;\n  let inCharGroup = false;\n  let inCharRange = false;\n  for (let i = 0; i < source.length; i++) {\n    if (isEscaped) {\n      pattern += source[i];\n      isEscaped = false;\n      continue;\n    }\n    if (flags.i) {\n      if (inCharGroup) {\n        if (source[i].match(/[a-z]/)) {\n          if (inCharRange) {\n            pattern += source[i];\n            pattern += `${source[i - 2]}-${source[i]}`.toUpperCase();\n            inCharRange = false;\n          } else if (source[i + 1] === '-' && source[i + 2]?.match(/[a-z]/)) {\n            pattern += source[i];\n            inCharRange = true;\n          } else {\n            pattern += `${source[i]}${source[i].toUpperCase()}`;\n          }\n          continue;\n        }\n      } else if (source[i].match(/[a-z]/)) {\n        pattern += `[${source[i]}${source[i].toUpperCase()}]`;\n        continue;\n      }\n    }\n    if (flags.m) {\n      if (source[i] === '^') {\n        pattern += `(^|(?<=[\\r\\n]))`;\n        continue;\n      } else if (source[i] === '$') {\n        pattern += `($|(?=[\\r\\n]))`;\n        continue;\n      }\n    }\n    if (flags.s && source[i] === '.') {\n      pattern += inCharGroup ? `${source[i]}\\r\\n` : `[${source[i]}\\r\\n]`;\n      continue;\n    }\n    pattern += source[i];\n    if (source[i] === '\\\\') {\n      isEscaped = true;\n    } else if (inCharGroup && source[i] === ']') {\n      inCharGroup = false;\n    } else if (!inCharGroup && source[i] === '[') {\n      inCharGroup = true;\n    }\n  }\n  try {\n    const regexTest = new RegExp(pattern);\n  } catch {\n    console.warn(`Could not convert regex pattern at ${refs.currentPath.join('/')} to a flag-independent form! Falling back to the flag-ignorant source`);\n    return regex.source;\n  }\n  return pattern;\n};","map":{"version":3,"names":["setResponseValueAndErrors","emojiRegex","zodPatterns","cuid","cuid2","ulid","email","emoji","undefined","RegExp","uuid","ipv4","ipv6","base64","nanoid","parseStringDef","def","refs","res","type","processPattern","value","patternStrategy","escapeNonAlphaNumeric","checks","check","kind","minLength","Math","max","message","maxLength","min","emailStrategy","addFormat","addPattern","regex","version","base64Strategy","_","Array","from","map","c","test","join","schema","format","anyOf","some","x","push","errorMessage","errorMessages","Object","keys","length","pattern","allOf","processRegExp","regexOrFunction","applyRegexFlags","flags","source","i","includes","m","s","toLowerCase","isEscaped","inCharGroup","inCharRange","match","toUpperCase","regexTest","console","warn","currentPath"],"sources":["/Users/youngchen/Downloads/cs224g-triage/node_modules/openai/src/_vendor/zod-to-json-schema/parsers/string.ts"],"sourcesContent":["// @ts-nocheck\nimport { ZodStringDef } from 'zod';\nimport { ErrorMessages, setResponseValueAndErrors } from '../errorMessages';\nimport { Refs } from '../Refs';\n\nlet emojiRegex: RegExp | undefined;\n\n/**\n * Generated from the regular expressions found here as of 2024-05-22:\n * https://github.com/colinhacks/zod/blob/master/src/types.ts.\n *\n * Expressions with /i flag have been changed accordingly.\n */\nexport const zodPatterns = {\n  /**\n   * `c` was changed to `[cC]` to replicate /i flag\n   */\n  cuid: /^[cC][^\\s-]{8,}$/,\n  cuid2: /^[0-9a-z]+$/,\n  ulid: /^[0-9A-HJKMNP-TV-Z]{26}$/,\n  /**\n   * `a-z` was added to replicate /i flag\n   */\n  email: /^(?!\\.)(?!.*\\.\\.)([a-zA-Z0-9_'+\\-\\.]*)[a-zA-Z0-9_+-]@([a-zA-Z0-9][a-zA-Z0-9\\-]*\\.)+[a-zA-Z]{2,}$/,\n  /**\n   * Constructed a valid Unicode RegExp\n   *\n   * Lazily instantiate since this type of regex isn't supported\n   * in all envs (e.g. React Native).\n   *\n   * See:\n   * https://github.com/colinhacks/zod/issues/2433\n   * Fix in Zod:\n   * https://github.com/colinhacks/zod/commit/9340fd51e48576a75adc919bff65dbc4a5d4c99b\n   */\n  emoji: () => {\n    if (emojiRegex === undefined) {\n      emojiRegex = RegExp('^(\\\\p{Extended_Pictographic}|\\\\p{Emoji_Component})+$', 'u');\n    }\n    return emojiRegex;\n  },\n  /**\n   * Unused\n   */\n  uuid: /^[0-9a-fA-F]{8}\\b-[0-9a-fA-F]{4}\\b-[0-9a-fA-F]{4}\\b-[0-9a-fA-F]{4}\\b-[0-9a-fA-F]{12}$/,\n  /**\n   * Unused\n   */\n  ipv4: /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/,\n  /**\n   * Unused\n   */\n  ipv6: /^(([a-f0-9]{1,4}:){7}|::([a-f0-9]{1,4}:){0,6}|([a-f0-9]{1,4}:){1}:([a-f0-9]{1,4}:){0,5}|([a-f0-9]{1,4}:){2}:([a-f0-9]{1,4}:){0,4}|([a-f0-9]{1,4}:){3}:([a-f0-9]{1,4}:){0,3}|([a-f0-9]{1,4}:){4}:([a-f0-9]{1,4}:){0,2}|([a-f0-9]{1,4}:){5}:([a-f0-9]{1,4}:){0,1})([a-f0-9]{1,4}|(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2})))$/,\n  base64: /^([0-9a-zA-Z+/]{4})*(([0-9a-zA-Z+/]{2}==)|([0-9a-zA-Z+/]{3}=))?$/,\n  nanoid: /^[a-zA-Z0-9_-]{21}$/,\n} as const;\n\nexport type JsonSchema7StringType = {\n  type: 'string';\n  minLength?: number;\n  maxLength?: number;\n  format?:\n    | 'email'\n    | 'idn-email'\n    | 'uri'\n    | 'uuid'\n    | 'date-time'\n    | 'ipv4'\n    | 'ipv6'\n    | 'date'\n    | 'time'\n    | 'duration';\n  pattern?: string;\n  allOf?: {\n    pattern: string;\n    errorMessage?: ErrorMessages<{ pattern: string }>;\n  }[];\n  anyOf?: {\n    format: string;\n    errorMessage?: ErrorMessages<{ format: string }>;\n  }[];\n  errorMessage?: ErrorMessages<JsonSchema7StringType>;\n  contentEncoding?: string;\n};\n\nexport function parseStringDef(def: ZodStringDef, refs: Refs): JsonSchema7StringType {\n  const res: JsonSchema7StringType = {\n    type: 'string',\n  };\n\n  function processPattern(value: string): string {\n    return refs.patternStrategy === 'escape' ? escapeNonAlphaNumeric(value) : value;\n  }\n\n  if (def.checks) {\n    for (const check of def.checks) {\n      switch (check.kind) {\n        case 'min':\n          setResponseValueAndErrors(\n            res,\n            'minLength',\n            typeof res.minLength === 'number' ? Math.max(res.minLength, check.value) : check.value,\n            check.message,\n            refs,\n          );\n          break;\n        case 'max':\n          setResponseValueAndErrors(\n            res,\n            'maxLength',\n            typeof res.maxLength === 'number' ? Math.min(res.maxLength, check.value) : check.value,\n            check.message,\n            refs,\n          );\n\n          break;\n        case 'email':\n          switch (refs.emailStrategy) {\n            case 'format:email':\n              addFormat(res, 'email', check.message, refs);\n              break;\n            case 'format:idn-email':\n              addFormat(res, 'idn-email', check.message, refs);\n              break;\n            case 'pattern:zod':\n              addPattern(res, zodPatterns.email, check.message, refs);\n              break;\n          }\n\n          break;\n        case 'url':\n          addFormat(res, 'uri', check.message, refs);\n          break;\n        case 'uuid':\n          addFormat(res, 'uuid', check.message, refs);\n          break;\n        case 'regex':\n          addPattern(res, check.regex, check.message, refs);\n          break;\n        case 'cuid':\n          addPattern(res, zodPatterns.cuid, check.message, refs);\n          break;\n        case 'cuid2':\n          addPattern(res, zodPatterns.cuid2, check.message, refs);\n          break;\n        case 'startsWith':\n          addPattern(res, RegExp(`^${processPattern(check.value)}`), check.message, refs);\n          break;\n        case 'endsWith':\n          addPattern(res, RegExp(`${processPattern(check.value)}$`), check.message, refs);\n          break;\n\n        case 'datetime':\n          addFormat(res, 'date-time', check.message, refs);\n          break;\n        case 'date':\n          addFormat(res, 'date', check.message, refs);\n          break;\n        case 'time':\n          addFormat(res, 'time', check.message, refs);\n          break;\n        case 'duration':\n          addFormat(res, 'duration', check.message, refs);\n          break;\n        case 'length':\n          setResponseValueAndErrors(\n            res,\n            'minLength',\n            typeof res.minLength === 'number' ? Math.max(res.minLength, check.value) : check.value,\n            check.message,\n            refs,\n          );\n          setResponseValueAndErrors(\n            res,\n            'maxLength',\n            typeof res.maxLength === 'number' ? Math.min(res.maxLength, check.value) : check.value,\n            check.message,\n            refs,\n          );\n          break;\n        case 'includes': {\n          addPattern(res, RegExp(processPattern(check.value)), check.message, refs);\n          break;\n        }\n        case 'ip': {\n          if (check.version !== 'v6') {\n            addFormat(res, 'ipv4', check.message, refs);\n          }\n          if (check.version !== 'v4') {\n            addFormat(res, 'ipv6', check.message, refs);\n          }\n          break;\n        }\n        case 'emoji':\n          addPattern(res, zodPatterns.emoji, check.message, refs);\n          break;\n        case 'ulid': {\n          addPattern(res, zodPatterns.ulid, check.message, refs);\n          break;\n        }\n        case 'base64': {\n          switch (refs.base64Strategy) {\n            case 'format:binary': {\n              addFormat(res, 'binary' as any, check.message, refs);\n              break;\n            }\n\n            case 'contentEncoding:base64': {\n              setResponseValueAndErrors(res, 'contentEncoding', 'base64', check.message, refs);\n              break;\n            }\n\n            case 'pattern:zod': {\n              addPattern(res, zodPatterns.base64, check.message, refs);\n              break;\n            }\n          }\n          break;\n        }\n        case 'nanoid': {\n          addPattern(res, zodPatterns.nanoid, check.message, refs);\n        }\n        case 'toLowerCase':\n        case 'toUpperCase':\n        case 'trim':\n          break;\n        default:\n          ((_: never) => {})(check);\n      }\n    }\n  }\n\n  return res;\n}\n\nconst escapeNonAlphaNumeric = (value: string) =>\n  Array.from(value)\n    .map((c) => (/[a-zA-Z0-9]/.test(c) ? c : `\\\\${c}`))\n    .join('');\n\nconst addFormat = (\n  schema: JsonSchema7StringType,\n  value: Required<JsonSchema7StringType>['format'],\n  message: string | undefined,\n  refs: Refs,\n) => {\n  if (schema.format || schema.anyOf?.some((x) => x.format)) {\n    if (!schema.anyOf) {\n      schema.anyOf = [];\n    }\n\n    if (schema.format) {\n      schema.anyOf!.push({\n        format: schema.format,\n        ...(schema.errorMessage &&\n          refs.errorMessages && {\n            errorMessage: { format: schema.errorMessage.format },\n          }),\n      });\n      delete schema.format;\n      if (schema.errorMessage) {\n        delete schema.errorMessage.format;\n        if (Object.keys(schema.errorMessage).length === 0) {\n          delete schema.errorMessage;\n        }\n      }\n    }\n\n    schema.anyOf!.push({\n      format: value,\n      ...(message && refs.errorMessages && { errorMessage: { format: message } }),\n    });\n  } else {\n    setResponseValueAndErrors(schema, 'format', value, message, refs);\n  }\n};\n\nconst addPattern = (\n  schema: JsonSchema7StringType,\n  regex: RegExp | (() => RegExp),\n  message: string | undefined,\n  refs: Refs,\n) => {\n  if (schema.pattern || schema.allOf?.some((x) => x.pattern)) {\n    if (!schema.allOf) {\n      schema.allOf = [];\n    }\n\n    if (schema.pattern) {\n      schema.allOf!.push({\n        pattern: schema.pattern,\n        ...(schema.errorMessage &&\n          refs.errorMessages && {\n            errorMessage: { pattern: schema.errorMessage.pattern },\n          }),\n      });\n      delete schema.pattern;\n      if (schema.errorMessage) {\n        delete schema.errorMessage.pattern;\n        if (Object.keys(schema.errorMessage).length === 0) {\n          delete schema.errorMessage;\n        }\n      }\n    }\n\n    schema.allOf!.push({\n      pattern: processRegExp(regex, refs),\n      ...(message && refs.errorMessages && { errorMessage: { pattern: message } }),\n    });\n  } else {\n    setResponseValueAndErrors(schema, 'pattern', processRegExp(regex, refs), message, refs);\n  }\n};\n\n// Mutate z.string.regex() in a best attempt to accommodate for regex flags when applyRegexFlags is true\nconst processRegExp = (regexOrFunction: RegExp | (() => RegExp), refs: Refs): string => {\n  const regex = typeof regexOrFunction === 'function' ? regexOrFunction() : regexOrFunction;\n  if (!refs.applyRegexFlags || !regex.flags) return regex.source;\n\n  // Currently handled flags\n  const flags = {\n    i: regex.flags.includes('i'), // Case-insensitive\n    m: regex.flags.includes('m'), // `^` and `$` matches adjacent to newline characters\n    s: regex.flags.includes('s'), // `.` matches newlines\n  };\n\n  // The general principle here is to step through each character, one at a time, applying mutations as flags require. We keep track when the current character is escaped, and when it's inside a group /like [this]/ or (also) a range like /[a-z]/. The following is fairly brittle imperative code; edit at your peril!\n\n  const source = flags.i ? regex.source.toLowerCase() : regex.source;\n  let pattern = '';\n  let isEscaped = false;\n  let inCharGroup = false;\n  let inCharRange = false;\n\n  for (let i = 0; i < source.length; i++) {\n    if (isEscaped) {\n      pattern += source[i];\n      isEscaped = false;\n      continue;\n    }\n\n    if (flags.i) {\n      if (inCharGroup) {\n        if (source[i].match(/[a-z]/)) {\n          if (inCharRange) {\n            pattern += source[i];\n            pattern += `${source[i - 2]}-${source[i]}`.toUpperCase();\n            inCharRange = false;\n          } else if (source[i + 1] === '-' && source[i + 2]?.match(/[a-z]/)) {\n            pattern += source[i];\n            inCharRange = true;\n          } else {\n            pattern += `${source[i]}${source[i].toUpperCase()}`;\n          }\n          continue;\n        }\n      } else if (source[i].match(/[a-z]/)) {\n        pattern += `[${source[i]}${source[i].toUpperCase()}]`;\n        continue;\n      }\n    }\n\n    if (flags.m) {\n      if (source[i] === '^') {\n        pattern += `(^|(?<=[\\r\\n]))`;\n        continue;\n      } else if (source[i] === '$') {\n        pattern += `($|(?=[\\r\\n]))`;\n        continue;\n      }\n    }\n\n    if (flags.s && source[i] === '.') {\n      pattern += inCharGroup ? `${source[i]}\\r\\n` : `[${source[i]}\\r\\n]`;\n      continue;\n    }\n\n    pattern += source[i];\n    if (source[i] === '\\\\') {\n      isEscaped = true;\n    } else if (inCharGroup && source[i] === ']') {\n      inCharGroup = false;\n    } else if (!inCharGroup && source[i] === '[') {\n      inCharGroup = true;\n    }\n  }\n\n  try {\n    const regexTest = new RegExp(pattern);\n  } catch {\n    console.warn(\n      `Could not convert regex pattern at ${refs.currentPath.join(\n        '/',\n      )} to a flag-independent form! Falling back to the flag-ignorant source`,\n    );\n    return regex.source;\n  }\n\n  return pattern;\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}