{"ast":null,"code":"// Default generic \"any\" values are for backwards compatibility.\n// Replace with \"string\" when we are comfortable with a breaking change.\nimport { BaseStringPromptTemplate } from \"./string.js\";\nimport { checkValidTemplate, parseTemplate, renderTemplate } from \"./template.js\";\n/**\n * Schema to represent a basic prompt for an LLM.\n * @augments BasePromptTemplate\n * @augments PromptTemplateInput\n *\n * @example\n * ```ts\n * import { PromptTemplate } from \"langchain/prompts\";\n *\n * const prompt = new PromptTemplate({\n *   inputVariables: [\"foo\"],\n *   template: \"Say {foo}\",\n * });\n * ```\n */\nexport class PromptTemplate extends BaseStringPromptTemplate {\n  static lc_name() {\n    return \"PromptTemplate\";\n  }\n  constructor(input) {\n    super(input);\n    Object.defineProperty(this, \"template\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, \"templateFormat\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: \"f-string\"\n    });\n    Object.defineProperty(this, \"validateTemplate\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: true\n    });\n    /**\n     * Additional fields which should be included inside\n     * the message content array if using a complex message\n     * content.\n     */\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    Object.defineProperty(this, \"additionalContentFields\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    // If input is mustache and validateTemplate is not defined, set it to false\n    if (input.templateFormat === \"mustache\" && input.validateTemplate === undefined) {\n      this.validateTemplate = false;\n    }\n    Object.assign(this, input);\n    if (this.validateTemplate) {\n      if (this.templateFormat === \"mustache\") {\n        throw new Error(\"Mustache templates cannot be validated.\");\n      }\n      let totalInputVariables = this.inputVariables;\n      if (this.partialVariables) {\n        totalInputVariables = totalInputVariables.concat(Object.keys(this.partialVariables));\n      }\n      checkValidTemplate(this.template, this.templateFormat, totalInputVariables);\n    }\n  }\n  _getPromptType() {\n    return \"prompt\";\n  }\n  /**\n   * Formats the prompt template with the provided values.\n   * @param values The values to be used to format the prompt template.\n   * @returns A promise that resolves to a string which is the formatted prompt.\n   */\n  async format(values) {\n    const allValues = await this.mergePartialAndUserVariables(values);\n    return renderTemplate(this.template, this.templateFormat, allValues);\n  }\n  /**\n   * Take examples in list format with prefix and suffix to create a prompt.\n   *\n   * Intended to be used a a way to dynamically create a prompt from examples.\n   *\n   * @param examples - List of examples to use in the prompt.\n   * @param suffix - String to go after the list of examples. Should generally set up the user's input.\n   * @param inputVariables - A list of variable names the final prompt template will expect\n   * @param exampleSeparator - The separator to use in between examples\n   * @param prefix - String that should go before any examples. Generally includes examples.\n   *\n   * @returns The final prompt template generated.\n   */\n  static fromExamples(examples, suffix, inputVariables, exampleSeparator = \"\\n\\n\", prefix = \"\") {\n    const template = [prefix, ...examples, suffix].join(exampleSeparator);\n    return new PromptTemplate({\n      inputVariables,\n      template\n    });\n  }\n  static fromTemplate(template, options) {\n    const {\n      templateFormat = \"f-string\",\n      ...rest\n    } = options ?? {};\n    const names = new Set();\n    parseTemplate(template, templateFormat).forEach(node => {\n      if (node.type === \"variable\") {\n        names.add(node.name);\n      }\n    });\n    return new PromptTemplate({\n      // Rely on extracted types\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      inputVariables: [...names],\n      templateFormat,\n      template,\n      ...rest\n    });\n  }\n  /**\n   * Partially applies values to the prompt template.\n   * @param values The values to be partially applied to the prompt template.\n   * @returns A new instance of PromptTemplate with the partially applied values.\n   */\n  async partial(values) {\n    const newInputVariables = this.inputVariables.filter(iv => !(iv in values));\n    const newPartialVariables = {\n      ...(this.partialVariables ?? {}),\n      ...values\n    };\n    const promptDict = {\n      ...this,\n      inputVariables: newInputVariables,\n      partialVariables: newPartialVariables\n    };\n    return new PromptTemplate(promptDict);\n  }\n  serialize() {\n    if (this.outputParser !== undefined) {\n      throw new Error(\"Cannot serialize a prompt template with an output parser\");\n    }\n    return {\n      _type: this._getPromptType(),\n      input_variables: this.inputVariables,\n      template: this.template,\n      template_format: this.templateFormat\n    };\n  }\n  static async deserialize(data) {\n    if (!data.template) {\n      throw new Error(\"Prompt template must have a template\");\n    }\n    const res = new PromptTemplate({\n      inputVariables: data.input_variables,\n      template: data.template,\n      templateFormat: data.template_format\n    });\n    return res;\n  }\n}","map":{"version":3,"names":["BaseStringPromptTemplate","checkValidTemplate","parseTemplate","renderTemplate","PromptTemplate","lc_name","constructor","input","Object","defineProperty","enumerable","configurable","writable","value","templateFormat","validateTemplate","undefined","assign","Error","totalInputVariables","inputVariables","partialVariables","concat","keys","template","_getPromptType","format","values","allValues","mergePartialAndUserVariables","fromExamples","examples","suffix","exampleSeparator","prefix","join","fromTemplate","options","rest","names","Set","forEach","node","type","add","name","partial","newInputVariables","filter","iv","newPartialVariables","promptDict","serialize","outputParser","_type","input_variables","template_format","deserialize","data","res"],"sources":["/Users/youngchen/Downloads/cs224g-triage/node_modules/@langchain/core/dist/prompts/prompt.js"],"sourcesContent":["// Default generic \"any\" values are for backwards compatibility.\n// Replace with \"string\" when we are comfortable with a breaking change.\nimport { BaseStringPromptTemplate } from \"./string.js\";\nimport { checkValidTemplate, parseTemplate, renderTemplate, } from \"./template.js\";\n/**\n * Schema to represent a basic prompt for an LLM.\n * @augments BasePromptTemplate\n * @augments PromptTemplateInput\n *\n * @example\n * ```ts\n * import { PromptTemplate } from \"langchain/prompts\";\n *\n * const prompt = new PromptTemplate({\n *   inputVariables: [\"foo\"],\n *   template: \"Say {foo}\",\n * });\n * ```\n */\nexport class PromptTemplate extends BaseStringPromptTemplate {\n    static lc_name() {\n        return \"PromptTemplate\";\n    }\n    constructor(input) {\n        super(input);\n        Object.defineProperty(this, \"template\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"templateFormat\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: \"f-string\"\n        });\n        Object.defineProperty(this, \"validateTemplate\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: true\n        });\n        /**\n         * Additional fields which should be included inside\n         * the message content array if using a complex message\n         * content.\n         */\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        Object.defineProperty(this, \"additionalContentFields\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        // If input is mustache and validateTemplate is not defined, set it to false\n        if (input.templateFormat === \"mustache\" &&\n            input.validateTemplate === undefined) {\n            this.validateTemplate = false;\n        }\n        Object.assign(this, input);\n        if (this.validateTemplate) {\n            if (this.templateFormat === \"mustache\") {\n                throw new Error(\"Mustache templates cannot be validated.\");\n            }\n            let totalInputVariables = this.inputVariables;\n            if (this.partialVariables) {\n                totalInputVariables = totalInputVariables.concat(Object.keys(this.partialVariables));\n            }\n            checkValidTemplate(this.template, this.templateFormat, totalInputVariables);\n        }\n    }\n    _getPromptType() {\n        return \"prompt\";\n    }\n    /**\n     * Formats the prompt template with the provided values.\n     * @param values The values to be used to format the prompt template.\n     * @returns A promise that resolves to a string which is the formatted prompt.\n     */\n    async format(values) {\n        const allValues = await this.mergePartialAndUserVariables(values);\n        return renderTemplate(this.template, this.templateFormat, allValues);\n    }\n    /**\n     * Take examples in list format with prefix and suffix to create a prompt.\n     *\n     * Intended to be used a a way to dynamically create a prompt from examples.\n     *\n     * @param examples - List of examples to use in the prompt.\n     * @param suffix - String to go after the list of examples. Should generally set up the user's input.\n     * @param inputVariables - A list of variable names the final prompt template will expect\n     * @param exampleSeparator - The separator to use in between examples\n     * @param prefix - String that should go before any examples. Generally includes examples.\n     *\n     * @returns The final prompt template generated.\n     */\n    static fromExamples(examples, suffix, inputVariables, exampleSeparator = \"\\n\\n\", prefix = \"\") {\n        const template = [prefix, ...examples, suffix].join(exampleSeparator);\n        return new PromptTemplate({\n            inputVariables,\n            template,\n        });\n    }\n    static fromTemplate(template, options) {\n        const { templateFormat = \"f-string\", ...rest } = options ?? {};\n        const names = new Set();\n        parseTemplate(template, templateFormat).forEach((node) => {\n            if (node.type === \"variable\") {\n                names.add(node.name);\n            }\n        });\n        return new PromptTemplate({\n            // Rely on extracted types\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n            inputVariables: [...names],\n            templateFormat,\n            template,\n            ...rest,\n        });\n    }\n    /**\n     * Partially applies values to the prompt template.\n     * @param values The values to be partially applied to the prompt template.\n     * @returns A new instance of PromptTemplate with the partially applied values.\n     */\n    async partial(values) {\n        const newInputVariables = this.inputVariables.filter((iv) => !(iv in values));\n        const newPartialVariables = {\n            ...(this.partialVariables ?? {}),\n            ...values,\n        };\n        const promptDict = {\n            ...this,\n            inputVariables: newInputVariables,\n            partialVariables: newPartialVariables,\n        };\n        return new PromptTemplate(promptDict);\n    }\n    serialize() {\n        if (this.outputParser !== undefined) {\n            throw new Error(\"Cannot serialize a prompt template with an output parser\");\n        }\n        return {\n            _type: this._getPromptType(),\n            input_variables: this.inputVariables,\n            template: this.template,\n            template_format: this.templateFormat,\n        };\n    }\n    static async deserialize(data) {\n        if (!data.template) {\n            throw new Error(\"Prompt template must have a template\");\n        }\n        const res = new PromptTemplate({\n            inputVariables: data.input_variables,\n            template: data.template,\n            templateFormat: data.template_format,\n        });\n        return res;\n    }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}