{"ast":null,"code":"import { BaseTracer } from \"./base.js\";\nimport { IterableReadableStream } from \"../utils/stream.js\";\nimport { AIMessageChunk } from \"../messages/ai.js\";\nimport { GenerationChunk } from \"../outputs.js\";\nfunction assignName({\n  name,\n  serialized\n}) {\n  if (name !== undefined) {\n    return name;\n  }\n  if (serialized?.name !== undefined) {\n    return serialized.name;\n  } else if (serialized?.id !== undefined && Array.isArray(serialized?.id)) {\n    return serialized.id[serialized.id.length - 1];\n  }\n  return \"Unnamed\";\n}\nexport const isStreamEventsHandler = handler => handler.name === \"event_stream_tracer\";\n/**\n * Class that extends the `BaseTracer` class from the\n * `langchain.callbacks.tracers.base` module. It represents a callback\n * handler that logs the execution of runs and emits `RunLog` instances to a\n * `RunLogStream`.\n */\nexport class EventStreamCallbackHandler extends BaseTracer {\n  constructor(fields) {\n    super({\n      _awaitHandler: true,\n      ...fields\n    });\n    Object.defineProperty(this, \"autoClose\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: true\n    });\n    Object.defineProperty(this, \"includeNames\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, \"includeTypes\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, \"includeTags\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, \"excludeNames\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, \"excludeTypes\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, \"excludeTags\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, \"runInfoMap\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: new Map()\n    });\n    Object.defineProperty(this, \"tappedPromises\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: new Map()\n    });\n    Object.defineProperty(this, \"transformStream\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, \"writer\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, \"receiveStream\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, \"name\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: \"event_stream_tracer\"\n    });\n    Object.defineProperty(this, \"lc_prefer_streaming\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: true\n    });\n    this.autoClose = fields?.autoClose ?? true;\n    this.includeNames = fields?.includeNames;\n    this.includeTypes = fields?.includeTypes;\n    this.includeTags = fields?.includeTags;\n    this.excludeNames = fields?.excludeNames;\n    this.excludeTypes = fields?.excludeTypes;\n    this.excludeTags = fields?.excludeTags;\n    this.transformStream = new TransformStream();\n    this.writer = this.transformStream.writable.getWriter();\n    this.receiveStream = IterableReadableStream.fromReadableStream(this.transformStream.readable);\n  }\n  [Symbol.asyncIterator]() {\n    return this.receiveStream;\n  }\n  async persistRun(_run) {\n    // This is a legacy method only called once for an entire run tree\n    // and is therefore not useful here\n  }\n  _includeRun(run) {\n    const runTags = run.tags ?? [];\n    let include = this.includeNames === undefined && this.includeTags === undefined && this.includeTypes === undefined;\n    if (this.includeNames !== undefined) {\n      include = include || this.includeNames.includes(run.name);\n    }\n    if (this.includeTypes !== undefined) {\n      include = include || this.includeTypes.includes(run.runType);\n    }\n    if (this.includeTags !== undefined) {\n      include = include || runTags.find(tag => this.includeTags?.includes(tag)) !== undefined;\n    }\n    if (this.excludeNames !== undefined) {\n      include = include && !this.excludeNames.includes(run.name);\n    }\n    if (this.excludeTypes !== undefined) {\n      include = include && !this.excludeTypes.includes(run.runType);\n    }\n    if (this.excludeTags !== undefined) {\n      include = include && runTags.every(tag => !this.excludeTags?.includes(tag));\n    }\n    return include;\n  }\n  async *tapOutputIterable(runId, outputStream) {\n    const firstChunk = await outputStream.next();\n    if (firstChunk.done) {\n      return;\n    }\n    const runInfo = this.runInfoMap.get(runId);\n    // Run has finished, don't issue any stream events.\n    // An example of this is for runnables that use the default\n    // implementation of .stream(), which delegates to .invoke()\n    // and calls .onChainEnd() before passing it to the iterator.\n    if (runInfo === undefined) {\n      yield firstChunk.value;\n      return;\n    }\n    // Match format from handlers below\n    function _formatOutputChunk(eventType, data) {\n      if (eventType === \"llm\" && typeof data === \"string\") {\n        return new GenerationChunk({\n          text: data\n        });\n      }\n      return data;\n    }\n    let tappedPromise = this.tappedPromises.get(runId);\n    // if we are the first to tap, issue stream events\n    if (tappedPromise === undefined) {\n      let tappedPromiseResolver;\n      tappedPromise = new Promise(resolve => {\n        tappedPromiseResolver = resolve;\n      });\n      this.tappedPromises.set(runId, tappedPromise);\n      try {\n        const event = {\n          event: `on_${runInfo.runType}_stream`,\n          run_id: runId,\n          name: runInfo.name,\n          tags: runInfo.tags,\n          metadata: runInfo.metadata,\n          data: {}\n        };\n        await this.send({\n          ...event,\n          data: {\n            chunk: _formatOutputChunk(runInfo.runType, firstChunk.value)\n          }\n        }, runInfo);\n        yield firstChunk.value;\n        for await (const chunk of outputStream) {\n          // Don't yield tool and retriever stream events\n          if (runInfo.runType !== \"tool\" && runInfo.runType !== \"retriever\") {\n            await this.send({\n              ...event,\n              data: {\n                chunk: _formatOutputChunk(runInfo.runType, chunk)\n              }\n            }, runInfo);\n          }\n          yield chunk;\n        }\n      } finally {\n        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n        tappedPromiseResolver();\n        // Don't delete from the promises map to keep track of which runs have been tapped.\n      }\n    } else {\n      // otherwise just pass through\n      yield firstChunk.value;\n      for await (const chunk of outputStream) {\n        yield chunk;\n      }\n    }\n  }\n  async send(payload, run) {\n    if (this._includeRun(run)) {\n      await this.writer.write(payload);\n    }\n  }\n  async sendEndEvent(payload, run) {\n    const tappedPromise = this.tappedPromises.get(payload.run_id);\n    if (tappedPromise !== undefined) {\n      void tappedPromise.then(() => {\n        void this.send(payload, run);\n      });\n    } else {\n      await this.send(payload, run);\n    }\n  }\n  async onLLMStart(run) {\n    const runName = assignName(run);\n    const runType = run.inputs.messages !== undefined ? \"chat_model\" : \"llm\";\n    const runInfo = {\n      tags: run.tags ?? [],\n      metadata: run.extra?.metadata ?? {},\n      name: runName,\n      runType,\n      inputs: run.inputs\n    };\n    this.runInfoMap.set(run.id, runInfo);\n    const eventName = `on_${runType}_start`;\n    await this.send({\n      event: eventName,\n      data: {\n        input: run.inputs\n      },\n      name: runName,\n      tags: run.tags ?? [],\n      run_id: run.id,\n      metadata: run.extra?.metadata ?? {}\n    }, runInfo);\n  }\n  async onLLMNewToken(run, token,\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  kwargs) {\n    const runInfo = this.runInfoMap.get(run.id);\n    let chunk;\n    let eventName;\n    if (runInfo === undefined) {\n      throw new Error(`onLLMNewToken: Run ID ${run.id} not found in run map.`);\n    }\n    // Top-level streaming events are covered by tapOutputIterable\n    if (this.runInfoMap.size === 1) {\n      return;\n    }\n    if (runInfo.runType === \"chat_model\") {\n      eventName = \"on_chat_model_stream\";\n      if (kwargs?.chunk === undefined) {\n        chunk = new AIMessageChunk({\n          content: token,\n          id: `run-${run.id}`\n        });\n      } else {\n        chunk = kwargs.chunk.message;\n      }\n    } else if (runInfo.runType === \"llm\") {\n      eventName = \"on_llm_stream\";\n      if (kwargs?.chunk === undefined) {\n        chunk = new GenerationChunk({\n          text: token\n        });\n      } else {\n        chunk = kwargs.chunk;\n      }\n    } else {\n      throw new Error(`Unexpected run type ${runInfo.runType}`);\n    }\n    await this.send({\n      event: eventName,\n      data: {\n        chunk\n      },\n      run_id: run.id,\n      name: runInfo.name,\n      tags: runInfo.tags,\n      metadata: runInfo.metadata\n    }, runInfo);\n  }\n  async onLLMEnd(run) {\n    const runInfo = this.runInfoMap.get(run.id);\n    this.runInfoMap.delete(run.id);\n    let eventName;\n    if (runInfo === undefined) {\n      throw new Error(`onLLMEnd: Run ID ${run.id} not found in run map.`);\n    }\n    const generations = run.outputs?.generations;\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    let output;\n    if (runInfo.runType === \"chat_model\") {\n      for (const generation of generations ?? []) {\n        if (output !== undefined) {\n          break;\n        }\n        output = generation[0]?.message;\n      }\n      eventName = \"on_chat_model_end\";\n    } else if (runInfo.runType === \"llm\") {\n      output = {\n        generations: generations?.map(generation => {\n          return generation.map(chunk => {\n            return {\n              text: chunk.text,\n              generationInfo: chunk.generationInfo\n            };\n          });\n        }),\n        llmOutput: run.outputs?.llmOutput ?? {}\n      };\n      eventName = \"on_llm_end\";\n    } else {\n      throw new Error(`onLLMEnd: Unexpected run type: ${runInfo.runType}`);\n    }\n    await this.sendEndEvent({\n      event: eventName,\n      data: {\n        output,\n        input: runInfo.inputs\n      },\n      run_id: run.id,\n      name: runInfo.name,\n      tags: runInfo.tags,\n      metadata: runInfo.metadata\n    }, runInfo);\n  }\n  async onChainStart(run) {\n    const runName = assignName(run);\n    const runType = run.run_type ?? \"chain\";\n    const runInfo = {\n      tags: run.tags ?? [],\n      metadata: run.extra?.metadata ?? {},\n      name: runName,\n      runType: run.run_type\n    };\n    let eventData = {};\n    // Workaround Runnable core code not sending input when transform streaming.\n    if (run.inputs.input === \"\" && Object.keys(run.inputs).length === 1) {\n      eventData = {};\n      runInfo.inputs = {};\n    } else if (run.inputs.input !== undefined) {\n      eventData.input = run.inputs.input;\n      runInfo.inputs = run.inputs.input;\n    } else {\n      eventData.input = run.inputs;\n      runInfo.inputs = run.inputs;\n    }\n    this.runInfoMap.set(run.id, runInfo);\n    await this.send({\n      event: `on_${runType}_start`,\n      data: eventData,\n      name: runName,\n      tags: run.tags ?? [],\n      run_id: run.id,\n      metadata: run.extra?.metadata ?? {}\n    }, runInfo);\n  }\n  async onChainEnd(run) {\n    const runInfo = this.runInfoMap.get(run.id);\n    this.runInfoMap.delete(run.id);\n    if (runInfo === undefined) {\n      throw new Error(`onChainEnd: Run ID ${run.id} not found in run map.`);\n    }\n    const eventName = `on_${run.run_type}_end`;\n    const inputs = run.inputs ?? runInfo.inputs ?? {};\n    const outputs = run.outputs?.output ?? run.outputs;\n    const data = {\n      output: outputs,\n      input: inputs\n    };\n    if (inputs.input && Object.keys(inputs).length === 1) {\n      data.input = inputs.input;\n      runInfo.inputs = inputs.input;\n    }\n    await this.sendEndEvent({\n      event: eventName,\n      data,\n      run_id: run.id,\n      name: runInfo.name,\n      tags: runInfo.tags,\n      metadata: runInfo.metadata ?? {}\n    }, runInfo);\n  }\n  async onToolStart(run) {\n    const runName = assignName(run);\n    const runInfo = {\n      tags: run.tags ?? [],\n      metadata: run.extra?.metadata ?? {},\n      name: runName,\n      runType: \"tool\",\n      inputs: run.inputs ?? {}\n    };\n    this.runInfoMap.set(run.id, runInfo);\n    await this.send({\n      event: \"on_tool_start\",\n      data: {\n        input: run.inputs ?? {}\n      },\n      name: runName,\n      run_id: run.id,\n      tags: run.tags ?? [],\n      metadata: run.extra?.metadata ?? {}\n    }, runInfo);\n  }\n  async onToolEnd(run) {\n    const runInfo = this.runInfoMap.get(run.id);\n    this.runInfoMap.delete(run.id);\n    if (runInfo === undefined) {\n      throw new Error(`onToolEnd: Run ID ${run.id} not found in run map.`);\n    }\n    if (runInfo.inputs === undefined) {\n      throw new Error(`onToolEnd: Run ID ${run.id} is a tool call, and is expected to have traced inputs.`);\n    }\n    const output = run.outputs?.output === undefined ? run.outputs : run.outputs.output;\n    await this.sendEndEvent({\n      event: \"on_tool_end\",\n      data: {\n        output,\n        input: runInfo.inputs\n      },\n      run_id: run.id,\n      name: runInfo.name,\n      tags: runInfo.tags,\n      metadata: runInfo.metadata\n    }, runInfo);\n  }\n  async onRetrieverStart(run) {\n    const runName = assignName(run);\n    const runType = \"retriever\";\n    const runInfo = {\n      tags: run.tags ?? [],\n      metadata: run.extra?.metadata ?? {},\n      name: runName,\n      runType,\n      inputs: {\n        query: run.inputs.query\n      }\n    };\n    this.runInfoMap.set(run.id, runInfo);\n    await this.send({\n      event: \"on_retriever_start\",\n      data: {\n        input: {\n          query: run.inputs.query\n        }\n      },\n      name: runName,\n      tags: run.tags ?? [],\n      run_id: run.id,\n      metadata: run.extra?.metadata ?? {}\n    }, runInfo);\n  }\n  async onRetrieverEnd(run) {\n    const runInfo = this.runInfoMap.get(run.id);\n    this.runInfoMap.delete(run.id);\n    if (runInfo === undefined) {\n      throw new Error(`onRetrieverEnd: Run ID ${run.id} not found in run map.`);\n    }\n    await this.sendEndEvent({\n      event: \"on_retriever_end\",\n      data: {\n        output: run.outputs?.documents ?? run.outputs,\n        input: runInfo.inputs\n      },\n      run_id: run.id,\n      name: runInfo.name,\n      tags: runInfo.tags,\n      metadata: runInfo.metadata\n    }, runInfo);\n  }\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  async handleCustomEvent(eventName, data, runId) {\n    const runInfo = this.runInfoMap.get(runId);\n    if (runInfo === undefined) {\n      throw new Error(`handleCustomEvent: Run ID ${runId} not found in run map.`);\n    }\n    await this.send({\n      event: \"on_custom_event\",\n      run_id: runId,\n      name: eventName,\n      tags: runInfo.tags,\n      metadata: runInfo.metadata,\n      data\n    }, runInfo);\n  }\n  async finish() {\n    const pendingPromises = [...this.tappedPromises.values()];\n    void Promise.all(pendingPromises).finally(() => {\n      void this.writer.close();\n    });\n  }\n}","map":{"version":3,"names":["BaseTracer","IterableReadableStream","AIMessageChunk","GenerationChunk","assignName","name","serialized","undefined","id","Array","isArray","length","isStreamEventsHandler","handler","EventStreamCallbackHandler","constructor","fields","_awaitHandler","Object","defineProperty","enumerable","configurable","writable","value","Map","autoClose","includeNames","includeTypes","includeTags","excludeNames","excludeTypes","excludeTags","transformStream","TransformStream","writer","getWriter","receiveStream","fromReadableStream","readable","Symbol","asyncIterator","persistRun","_run","_includeRun","run","runTags","tags","include","includes","runType","find","tag","every","tapOutputIterable","runId","outputStream","firstChunk","next","done","runInfo","runInfoMap","get","_formatOutputChunk","eventType","data","text","tappedPromise","tappedPromises","tappedPromiseResolver","Promise","resolve","set","event","run_id","metadata","send","chunk","payload","write","sendEndEvent","then","onLLMStart","runName","inputs","messages","extra","eventName","input","onLLMNewToken","token","kwargs","Error","size","content","message","onLLMEnd","delete","generations","outputs","output","generation","map","generationInfo","llmOutput","onChainStart","run_type","eventData","keys","onChainEnd","onToolStart","onToolEnd","onRetrieverStart","query","onRetrieverEnd","documents","handleCustomEvent","finish","pendingPromises","values","all","finally","close"],"sources":["/Users/youngchen/Downloads/cs224g-triage/node_modules/@langchain/core/dist/tracers/event_stream.js"],"sourcesContent":["import { BaseTracer } from \"./base.js\";\nimport { IterableReadableStream } from \"../utils/stream.js\";\nimport { AIMessageChunk } from \"../messages/ai.js\";\nimport { GenerationChunk } from \"../outputs.js\";\nfunction assignName({ name, serialized, }) {\n    if (name !== undefined) {\n        return name;\n    }\n    if (serialized?.name !== undefined) {\n        return serialized.name;\n    }\n    else if (serialized?.id !== undefined && Array.isArray(serialized?.id)) {\n        return serialized.id[serialized.id.length - 1];\n    }\n    return \"Unnamed\";\n}\nexport const isStreamEventsHandler = (handler) => handler.name === \"event_stream_tracer\";\n/**\n * Class that extends the `BaseTracer` class from the\n * `langchain.callbacks.tracers.base` module. It represents a callback\n * handler that logs the execution of runs and emits `RunLog` instances to a\n * `RunLogStream`.\n */\nexport class EventStreamCallbackHandler extends BaseTracer {\n    constructor(fields) {\n        super({ _awaitHandler: true, ...fields });\n        Object.defineProperty(this, \"autoClose\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: true\n        });\n        Object.defineProperty(this, \"includeNames\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"includeTypes\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"includeTags\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"excludeNames\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"excludeTypes\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"excludeTags\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"runInfoMap\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: new Map()\n        });\n        Object.defineProperty(this, \"tappedPromises\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: new Map()\n        });\n        Object.defineProperty(this, \"transformStream\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"writer\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"receiveStream\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: \"event_stream_tracer\"\n        });\n        Object.defineProperty(this, \"lc_prefer_streaming\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: true\n        });\n        this.autoClose = fields?.autoClose ?? true;\n        this.includeNames = fields?.includeNames;\n        this.includeTypes = fields?.includeTypes;\n        this.includeTags = fields?.includeTags;\n        this.excludeNames = fields?.excludeNames;\n        this.excludeTypes = fields?.excludeTypes;\n        this.excludeTags = fields?.excludeTags;\n        this.transformStream = new TransformStream();\n        this.writer = this.transformStream.writable.getWriter();\n        this.receiveStream = IterableReadableStream.fromReadableStream(this.transformStream.readable);\n    }\n    [Symbol.asyncIterator]() {\n        return this.receiveStream;\n    }\n    async persistRun(_run) {\n        // This is a legacy method only called once for an entire run tree\n        // and is therefore not useful here\n    }\n    _includeRun(run) {\n        const runTags = run.tags ?? [];\n        let include = this.includeNames === undefined &&\n            this.includeTags === undefined &&\n            this.includeTypes === undefined;\n        if (this.includeNames !== undefined) {\n            include = include || this.includeNames.includes(run.name);\n        }\n        if (this.includeTypes !== undefined) {\n            include = include || this.includeTypes.includes(run.runType);\n        }\n        if (this.includeTags !== undefined) {\n            include =\n                include ||\n                    runTags.find((tag) => this.includeTags?.includes(tag)) !== undefined;\n        }\n        if (this.excludeNames !== undefined) {\n            include = include && !this.excludeNames.includes(run.name);\n        }\n        if (this.excludeTypes !== undefined) {\n            include = include && !this.excludeTypes.includes(run.runType);\n        }\n        if (this.excludeTags !== undefined) {\n            include =\n                include && runTags.every((tag) => !this.excludeTags?.includes(tag));\n        }\n        return include;\n    }\n    async *tapOutputIterable(runId, outputStream) {\n        const firstChunk = await outputStream.next();\n        if (firstChunk.done) {\n            return;\n        }\n        const runInfo = this.runInfoMap.get(runId);\n        // Run has finished, don't issue any stream events.\n        // An example of this is for runnables that use the default\n        // implementation of .stream(), which delegates to .invoke()\n        // and calls .onChainEnd() before passing it to the iterator.\n        if (runInfo === undefined) {\n            yield firstChunk.value;\n            return;\n        }\n        // Match format from handlers below\n        function _formatOutputChunk(eventType, data) {\n            if (eventType === \"llm\" && typeof data === \"string\") {\n                return new GenerationChunk({ text: data });\n            }\n            return data;\n        }\n        let tappedPromise = this.tappedPromises.get(runId);\n        // if we are the first to tap, issue stream events\n        if (tappedPromise === undefined) {\n            let tappedPromiseResolver;\n            tappedPromise = new Promise((resolve) => {\n                tappedPromiseResolver = resolve;\n            });\n            this.tappedPromises.set(runId, tappedPromise);\n            try {\n                const event = {\n                    event: `on_${runInfo.runType}_stream`,\n                    run_id: runId,\n                    name: runInfo.name,\n                    tags: runInfo.tags,\n                    metadata: runInfo.metadata,\n                    data: {},\n                };\n                await this.send({\n                    ...event,\n                    data: {\n                        chunk: _formatOutputChunk(runInfo.runType, firstChunk.value),\n                    },\n                }, runInfo);\n                yield firstChunk.value;\n                for await (const chunk of outputStream) {\n                    // Don't yield tool and retriever stream events\n                    if (runInfo.runType !== \"tool\" && runInfo.runType !== \"retriever\") {\n                        await this.send({\n                            ...event,\n                            data: {\n                                chunk: _formatOutputChunk(runInfo.runType, chunk),\n                            },\n                        }, runInfo);\n                    }\n                    yield chunk;\n                }\n            }\n            finally {\n                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n                tappedPromiseResolver();\n                // Don't delete from the promises map to keep track of which runs have been tapped.\n            }\n        }\n        else {\n            // otherwise just pass through\n            yield firstChunk.value;\n            for await (const chunk of outputStream) {\n                yield chunk;\n            }\n        }\n    }\n    async send(payload, run) {\n        if (this._includeRun(run)) {\n            await this.writer.write(payload);\n        }\n    }\n    async sendEndEvent(payload, run) {\n        const tappedPromise = this.tappedPromises.get(payload.run_id);\n        if (tappedPromise !== undefined) {\n            void tappedPromise.then(() => {\n                void this.send(payload, run);\n            });\n        }\n        else {\n            await this.send(payload, run);\n        }\n    }\n    async onLLMStart(run) {\n        const runName = assignName(run);\n        const runType = run.inputs.messages !== undefined ? \"chat_model\" : \"llm\";\n        const runInfo = {\n            tags: run.tags ?? [],\n            metadata: run.extra?.metadata ?? {},\n            name: runName,\n            runType,\n            inputs: run.inputs,\n        };\n        this.runInfoMap.set(run.id, runInfo);\n        const eventName = `on_${runType}_start`;\n        await this.send({\n            event: eventName,\n            data: {\n                input: run.inputs,\n            },\n            name: runName,\n            tags: run.tags ?? [],\n            run_id: run.id,\n            metadata: run.extra?.metadata ?? {},\n        }, runInfo);\n    }\n    async onLLMNewToken(run, token, \n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    kwargs) {\n        const runInfo = this.runInfoMap.get(run.id);\n        let chunk;\n        let eventName;\n        if (runInfo === undefined) {\n            throw new Error(`onLLMNewToken: Run ID ${run.id} not found in run map.`);\n        }\n        // Top-level streaming events are covered by tapOutputIterable\n        if (this.runInfoMap.size === 1) {\n            return;\n        }\n        if (runInfo.runType === \"chat_model\") {\n            eventName = \"on_chat_model_stream\";\n            if (kwargs?.chunk === undefined) {\n                chunk = new AIMessageChunk({ content: token, id: `run-${run.id}` });\n            }\n            else {\n                chunk = kwargs.chunk.message;\n            }\n        }\n        else if (runInfo.runType === \"llm\") {\n            eventName = \"on_llm_stream\";\n            if (kwargs?.chunk === undefined) {\n                chunk = new GenerationChunk({ text: token });\n            }\n            else {\n                chunk = kwargs.chunk;\n            }\n        }\n        else {\n            throw new Error(`Unexpected run type ${runInfo.runType}`);\n        }\n        await this.send({\n            event: eventName,\n            data: {\n                chunk,\n            },\n            run_id: run.id,\n            name: runInfo.name,\n            tags: runInfo.tags,\n            metadata: runInfo.metadata,\n        }, runInfo);\n    }\n    async onLLMEnd(run) {\n        const runInfo = this.runInfoMap.get(run.id);\n        this.runInfoMap.delete(run.id);\n        let eventName;\n        if (runInfo === undefined) {\n            throw new Error(`onLLMEnd: Run ID ${run.id} not found in run map.`);\n        }\n        const generations = run.outputs?.generations;\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        let output;\n        if (runInfo.runType === \"chat_model\") {\n            for (const generation of generations ?? []) {\n                if (output !== undefined) {\n                    break;\n                }\n                output = generation[0]?.message;\n            }\n            eventName = \"on_chat_model_end\";\n        }\n        else if (runInfo.runType === \"llm\") {\n            output = {\n                generations: generations?.map((generation) => {\n                    return generation.map((chunk) => {\n                        return {\n                            text: chunk.text,\n                            generationInfo: chunk.generationInfo,\n                        };\n                    });\n                }),\n                llmOutput: run.outputs?.llmOutput ?? {},\n            };\n            eventName = \"on_llm_end\";\n        }\n        else {\n            throw new Error(`onLLMEnd: Unexpected run type: ${runInfo.runType}`);\n        }\n        await this.sendEndEvent({\n            event: eventName,\n            data: {\n                output,\n                input: runInfo.inputs,\n            },\n            run_id: run.id,\n            name: runInfo.name,\n            tags: runInfo.tags,\n            metadata: runInfo.metadata,\n        }, runInfo);\n    }\n    async onChainStart(run) {\n        const runName = assignName(run);\n        const runType = run.run_type ?? \"chain\";\n        const runInfo = {\n            tags: run.tags ?? [],\n            metadata: run.extra?.metadata ?? {},\n            name: runName,\n            runType: run.run_type,\n        };\n        let eventData = {};\n        // Workaround Runnable core code not sending input when transform streaming.\n        if (run.inputs.input === \"\" && Object.keys(run.inputs).length === 1) {\n            eventData = {};\n            runInfo.inputs = {};\n        }\n        else if (run.inputs.input !== undefined) {\n            eventData.input = run.inputs.input;\n            runInfo.inputs = run.inputs.input;\n        }\n        else {\n            eventData.input = run.inputs;\n            runInfo.inputs = run.inputs;\n        }\n        this.runInfoMap.set(run.id, runInfo);\n        await this.send({\n            event: `on_${runType}_start`,\n            data: eventData,\n            name: runName,\n            tags: run.tags ?? [],\n            run_id: run.id,\n            metadata: run.extra?.metadata ?? {},\n        }, runInfo);\n    }\n    async onChainEnd(run) {\n        const runInfo = this.runInfoMap.get(run.id);\n        this.runInfoMap.delete(run.id);\n        if (runInfo === undefined) {\n            throw new Error(`onChainEnd: Run ID ${run.id} not found in run map.`);\n        }\n        const eventName = `on_${run.run_type}_end`;\n        const inputs = run.inputs ?? runInfo.inputs ?? {};\n        const outputs = run.outputs?.output ?? run.outputs;\n        const data = {\n            output: outputs,\n            input: inputs,\n        };\n        if (inputs.input && Object.keys(inputs).length === 1) {\n            data.input = inputs.input;\n            runInfo.inputs = inputs.input;\n        }\n        await this.sendEndEvent({\n            event: eventName,\n            data,\n            run_id: run.id,\n            name: runInfo.name,\n            tags: runInfo.tags,\n            metadata: runInfo.metadata ?? {},\n        }, runInfo);\n    }\n    async onToolStart(run) {\n        const runName = assignName(run);\n        const runInfo = {\n            tags: run.tags ?? [],\n            metadata: run.extra?.metadata ?? {},\n            name: runName,\n            runType: \"tool\",\n            inputs: run.inputs ?? {},\n        };\n        this.runInfoMap.set(run.id, runInfo);\n        await this.send({\n            event: \"on_tool_start\",\n            data: {\n                input: run.inputs ?? {},\n            },\n            name: runName,\n            run_id: run.id,\n            tags: run.tags ?? [],\n            metadata: run.extra?.metadata ?? {},\n        }, runInfo);\n    }\n    async onToolEnd(run) {\n        const runInfo = this.runInfoMap.get(run.id);\n        this.runInfoMap.delete(run.id);\n        if (runInfo === undefined) {\n            throw new Error(`onToolEnd: Run ID ${run.id} not found in run map.`);\n        }\n        if (runInfo.inputs === undefined) {\n            throw new Error(`onToolEnd: Run ID ${run.id} is a tool call, and is expected to have traced inputs.`);\n        }\n        const output = run.outputs?.output === undefined ? run.outputs : run.outputs.output;\n        await this.sendEndEvent({\n            event: \"on_tool_end\",\n            data: {\n                output,\n                input: runInfo.inputs,\n            },\n            run_id: run.id,\n            name: runInfo.name,\n            tags: runInfo.tags,\n            metadata: runInfo.metadata,\n        }, runInfo);\n    }\n    async onRetrieverStart(run) {\n        const runName = assignName(run);\n        const runType = \"retriever\";\n        const runInfo = {\n            tags: run.tags ?? [],\n            metadata: run.extra?.metadata ?? {},\n            name: runName,\n            runType,\n            inputs: {\n                query: run.inputs.query,\n            },\n        };\n        this.runInfoMap.set(run.id, runInfo);\n        await this.send({\n            event: \"on_retriever_start\",\n            data: {\n                input: {\n                    query: run.inputs.query,\n                },\n            },\n            name: runName,\n            tags: run.tags ?? [],\n            run_id: run.id,\n            metadata: run.extra?.metadata ?? {},\n        }, runInfo);\n    }\n    async onRetrieverEnd(run) {\n        const runInfo = this.runInfoMap.get(run.id);\n        this.runInfoMap.delete(run.id);\n        if (runInfo === undefined) {\n            throw new Error(`onRetrieverEnd: Run ID ${run.id} not found in run map.`);\n        }\n        await this.sendEndEvent({\n            event: \"on_retriever_end\",\n            data: {\n                output: run.outputs?.documents ?? run.outputs,\n                input: runInfo.inputs,\n            },\n            run_id: run.id,\n            name: runInfo.name,\n            tags: runInfo.tags,\n            metadata: runInfo.metadata,\n        }, runInfo);\n    }\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    async handleCustomEvent(eventName, data, runId) {\n        const runInfo = this.runInfoMap.get(runId);\n        if (runInfo === undefined) {\n            throw new Error(`handleCustomEvent: Run ID ${runId} not found in run map.`);\n        }\n        await this.send({\n            event: \"on_custom_event\",\n            run_id: runId,\n            name: eventName,\n            tags: runInfo.tags,\n            metadata: runInfo.metadata,\n            data,\n        }, runInfo);\n    }\n    async finish() {\n        const pendingPromises = [...this.tappedPromises.values()];\n        void Promise.all(pendingPromises).finally(() => {\n            void this.writer.close();\n        });\n    }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}