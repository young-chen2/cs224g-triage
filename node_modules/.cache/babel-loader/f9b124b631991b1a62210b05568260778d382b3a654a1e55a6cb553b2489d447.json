{"ast":null,"code":"import { parseDef } from \"../parseDef.mjs\";\nconst isJsonSchema7AllOfType = type => {\n  if ('type' in type && type.type === 'string') return false;\n  return 'allOf' in type;\n};\nexport function parseIntersectionDef(def, refs) {\n  const allOf = [parseDef(def.left._def, {\n    ...refs,\n    currentPath: [...refs.currentPath, 'allOf', '0']\n  }), parseDef(def.right._def, {\n    ...refs,\n    currentPath: [...refs.currentPath, 'allOf', '1']\n  })].filter(x => !!x);\n  let unevaluatedProperties = refs.target === 'jsonSchema2019-09' ? {\n    unevaluatedProperties: false\n  } : undefined;\n  const mergedAllOf = [];\n  // If either of the schemas is an allOf, merge them into a single allOf\n  allOf.forEach(schema => {\n    if (isJsonSchema7AllOfType(schema)) {\n      mergedAllOf.push(...schema.allOf);\n      if (schema.unevaluatedProperties === undefined) {\n        // If one of the schemas has no unevaluatedProperties set,\n        // the merged schema should also have no unevaluatedProperties set\n        unevaluatedProperties = undefined;\n      }\n    } else {\n      let nestedSchema = schema;\n      if ('additionalProperties' in schema && schema.additionalProperties === false) {\n        const {\n          additionalProperties,\n          ...rest\n        } = schema;\n        nestedSchema = rest;\n      } else {\n        // As soon as one of the schemas has additionalProperties set not to false, we allow unevaluatedProperties\n        unevaluatedProperties = undefined;\n      }\n      mergedAllOf.push(nestedSchema);\n    }\n  });\n  return mergedAllOf.length ? {\n    allOf: mergedAllOf,\n    ...unevaluatedProperties\n  } : undefined;\n}","map":{"version":3,"names":["parseDef","isJsonSchema7AllOfType","type","parseIntersectionDef","def","refs","allOf","left","_def","currentPath","right","filter","x","unevaluatedProperties","target","undefined","mergedAllOf","forEach","schema","push","nestedSchema","additionalProperties","rest","length"],"sources":["/Users/youngchen/Downloads/cs224g-triage/node_modules/openai/src/_vendor/zod-to-json-schema/parsers/intersection.ts"],"sourcesContent":["import { ZodIntersectionDef } from 'zod';\nimport { JsonSchema7Type, parseDef } from '../parseDef';\nimport { Refs } from '../Refs';\nimport { JsonSchema7StringType } from './string';\n\nexport type JsonSchema7AllOfType = {\n  allOf: JsonSchema7Type[];\n  unevaluatedProperties?: boolean;\n};\n\nconst isJsonSchema7AllOfType = (\n  type: JsonSchema7Type | JsonSchema7StringType,\n): type is JsonSchema7AllOfType => {\n  if ('type' in type && type.type === 'string') return false;\n  return 'allOf' in type;\n};\n\nexport function parseIntersectionDef(\n  def: ZodIntersectionDef,\n  refs: Refs,\n): JsonSchema7AllOfType | JsonSchema7Type | undefined {\n  const allOf = [\n    parseDef(def.left._def, {\n      ...refs,\n      currentPath: [...refs.currentPath, 'allOf', '0'],\n    }),\n    parseDef(def.right._def, {\n      ...refs,\n      currentPath: [...refs.currentPath, 'allOf', '1'],\n    }),\n  ].filter((x): x is JsonSchema7Type => !!x);\n\n  let unevaluatedProperties: Pick<JsonSchema7AllOfType, 'unevaluatedProperties'> | undefined =\n    refs.target === 'jsonSchema2019-09' ? { unevaluatedProperties: false } : undefined;\n\n  const mergedAllOf: JsonSchema7Type[] = [];\n  // If either of the schemas is an allOf, merge them into a single allOf\n  allOf.forEach((schema) => {\n    if (isJsonSchema7AllOfType(schema)) {\n      mergedAllOf.push(...schema.allOf);\n      if (schema.unevaluatedProperties === undefined) {\n        // If one of the schemas has no unevaluatedProperties set,\n        // the merged schema should also have no unevaluatedProperties set\n        unevaluatedProperties = undefined;\n      }\n    } else {\n      let nestedSchema: JsonSchema7Type = schema;\n      if ('additionalProperties' in schema && schema.additionalProperties === false) {\n        const { additionalProperties, ...rest } = schema;\n        nestedSchema = rest;\n      } else {\n        // As soon as one of the schemas has additionalProperties set not to false, we allow unevaluatedProperties\n        unevaluatedProperties = undefined;\n      }\n      mergedAllOf.push(nestedSchema);\n    }\n  });\n  return mergedAllOf.length ?\n      {\n        allOf: mergedAllOf,\n        ...unevaluatedProperties,\n      }\n    : undefined;\n}\n"],"mappings":"SAC0BA,QAAQ,QAAE;AASpC,MAAMC,sBAAsB,GAC1BC,IAA6C,IACb;EAChC,IAAI,MAAM,IAAIA,IAAI,IAAIA,IAAI,CAACA,IAAI,KAAK,QAAQ,EAAE,OAAO,KAAK;EAC1D,OAAO,OAAO,IAAIA,IAAI;AACxB,CAAC;AAED,OAAM,SAAUC,oBAAoBA,CAClCC,GAAuB,EACvBC,IAAU;EAEV,MAAMC,KAAK,GAAG,CACZN,QAAQ,CAACI,GAAG,CAACG,IAAI,CAACC,IAAI,EAAE;IACtB,GAAGH,IAAI;IACPI,WAAW,EAAE,CAAC,GAAGJ,IAAI,CAACI,WAAW,EAAE,OAAO,EAAE,GAAG;GAChD,CAAC,EACFT,QAAQ,CAACI,GAAG,CAACM,KAAK,CAACF,IAAI,EAAE;IACvB,GAAGH,IAAI;IACPI,WAAW,EAAE,CAAC,GAAGJ,IAAI,CAACI,WAAW,EAAE,OAAO,EAAE,GAAG;GAChD,CAAC,CACH,CAACE,MAAM,CAAEC,CAAC,IAA2B,CAAC,CAACA,CAAC,CAAC;EAE1C,IAAIC,qBAAqB,GACvBR,IAAI,CAACS,MAAM,KAAK,mBAAmB,GAAG;IAAED,qBAAqB,EAAE;EAAK,CAAE,GAAGE,SAAS;EAEpF,MAAMC,WAAW,GAAsB,EAAE;EACzC;EACAV,KAAK,CAACW,OAAO,CAAEC,MAAM,IAAI;IACvB,IAAIjB,sBAAsB,CAACiB,MAAM,CAAC,EAAE;MAClCF,WAAW,CAACG,IAAI,CAAC,GAAGD,MAAM,CAACZ,KAAK,CAAC;MACjC,IAAIY,MAAM,CAACL,qBAAqB,KAAKE,SAAS,EAAE;QAC9C;QACA;QACAF,qBAAqB,GAAGE,SAAS;;KAEpC,MAAM;MACL,IAAIK,YAAY,GAAoBF,MAAM;MAC1C,IAAI,sBAAsB,IAAIA,MAAM,IAAIA,MAAM,CAACG,oBAAoB,KAAK,KAAK,EAAE;QAC7E,MAAM;UAAEA,oBAAoB;UAAE,GAAGC;QAAI,CAAE,GAAGJ,MAAM;QAChDE,YAAY,GAAGE,IAAI;OACpB,MAAM;QACL;QACAT,qBAAqB,GAAGE,SAAS;;MAEnCC,WAAW,CAACG,IAAI,CAACC,YAAY,CAAC;;EAElC,CAAC,CAAC;EACF,OAAOJ,WAAW,CAACO,MAAM,GACrB;IACEjB,KAAK,EAAEU,WAAW;IAClB,GAAGH;GACJ,GACDE,SAAS;AACf","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}