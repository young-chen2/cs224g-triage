{"ast":null,"code":"import { BaseChain } from \"./base.js\";\nimport { intersection, union, difference } from \"../util/set.js\";\nfunction formatSet(input) {\n  return Array.from(input).map(i => `\"${i}\"`).join(\", \");\n}\n/**\n * Chain where the outputs of one chain feed directly into next.\n * @example\n * ```typescript\n * const promptTemplate = new PromptTemplate({\n *   template: `You are a playwright. Given the title of play and the era it is set in, it is your job to write a synopsis for that title.\n * Title: {title}\n * Era: {era}\n * Playwright: This is a synopsis for the above play:`,\n *   inputVariables: [\"title\", \"era\"],\n * });\n\n * const reviewPromptTemplate = new PromptTemplate({\n *   template: `You are a play critic from the New York Times. Given the synopsis of play, it is your job to write a review for that play.\n *\n *     Play Synopsis:\n *     {synopsis}\n *     Review from a New York Times play critic of the above play:`,\n *   inputVariables: [\"synopsis\"],\n * });\n\n * const overallChain = new SequentialChain({\n *   chains: [\n *     new LLMChain({\n *       llm: new ChatOpenAI({ temperature: 0 }),\n *       prompt: promptTemplate,\n *       outputKey: \"synopsis\",\n *     }),\n *     new LLMChain({\n *       llm: new OpenAI({ temperature: 0 }),\n *       prompt: reviewPromptTemplate,\n *       outputKey: \"review\",\n *     }),\n *   ],\n *   inputVariables: [\"era\", \"title\"],\n *   outputVariables: [\"synopsis\", \"review\"],\n *   verbose: true,\n * });\n\n * const chainExecutionResult = await overallChain.call({\n *   title: \"Tragedy at sunset on the beach\",\n *   era: \"Victorian England\",\n * });\n * console.log(chainExecutionResult);\n * ```\n *\n * @deprecated\n * Switch to {@link https://js.langchain.com/docs/expression_language/ | expression language}.\n * Will be removed in 0.2.0\n */\nexport class SequentialChain extends BaseChain {\n  static lc_name() {\n    return \"SequentialChain\";\n  }\n  get inputKeys() {\n    return this.inputVariables;\n  }\n  get outputKeys() {\n    return this.outputVariables;\n  }\n  constructor(fields) {\n    super(fields);\n    Object.defineProperty(this, \"chains\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, \"inputVariables\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, \"outputVariables\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, \"returnAll\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    this.chains = fields.chains;\n    this.inputVariables = fields.inputVariables;\n    this.outputVariables = fields.outputVariables ?? [];\n    if (this.outputVariables.length > 0 && fields.returnAll) {\n      throw new Error(\"Either specify variables to return using `outputVariables` or use `returnAll` param. Cannot apply both conditions at the same time.\");\n    }\n    this.returnAll = fields.returnAll ?? false;\n    this._validateChains();\n  }\n  /** @ignore */\n  _validateChains() {\n    if (this.chains.length === 0) {\n      throw new Error(\"Sequential chain must have at least one chain.\");\n    }\n    const memoryKeys = this.memory?.memoryKeys ?? [];\n    const inputKeysSet = new Set(this.inputKeys);\n    const memoryKeysSet = new Set(memoryKeys);\n    const keysIntersection = intersection(inputKeysSet, memoryKeysSet);\n    if (keysIntersection.size > 0) {\n      throw new Error(`The following keys: ${formatSet(keysIntersection)} are overlapping between memory and input keys of the chain variables. This can lead to unexpected behaviour. Please use input and memory keys that don't overlap.`);\n    }\n    const availableKeys = union(inputKeysSet, memoryKeysSet);\n    for (const chain of this.chains) {\n      let missingKeys = difference(new Set(chain.inputKeys), availableKeys);\n      if (chain.memory) {\n        missingKeys = difference(missingKeys, new Set(chain.memory.memoryKeys));\n      }\n      if (missingKeys.size > 0) {\n        throw new Error(`Missing variables for chain \"${chain._chainType()}\": ${formatSet(missingKeys)}. Only got the following variables: ${formatSet(availableKeys)}.`);\n      }\n      const outputKeysSet = new Set(chain.outputKeys);\n      const overlappingOutputKeys = intersection(availableKeys, outputKeysSet);\n      if (overlappingOutputKeys.size > 0) {\n        throw new Error(`The following output variables for chain \"${chain._chainType()}\" are overlapping: ${formatSet(overlappingOutputKeys)}. This can lead to unexpected behaviour.`);\n      }\n      for (const outputKey of outputKeysSet) {\n        availableKeys.add(outputKey);\n      }\n    }\n    if (this.outputVariables.length === 0) {\n      if (this.returnAll) {\n        const outputKeys = difference(availableKeys, inputKeysSet);\n        this.outputVariables = Array.from(outputKeys);\n      } else {\n        this.outputVariables = this.chains[this.chains.length - 1].outputKeys;\n      }\n    } else {\n      const missingKeys = difference(new Set(this.outputVariables), new Set(availableKeys));\n      if (missingKeys.size > 0) {\n        throw new Error(`The following output variables were expected to be in the final chain output but were not found: ${formatSet(missingKeys)}.`);\n      }\n    }\n  }\n  /** @ignore */\n  async _call(values, runManager) {\n    let input = {};\n    const allChainValues = values;\n    let i = 0;\n    for (const chain of this.chains) {\n      i += 1;\n      input = await chain.call(allChainValues, runManager?.getChild(`step_${i}`));\n      for (const key of Object.keys(input)) {\n        allChainValues[key] = input[key];\n      }\n    }\n    const output = {};\n    for (const key of this.outputVariables) {\n      output[key] = allChainValues[key];\n    }\n    return output;\n  }\n  _chainType() {\n    return \"sequential_chain\";\n  }\n  static async deserialize(data) {\n    const chains = [];\n    const inputVariables = data.input_variables;\n    const outputVariables = data.output_variables;\n    const serializedChains = data.chains;\n    for (const serializedChain of serializedChains) {\n      const deserializedChain = await BaseChain.deserialize(serializedChain);\n      chains.push(deserializedChain);\n    }\n    return new SequentialChain({\n      chains,\n      inputVariables,\n      outputVariables\n    });\n  }\n  serialize() {\n    const chains = [];\n    for (const chain of this.chains) {\n      chains.push(chain.serialize());\n    }\n    return {\n      _type: this._chainType(),\n      input_variables: this.inputVariables,\n      output_variables: this.outputVariables,\n      chains\n    };\n  }\n}\n/**\n * @deprecated Switch to expression language: https://js.langchain.com/docs/expression_language/\n * Simple chain where a single string output of one chain is fed directly into the next.\n * @augments BaseChain\n * @augments SimpleSequentialChainInput\n *\n * @example\n * ```ts\n * import { SimpleSequentialChain, LLMChain } from \"langchain/chains\";\n * import { OpenAI } from \"langchain/llms/openai\";\n * import { PromptTemplate } from \"langchain/prompts\";\n *\n * // This is an LLMChain to write a synopsis given a title of a play.\n * const llm = new OpenAI({ temperature: 0 });\n * const template = `You are a playwright. Given the title of play, it is your job to write a synopsis for that title.\n *\n * Title: {title}\n * Playwright: This is a synopsis for the above play:`\n * const promptTemplate = new PromptTemplate({ template, inputVariables: [\"title\"] });\n * const synopsisChain = new LLMChain({ llm, prompt: promptTemplate });\n *\n *\n * // This is an LLMChain to write a review of a play given a synopsis.\n * const reviewLLM = new OpenAI({ temperature: 0 })\n * const reviewTemplate = `You are a play critic from the New York Times. Given the synopsis of play, it is your job to write a review for that play.\n *\n * Play Synopsis:\n * {synopsis}\n * Review from a New York Times play critic of the above play:`\n * const reviewPromptTemplate = new PromptTemplate({ template: reviewTemplate, inputVariables: [\"synopsis\"] });\n * const reviewChain = new LLMChain({ llm: reviewLLM, prompt: reviewPromptTemplate });\n *\n * const overallChain = new SimpleSequentialChain({chains: [synopsisChain, reviewChain], verbose:true})\n * const review = await overallChain.run(\"Tragedy at sunset on the beach\")\n * // the variable review contains resulting play review.\n * ```\n */\nexport class SimpleSequentialChain extends BaseChain {\n  static lc_name() {\n    return \"SimpleSequentialChain\";\n  }\n  get inputKeys() {\n    return [this.inputKey];\n  }\n  get outputKeys() {\n    return [this.outputKey];\n  }\n  constructor(fields) {\n    super(fields);\n    Object.defineProperty(this, \"chains\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, \"inputKey\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: \"input\"\n    });\n    Object.defineProperty(this, \"outputKey\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: \"output\"\n    });\n    Object.defineProperty(this, \"trimOutputs\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    this.chains = fields.chains;\n    this.trimOutputs = fields.trimOutputs ?? false;\n    this._validateChains();\n  }\n  /** @ignore */\n  _validateChains() {\n    for (const chain of this.chains) {\n      if (chain.inputKeys.filter(k => !chain.memory?.memoryKeys.includes(k) ?? true).length !== 1) {\n        throw new Error(`Chains used in SimpleSequentialChain should all have one input, got ${chain.inputKeys.length} for ${chain._chainType()}.`);\n      }\n      if (chain.outputKeys.length !== 1) {\n        throw new Error(`Chains used in SimpleSequentialChain should all have one output, got ${chain.outputKeys.length} for ${chain._chainType()}.`);\n      }\n    }\n  }\n  /** @ignore */\n  async _call(values, runManager) {\n    let input = values[this.inputKey];\n    let i = 0;\n    for (const chain of this.chains) {\n      i += 1;\n      input = (await chain.call({\n        [chain.inputKeys[0]]: input,\n        signal: values.signal\n      }, runManager?.getChild(`step_${i}`)))[chain.outputKeys[0]];\n      if (this.trimOutputs) {\n        input = input.trim();\n      }\n      await runManager?.handleText(input);\n    }\n    return {\n      [this.outputKey]: input\n    };\n  }\n  _chainType() {\n    return \"simple_sequential_chain\";\n  }\n  static async deserialize(data) {\n    const chains = [];\n    const serializedChains = data.chains;\n    for (const serializedChain of serializedChains) {\n      const deserializedChain = await BaseChain.deserialize(serializedChain);\n      chains.push(deserializedChain);\n    }\n    return new SimpleSequentialChain({\n      chains\n    });\n  }\n  serialize() {\n    const chains = [];\n    for (const chain of this.chains) {\n      chains.push(chain.serialize());\n    }\n    return {\n      _type: this._chainType(),\n      chains\n    };\n  }\n}","map":{"version":3,"names":["BaseChain","intersection","union","difference","formatSet","input","Array","from","map","i","join","SequentialChain","lc_name","inputKeys","inputVariables","outputKeys","outputVariables","constructor","fields","Object","defineProperty","enumerable","configurable","writable","value","chains","length","returnAll","Error","_validateChains","memoryKeys","memory","inputKeysSet","Set","memoryKeysSet","keysIntersection","size","availableKeys","chain","missingKeys","_chainType","outputKeysSet","overlappingOutputKeys","outputKey","add","_call","values","runManager","allChainValues","call","getChild","key","keys","output","deserialize","data","input_variables","output_variables","serializedChains","serializedChain","deserializedChain","push","serialize","_type","SimpleSequentialChain","inputKey","trimOutputs","filter","k","includes","signal","trim","handleText"],"sources":["/Users/youngchen/Downloads/cs224g-triage/node_modules/langchain/dist/chains/sequential_chain.js"],"sourcesContent":["import { BaseChain } from \"./base.js\";\nimport { intersection, union, difference } from \"../util/set.js\";\nfunction formatSet(input) {\n    return Array.from(input)\n        .map((i) => `\"${i}\"`)\n        .join(\", \");\n}\n/**\n * Chain where the outputs of one chain feed directly into next.\n * @example\n * ```typescript\n * const promptTemplate = new PromptTemplate({\n *   template: `You are a playwright. Given the title of play and the era it is set in, it is your job to write a synopsis for that title.\n * Title: {title}\n * Era: {era}\n * Playwright: This is a synopsis for the above play:`,\n *   inputVariables: [\"title\", \"era\"],\n * });\n\n * const reviewPromptTemplate = new PromptTemplate({\n *   template: `You are a play critic from the New York Times. Given the synopsis of play, it is your job to write a review for that play.\n *\n *     Play Synopsis:\n *     {synopsis}\n *     Review from a New York Times play critic of the above play:`,\n *   inputVariables: [\"synopsis\"],\n * });\n\n * const overallChain = new SequentialChain({\n *   chains: [\n *     new LLMChain({\n *       llm: new ChatOpenAI({ temperature: 0 }),\n *       prompt: promptTemplate,\n *       outputKey: \"synopsis\",\n *     }),\n *     new LLMChain({\n *       llm: new OpenAI({ temperature: 0 }),\n *       prompt: reviewPromptTemplate,\n *       outputKey: \"review\",\n *     }),\n *   ],\n *   inputVariables: [\"era\", \"title\"],\n *   outputVariables: [\"synopsis\", \"review\"],\n *   verbose: true,\n * });\n\n * const chainExecutionResult = await overallChain.call({\n *   title: \"Tragedy at sunset on the beach\",\n *   era: \"Victorian England\",\n * });\n * console.log(chainExecutionResult);\n * ```\n *\n * @deprecated\n * Switch to {@link https://js.langchain.com/docs/expression_language/ | expression language}.\n * Will be removed in 0.2.0\n */\nexport class SequentialChain extends BaseChain {\n    static lc_name() {\n        return \"SequentialChain\";\n    }\n    get inputKeys() {\n        return this.inputVariables;\n    }\n    get outputKeys() {\n        return this.outputVariables;\n    }\n    constructor(fields) {\n        super(fields);\n        Object.defineProperty(this, \"chains\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"inputVariables\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"outputVariables\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"returnAll\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.chains = fields.chains;\n        this.inputVariables = fields.inputVariables;\n        this.outputVariables = fields.outputVariables ?? [];\n        if (this.outputVariables.length > 0 && fields.returnAll) {\n            throw new Error(\"Either specify variables to return using `outputVariables` or use `returnAll` param. Cannot apply both conditions at the same time.\");\n        }\n        this.returnAll = fields.returnAll ?? false;\n        this._validateChains();\n    }\n    /** @ignore */\n    _validateChains() {\n        if (this.chains.length === 0) {\n            throw new Error(\"Sequential chain must have at least one chain.\");\n        }\n        const memoryKeys = this.memory?.memoryKeys ?? [];\n        const inputKeysSet = new Set(this.inputKeys);\n        const memoryKeysSet = new Set(memoryKeys);\n        const keysIntersection = intersection(inputKeysSet, memoryKeysSet);\n        if (keysIntersection.size > 0) {\n            throw new Error(`The following keys: ${formatSet(keysIntersection)} are overlapping between memory and input keys of the chain variables. This can lead to unexpected behaviour. Please use input and memory keys that don't overlap.`);\n        }\n        const availableKeys = union(inputKeysSet, memoryKeysSet);\n        for (const chain of this.chains) {\n            let missingKeys = difference(new Set(chain.inputKeys), availableKeys);\n            if (chain.memory) {\n                missingKeys = difference(missingKeys, new Set(chain.memory.memoryKeys));\n            }\n            if (missingKeys.size > 0) {\n                throw new Error(`Missing variables for chain \"${chain._chainType()}\": ${formatSet(missingKeys)}. Only got the following variables: ${formatSet(availableKeys)}.`);\n            }\n            const outputKeysSet = new Set(chain.outputKeys);\n            const overlappingOutputKeys = intersection(availableKeys, outputKeysSet);\n            if (overlappingOutputKeys.size > 0) {\n                throw new Error(`The following output variables for chain \"${chain._chainType()}\" are overlapping: ${formatSet(overlappingOutputKeys)}. This can lead to unexpected behaviour.`);\n            }\n            for (const outputKey of outputKeysSet) {\n                availableKeys.add(outputKey);\n            }\n        }\n        if (this.outputVariables.length === 0) {\n            if (this.returnAll) {\n                const outputKeys = difference(availableKeys, inputKeysSet);\n                this.outputVariables = Array.from(outputKeys);\n            }\n            else {\n                this.outputVariables = this.chains[this.chains.length - 1].outputKeys;\n            }\n        }\n        else {\n            const missingKeys = difference(new Set(this.outputVariables), new Set(availableKeys));\n            if (missingKeys.size > 0) {\n                throw new Error(`The following output variables were expected to be in the final chain output but were not found: ${formatSet(missingKeys)}.`);\n            }\n        }\n    }\n    /** @ignore */\n    async _call(values, runManager) {\n        let input = {};\n        const allChainValues = values;\n        let i = 0;\n        for (const chain of this.chains) {\n            i += 1;\n            input = await chain.call(allChainValues, runManager?.getChild(`step_${i}`));\n            for (const key of Object.keys(input)) {\n                allChainValues[key] = input[key];\n            }\n        }\n        const output = {};\n        for (const key of this.outputVariables) {\n            output[key] = allChainValues[key];\n        }\n        return output;\n    }\n    _chainType() {\n        return \"sequential_chain\";\n    }\n    static async deserialize(data) {\n        const chains = [];\n        const inputVariables = data.input_variables;\n        const outputVariables = data.output_variables;\n        const serializedChains = data.chains;\n        for (const serializedChain of serializedChains) {\n            const deserializedChain = await BaseChain.deserialize(serializedChain);\n            chains.push(deserializedChain);\n        }\n        return new SequentialChain({ chains, inputVariables, outputVariables });\n    }\n    serialize() {\n        const chains = [];\n        for (const chain of this.chains) {\n            chains.push(chain.serialize());\n        }\n        return {\n            _type: this._chainType(),\n            input_variables: this.inputVariables,\n            output_variables: this.outputVariables,\n            chains,\n        };\n    }\n}\n/**\n * @deprecated Switch to expression language: https://js.langchain.com/docs/expression_language/\n * Simple chain where a single string output of one chain is fed directly into the next.\n * @augments BaseChain\n * @augments SimpleSequentialChainInput\n *\n * @example\n * ```ts\n * import { SimpleSequentialChain, LLMChain } from \"langchain/chains\";\n * import { OpenAI } from \"langchain/llms/openai\";\n * import { PromptTemplate } from \"langchain/prompts\";\n *\n * // This is an LLMChain to write a synopsis given a title of a play.\n * const llm = new OpenAI({ temperature: 0 });\n * const template = `You are a playwright. Given the title of play, it is your job to write a synopsis for that title.\n *\n * Title: {title}\n * Playwright: This is a synopsis for the above play:`\n * const promptTemplate = new PromptTemplate({ template, inputVariables: [\"title\"] });\n * const synopsisChain = new LLMChain({ llm, prompt: promptTemplate });\n *\n *\n * // This is an LLMChain to write a review of a play given a synopsis.\n * const reviewLLM = new OpenAI({ temperature: 0 })\n * const reviewTemplate = `You are a play critic from the New York Times. Given the synopsis of play, it is your job to write a review for that play.\n *\n * Play Synopsis:\n * {synopsis}\n * Review from a New York Times play critic of the above play:`\n * const reviewPromptTemplate = new PromptTemplate({ template: reviewTemplate, inputVariables: [\"synopsis\"] });\n * const reviewChain = new LLMChain({ llm: reviewLLM, prompt: reviewPromptTemplate });\n *\n * const overallChain = new SimpleSequentialChain({chains: [synopsisChain, reviewChain], verbose:true})\n * const review = await overallChain.run(\"Tragedy at sunset on the beach\")\n * // the variable review contains resulting play review.\n * ```\n */\nexport class SimpleSequentialChain extends BaseChain {\n    static lc_name() {\n        return \"SimpleSequentialChain\";\n    }\n    get inputKeys() {\n        return [this.inputKey];\n    }\n    get outputKeys() {\n        return [this.outputKey];\n    }\n    constructor(fields) {\n        super(fields);\n        Object.defineProperty(this, \"chains\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"inputKey\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: \"input\"\n        });\n        Object.defineProperty(this, \"outputKey\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: \"output\"\n        });\n        Object.defineProperty(this, \"trimOutputs\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.chains = fields.chains;\n        this.trimOutputs = fields.trimOutputs ?? false;\n        this._validateChains();\n    }\n    /** @ignore */\n    _validateChains() {\n        for (const chain of this.chains) {\n            if (chain.inputKeys.filter((k) => !chain.memory?.memoryKeys.includes(k) ?? true).length !== 1) {\n                throw new Error(`Chains used in SimpleSequentialChain should all have one input, got ${chain.inputKeys.length} for ${chain._chainType()}.`);\n            }\n            if (chain.outputKeys.length !== 1) {\n                throw new Error(`Chains used in SimpleSequentialChain should all have one output, got ${chain.outputKeys.length} for ${chain._chainType()}.`);\n            }\n        }\n    }\n    /** @ignore */\n    async _call(values, runManager) {\n        let input = values[this.inputKey];\n        let i = 0;\n        for (const chain of this.chains) {\n            i += 1;\n            input = (await chain.call({ [chain.inputKeys[0]]: input, signal: values.signal }, runManager?.getChild(`step_${i}`)))[chain.outputKeys[0]];\n            if (this.trimOutputs) {\n                input = input.trim();\n            }\n            await runManager?.handleText(input);\n        }\n        return { [this.outputKey]: input };\n    }\n    _chainType() {\n        return \"simple_sequential_chain\";\n    }\n    static async deserialize(data) {\n        const chains = [];\n        const serializedChains = data.chains;\n        for (const serializedChain of serializedChains) {\n            const deserializedChain = await BaseChain.deserialize(serializedChain);\n            chains.push(deserializedChain);\n        }\n        return new SimpleSequentialChain({ chains });\n    }\n    serialize() {\n        const chains = [];\n        for (const chain of this.chains) {\n            chains.push(chain.serialize());\n        }\n        return {\n            _type: this._chainType(),\n            chains,\n        };\n    }\n}\n"],"mappings":"AAAA,SAASA,SAAS,QAAQ,WAAW;AACrC,SAASC,YAAY,EAAEC,KAAK,EAAEC,UAAU,QAAQ,gBAAgB;AAChE,SAASC,SAASA,CAACC,KAAK,EAAE;EACtB,OAAOC,KAAK,CAACC,IAAI,CAACF,KAAK,CAAC,CACnBG,GAAG,CAAEC,CAAC,IAAK,IAAIA,CAAC,GAAG,CAAC,CACpBC,IAAI,CAAC,IAAI,CAAC;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,MAAMC,eAAe,SAASX,SAAS,CAAC;EAC3C,OAAOY,OAAOA,CAAA,EAAG;IACb,OAAO,iBAAiB;EAC5B;EACA,IAAIC,SAASA,CAAA,EAAG;IACZ,OAAO,IAAI,CAACC,cAAc;EAC9B;EACA,IAAIC,UAAUA,CAAA,EAAG;IACb,OAAO,IAAI,CAACC,eAAe;EAC/B;EACAC,WAAWA,CAACC,MAAM,EAAE;IAChB,KAAK,CAACA,MAAM,CAAC;IACbC,MAAM,CAACC,cAAc,CAAC,IAAI,EAAE,QAAQ,EAAE;MAClCC,UAAU,EAAE,IAAI;MAChBC,YAAY,EAAE,IAAI;MAClBC,QAAQ,EAAE,IAAI;MACdC,KAAK,EAAE,KAAK;IAChB,CAAC,CAAC;IACFL,MAAM,CAACC,cAAc,CAAC,IAAI,EAAE,gBAAgB,EAAE;MAC1CC,UAAU,EAAE,IAAI;MAChBC,YAAY,EAAE,IAAI;MAClBC,QAAQ,EAAE,IAAI;MACdC,KAAK,EAAE,KAAK;IAChB,CAAC,CAAC;IACFL,MAAM,CAACC,cAAc,CAAC,IAAI,EAAE,iBAAiB,EAAE;MAC3CC,UAAU,EAAE,IAAI;MAChBC,YAAY,EAAE,IAAI;MAClBC,QAAQ,EAAE,IAAI;MACdC,KAAK,EAAE,KAAK;IAChB,CAAC,CAAC;IACFL,MAAM,CAACC,cAAc,CAAC,IAAI,EAAE,WAAW,EAAE;MACrCC,UAAU,EAAE,IAAI;MAChBC,YAAY,EAAE,IAAI;MAClBC,QAAQ,EAAE,IAAI;MACdC,KAAK,EAAE,KAAK;IAChB,CAAC,CAAC;IACF,IAAI,CAACC,MAAM,GAAGP,MAAM,CAACO,MAAM;IAC3B,IAAI,CAACX,cAAc,GAAGI,MAAM,CAACJ,cAAc;IAC3C,IAAI,CAACE,eAAe,GAAGE,MAAM,CAACF,eAAe,IAAI,EAAE;IACnD,IAAI,IAAI,CAACA,eAAe,CAACU,MAAM,GAAG,CAAC,IAAIR,MAAM,CAACS,SAAS,EAAE;MACrD,MAAM,IAAIC,KAAK,CAAC,qIAAqI,CAAC;IAC1J;IACA,IAAI,CAACD,SAAS,GAAGT,MAAM,CAACS,SAAS,IAAI,KAAK;IAC1C,IAAI,CAACE,eAAe,CAAC,CAAC;EAC1B;EACA;EACAA,eAAeA,CAAA,EAAG;IACd,IAAI,IAAI,CAACJ,MAAM,CAACC,MAAM,KAAK,CAAC,EAAE;MAC1B,MAAM,IAAIE,KAAK,CAAC,gDAAgD,CAAC;IACrE;IACA,MAAME,UAAU,GAAG,IAAI,CAACC,MAAM,EAAED,UAAU,IAAI,EAAE;IAChD,MAAME,YAAY,GAAG,IAAIC,GAAG,CAAC,IAAI,CAACpB,SAAS,CAAC;IAC5C,MAAMqB,aAAa,GAAG,IAAID,GAAG,CAACH,UAAU,CAAC;IACzC,MAAMK,gBAAgB,GAAGlC,YAAY,CAAC+B,YAAY,EAAEE,aAAa,CAAC;IAClE,IAAIC,gBAAgB,CAACC,IAAI,GAAG,CAAC,EAAE;MAC3B,MAAM,IAAIR,KAAK,CAAC,uBAAuBxB,SAAS,CAAC+B,gBAAgB,CAAC,oKAAoK,CAAC;IAC3O;IACA,MAAME,aAAa,GAAGnC,KAAK,CAAC8B,YAAY,EAAEE,aAAa,CAAC;IACxD,KAAK,MAAMI,KAAK,IAAI,IAAI,CAACb,MAAM,EAAE;MAC7B,IAAIc,WAAW,GAAGpC,UAAU,CAAC,IAAI8B,GAAG,CAACK,KAAK,CAACzB,SAAS,CAAC,EAAEwB,aAAa,CAAC;MACrE,IAAIC,KAAK,CAACP,MAAM,EAAE;QACdQ,WAAW,GAAGpC,UAAU,CAACoC,WAAW,EAAE,IAAIN,GAAG,CAACK,KAAK,CAACP,MAAM,CAACD,UAAU,CAAC,CAAC;MAC3E;MACA,IAAIS,WAAW,CAACH,IAAI,GAAG,CAAC,EAAE;QACtB,MAAM,IAAIR,KAAK,CAAC,gCAAgCU,KAAK,CAACE,UAAU,CAAC,CAAC,MAAMpC,SAAS,CAACmC,WAAW,CAAC,uCAAuCnC,SAAS,CAACiC,aAAa,CAAC,GAAG,CAAC;MACrK;MACA,MAAMI,aAAa,GAAG,IAAIR,GAAG,CAACK,KAAK,CAACvB,UAAU,CAAC;MAC/C,MAAM2B,qBAAqB,GAAGzC,YAAY,CAACoC,aAAa,EAAEI,aAAa,CAAC;MACxE,IAAIC,qBAAqB,CAACN,IAAI,GAAG,CAAC,EAAE;QAChC,MAAM,IAAIR,KAAK,CAAC,6CAA6CU,KAAK,CAACE,UAAU,CAAC,CAAC,sBAAsBpC,SAAS,CAACsC,qBAAqB,CAAC,0CAA0C,CAAC;MACpL;MACA,KAAK,MAAMC,SAAS,IAAIF,aAAa,EAAE;QACnCJ,aAAa,CAACO,GAAG,CAACD,SAAS,CAAC;MAChC;IACJ;IACA,IAAI,IAAI,CAAC3B,eAAe,CAACU,MAAM,KAAK,CAAC,EAAE;MACnC,IAAI,IAAI,CAACC,SAAS,EAAE;QAChB,MAAMZ,UAAU,GAAGZ,UAAU,CAACkC,aAAa,EAAEL,YAAY,CAAC;QAC1D,IAAI,CAAChB,eAAe,GAAGV,KAAK,CAACC,IAAI,CAACQ,UAAU,CAAC;MACjD,CAAC,MACI;QACD,IAAI,CAACC,eAAe,GAAG,IAAI,CAACS,MAAM,CAAC,IAAI,CAACA,MAAM,CAACC,MAAM,GAAG,CAAC,CAAC,CAACX,UAAU;MACzE;IACJ,CAAC,MACI;MACD,MAAMwB,WAAW,GAAGpC,UAAU,CAAC,IAAI8B,GAAG,CAAC,IAAI,CAACjB,eAAe,CAAC,EAAE,IAAIiB,GAAG,CAACI,aAAa,CAAC,CAAC;MACrF,IAAIE,WAAW,CAACH,IAAI,GAAG,CAAC,EAAE;QACtB,MAAM,IAAIR,KAAK,CAAC,oGAAoGxB,SAAS,CAACmC,WAAW,CAAC,GAAG,CAAC;MAClJ;IACJ;EACJ;EACA;EACA,MAAMM,KAAKA,CAACC,MAAM,EAAEC,UAAU,EAAE;IAC5B,IAAI1C,KAAK,GAAG,CAAC,CAAC;IACd,MAAM2C,cAAc,GAAGF,MAAM;IAC7B,IAAIrC,CAAC,GAAG,CAAC;IACT,KAAK,MAAM6B,KAAK,IAAI,IAAI,CAACb,MAAM,EAAE;MAC7BhB,CAAC,IAAI,CAAC;MACNJ,KAAK,GAAG,MAAMiC,KAAK,CAACW,IAAI,CAACD,cAAc,EAAED,UAAU,EAAEG,QAAQ,CAAC,QAAQzC,CAAC,EAAE,CAAC,CAAC;MAC3E,KAAK,MAAM0C,GAAG,IAAIhC,MAAM,CAACiC,IAAI,CAAC/C,KAAK,CAAC,EAAE;QAClC2C,cAAc,CAACG,GAAG,CAAC,GAAG9C,KAAK,CAAC8C,GAAG,CAAC;MACpC;IACJ;IACA,MAAME,MAAM,GAAG,CAAC,CAAC;IACjB,KAAK,MAAMF,GAAG,IAAI,IAAI,CAACnC,eAAe,EAAE;MACpCqC,MAAM,CAACF,GAAG,CAAC,GAAGH,cAAc,CAACG,GAAG,CAAC;IACrC;IACA,OAAOE,MAAM;EACjB;EACAb,UAAUA,CAAA,EAAG;IACT,OAAO,kBAAkB;EAC7B;EACA,aAAac,WAAWA,CAACC,IAAI,EAAE;IAC3B,MAAM9B,MAAM,GAAG,EAAE;IACjB,MAAMX,cAAc,GAAGyC,IAAI,CAACC,eAAe;IAC3C,MAAMxC,eAAe,GAAGuC,IAAI,CAACE,gBAAgB;IAC7C,MAAMC,gBAAgB,GAAGH,IAAI,CAAC9B,MAAM;IACpC,KAAK,MAAMkC,eAAe,IAAID,gBAAgB,EAAE;MAC5C,MAAME,iBAAiB,GAAG,MAAM5D,SAAS,CAACsD,WAAW,CAACK,eAAe,CAAC;MACtElC,MAAM,CAACoC,IAAI,CAACD,iBAAiB,CAAC;IAClC;IACA,OAAO,IAAIjD,eAAe,CAAC;MAAEc,MAAM;MAAEX,cAAc;MAAEE;IAAgB,CAAC,CAAC;EAC3E;EACA8C,SAASA,CAAA,EAAG;IACR,MAAMrC,MAAM,GAAG,EAAE;IACjB,KAAK,MAAMa,KAAK,IAAI,IAAI,CAACb,MAAM,EAAE;MAC7BA,MAAM,CAACoC,IAAI,CAACvB,KAAK,CAACwB,SAAS,CAAC,CAAC,CAAC;IAClC;IACA,OAAO;MACHC,KAAK,EAAE,IAAI,CAACvB,UAAU,CAAC,CAAC;MACxBgB,eAAe,EAAE,IAAI,CAAC1C,cAAc;MACpC2C,gBAAgB,EAAE,IAAI,CAACzC,eAAe;MACtCS;IACJ,CAAC;EACL;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,MAAMuC,qBAAqB,SAAShE,SAAS,CAAC;EACjD,OAAOY,OAAOA,CAAA,EAAG;IACb,OAAO,uBAAuB;EAClC;EACA,IAAIC,SAASA,CAAA,EAAG;IACZ,OAAO,CAAC,IAAI,CAACoD,QAAQ,CAAC;EAC1B;EACA,IAAIlD,UAAUA,CAAA,EAAG;IACb,OAAO,CAAC,IAAI,CAAC4B,SAAS,CAAC;EAC3B;EACA1B,WAAWA,CAACC,MAAM,EAAE;IAChB,KAAK,CAACA,MAAM,CAAC;IACbC,MAAM,CAACC,cAAc,CAAC,IAAI,EAAE,QAAQ,EAAE;MAClCC,UAAU,EAAE,IAAI;MAChBC,YAAY,EAAE,IAAI;MAClBC,QAAQ,EAAE,IAAI;MACdC,KAAK,EAAE,KAAK;IAChB,CAAC,CAAC;IACFL,MAAM,CAACC,cAAc,CAAC,IAAI,EAAE,UAAU,EAAE;MACpCC,UAAU,EAAE,IAAI;MAChBC,YAAY,EAAE,IAAI;MAClBC,QAAQ,EAAE,IAAI;MACdC,KAAK,EAAE;IACX,CAAC,CAAC;IACFL,MAAM,CAACC,cAAc,CAAC,IAAI,EAAE,WAAW,EAAE;MACrCC,UAAU,EAAE,IAAI;MAChBC,YAAY,EAAE,IAAI;MAClBC,QAAQ,EAAE,IAAI;MACdC,KAAK,EAAE;IACX,CAAC,CAAC;IACFL,MAAM,CAACC,cAAc,CAAC,IAAI,EAAE,aAAa,EAAE;MACvCC,UAAU,EAAE,IAAI;MAChBC,YAAY,EAAE,IAAI;MAClBC,QAAQ,EAAE,IAAI;MACdC,KAAK,EAAE,KAAK;IAChB,CAAC,CAAC;IACF,IAAI,CAACC,MAAM,GAAGP,MAAM,CAACO,MAAM;IAC3B,IAAI,CAACyC,WAAW,GAAGhD,MAAM,CAACgD,WAAW,IAAI,KAAK;IAC9C,IAAI,CAACrC,eAAe,CAAC,CAAC;EAC1B;EACA;EACAA,eAAeA,CAAA,EAAG;IACd,KAAK,MAAMS,KAAK,IAAI,IAAI,CAACb,MAAM,EAAE;MAC7B,IAAIa,KAAK,CAACzB,SAAS,CAACsD,MAAM,CAAEC,CAAC,IAAK,CAAC9B,KAAK,CAACP,MAAM,EAAED,UAAU,CAACuC,QAAQ,CAACD,CAAC,CAAC,IAAI,IAAI,CAAC,CAAC1C,MAAM,KAAK,CAAC,EAAE;QAC3F,MAAM,IAAIE,KAAK,CAAC,uEAAuEU,KAAK,CAACzB,SAAS,CAACa,MAAM,QAAQY,KAAK,CAACE,UAAU,CAAC,CAAC,GAAG,CAAC;MAC/I;MACA,IAAIF,KAAK,CAACvB,UAAU,CAACW,MAAM,KAAK,CAAC,EAAE;QAC/B,MAAM,IAAIE,KAAK,CAAC,wEAAwEU,KAAK,CAACvB,UAAU,CAACW,MAAM,QAAQY,KAAK,CAACE,UAAU,CAAC,CAAC,GAAG,CAAC;MACjJ;IACJ;EACJ;EACA;EACA,MAAMK,KAAKA,CAACC,MAAM,EAAEC,UAAU,EAAE;IAC5B,IAAI1C,KAAK,GAAGyC,MAAM,CAAC,IAAI,CAACmB,QAAQ,CAAC;IACjC,IAAIxD,CAAC,GAAG,CAAC;IACT,KAAK,MAAM6B,KAAK,IAAI,IAAI,CAACb,MAAM,EAAE;MAC7BhB,CAAC,IAAI,CAAC;MACNJ,KAAK,GAAG,CAAC,MAAMiC,KAAK,CAACW,IAAI,CAAC;QAAE,CAACX,KAAK,CAACzB,SAAS,CAAC,CAAC,CAAC,GAAGR,KAAK;QAAEiE,MAAM,EAAExB,MAAM,CAACwB;MAAO,CAAC,EAAEvB,UAAU,EAAEG,QAAQ,CAAC,QAAQzC,CAAC,EAAE,CAAC,CAAC,EAAE6B,KAAK,CAACvB,UAAU,CAAC,CAAC,CAAC,CAAC;MAC1I,IAAI,IAAI,CAACmD,WAAW,EAAE;QAClB7D,KAAK,GAAGA,KAAK,CAACkE,IAAI,CAAC,CAAC;MACxB;MACA,MAAMxB,UAAU,EAAEyB,UAAU,CAACnE,KAAK,CAAC;IACvC;IACA,OAAO;MAAE,CAAC,IAAI,CAACsC,SAAS,GAAGtC;IAAM,CAAC;EACtC;EACAmC,UAAUA,CAAA,EAAG;IACT,OAAO,yBAAyB;EACpC;EACA,aAAac,WAAWA,CAACC,IAAI,EAAE;IAC3B,MAAM9B,MAAM,GAAG,EAAE;IACjB,MAAMiC,gBAAgB,GAAGH,IAAI,CAAC9B,MAAM;IACpC,KAAK,MAAMkC,eAAe,IAAID,gBAAgB,EAAE;MAC5C,MAAME,iBAAiB,GAAG,MAAM5D,SAAS,CAACsD,WAAW,CAACK,eAAe,CAAC;MACtElC,MAAM,CAACoC,IAAI,CAACD,iBAAiB,CAAC;IAClC;IACA,OAAO,IAAII,qBAAqB,CAAC;MAAEvC;IAAO,CAAC,CAAC;EAChD;EACAqC,SAASA,CAAA,EAAG;IACR,MAAMrC,MAAM,GAAG,EAAE;IACjB,KAAK,MAAMa,KAAK,IAAI,IAAI,CAACb,MAAM,EAAE;MAC7BA,MAAM,CAACoC,IAAI,CAACvB,KAAK,CAACwB,SAAS,CAAC,CAAC,CAAC;IAClC;IACA,OAAO;MACHC,KAAK,EAAE,IAAI,CAACvB,UAAU,CAAC,CAAC;MACxBf;IACJ,CAAC;EACL;AACJ","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}