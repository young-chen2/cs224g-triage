{"ast":null,"code":"import { compare } from \"@langchain/core/utils/json_patch\";\nimport { BaseCumulativeTransformOutputParser, BaseLLMOutputParser, OutputParserException } from \"@langchain/core/output_parsers\";\nimport { parsePartialJson } from \"@langchain/core/output_parsers\";\n/**\n * Class for parsing the output of an LLM. Can be configured to return\n * only the arguments of the function call in the output.\n */\nexport class OutputFunctionsParser extends BaseLLMOutputParser {\n  static lc_name() {\n    return \"OutputFunctionsParser\";\n  }\n  constructor(config) {\n    super();\n    Object.defineProperty(this, \"lc_namespace\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: [\"langchain\", \"output_parsers\", \"openai_functions\"]\n    });\n    Object.defineProperty(this, \"lc_serializable\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: true\n    });\n    Object.defineProperty(this, \"argsOnly\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: true\n    });\n    this.argsOnly = config?.argsOnly ?? this.argsOnly;\n  }\n  /**\n   * Parses the output and returns a string representation of the function\n   * call or its arguments.\n   * @param generations The output of the LLM to parse.\n   * @returns A string representation of the function call or its arguments.\n   */\n  async parseResult(generations) {\n    if (\"message\" in generations[0]) {\n      const gen = generations[0];\n      const functionCall = gen.message.additional_kwargs.function_call;\n      if (!functionCall) {\n        throw new Error(`No function_call in message ${JSON.stringify(generations)}`);\n      }\n      if (!functionCall.arguments) {\n        throw new Error(`No arguments in function_call ${JSON.stringify(generations)}`);\n      }\n      if (this.argsOnly) {\n        return functionCall.arguments;\n      }\n      return JSON.stringify(functionCall);\n    } else {\n      throw new Error(`No message in generations ${JSON.stringify(generations)}`);\n    }\n  }\n}\n/**\n * Class for parsing the output of an LLM into a JSON object. Uses an\n * instance of `OutputFunctionsParser` to parse the output.\n */\nexport class JsonOutputFunctionsParser extends BaseCumulativeTransformOutputParser {\n  static lc_name() {\n    return \"JsonOutputFunctionsParser\";\n  }\n  constructor(config) {\n    super(config);\n    Object.defineProperty(this, \"lc_namespace\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: [\"langchain\", \"output_parsers\", \"openai_functions\"]\n    });\n    Object.defineProperty(this, \"lc_serializable\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: true\n    });\n    Object.defineProperty(this, \"outputParser\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, \"argsOnly\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: true\n    });\n    this.argsOnly = config?.argsOnly ?? this.argsOnly;\n    this.outputParser = new OutputFunctionsParser(config);\n  }\n  _diff(prev, next) {\n    if (!next) {\n      return undefined;\n    }\n    const ops = compare(prev ?? {}, next);\n    return ops;\n  }\n  async parsePartialResult(generations) {\n    const generation = generations[0];\n    if (!generation.message) {\n      return undefined;\n    }\n    const {\n      message\n    } = generation;\n    const functionCall = message.additional_kwargs.function_call;\n    if (!functionCall) {\n      return undefined;\n    }\n    if (this.argsOnly) {\n      return parsePartialJson(functionCall.arguments);\n    }\n    return {\n      ...functionCall,\n      arguments: parsePartialJson(functionCall.arguments)\n    };\n  }\n  /**\n   * Parses the output and returns a JSON object. If `argsOnly` is true,\n   * only the arguments of the function call are returned.\n   * @param generations The output of the LLM to parse.\n   * @returns A JSON object representation of the function call or its arguments.\n   */\n  async parseResult(generations) {\n    const result = await this.outputParser.parseResult(generations);\n    if (!result) {\n      throw new Error(`No result from \"OutputFunctionsParser\" ${JSON.stringify(generations)}`);\n    }\n    return this.parse(result);\n  }\n  async parse(text) {\n    try {\n      const parsedResult = JSON.parse(text);\n      if (this.argsOnly) {\n        return parsedResult;\n      }\n      parsedResult.arguments = JSON.parse(parsedResult.arguments);\n      return parsedResult;\n    } catch (e) {\n      throw new OutputParserException(`Failed to parse. Text: \"${text}\". Error: ${e}`);\n    }\n  }\n  getFormatInstructions() {\n    return \"\";\n  }\n}\n/**\n * Class for parsing the output of an LLM into a JSON object and returning\n * a specific attribute. Uses an instance of `JsonOutputFunctionsParser`\n * to parse the output.\n */\nexport class JsonKeyOutputFunctionsParser extends BaseLLMOutputParser {\n  static lc_name() {\n    return \"JsonKeyOutputFunctionsParser\";\n  }\n  get lc_aliases() {\n    return {\n      attrName: \"key_name\"\n    };\n  }\n  constructor(fields) {\n    super(fields);\n    Object.defineProperty(this, \"lc_namespace\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: [\"langchain\", \"output_parsers\", \"openai_functions\"]\n    });\n    Object.defineProperty(this, \"lc_serializable\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: true\n    });\n    Object.defineProperty(this, \"outputParser\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: new JsonOutputFunctionsParser()\n    });\n    Object.defineProperty(this, \"attrName\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    this.attrName = fields.attrName;\n  }\n  /**\n   * Parses the output and returns a specific attribute of the parsed JSON\n   * object.\n   * @param generations The output of the LLM to parse.\n   * @returns The value of a specific attribute of the parsed JSON object.\n   */\n  async parseResult(generations) {\n    const result = await this.outputParser.parseResult(generations);\n    return result[this.attrName];\n  }\n}","map":{"version":3,"names":["compare","BaseCumulativeTransformOutputParser","BaseLLMOutputParser","OutputParserException","parsePartialJson","OutputFunctionsParser","lc_name","constructor","config","Object","defineProperty","enumerable","configurable","writable","value","argsOnly","parseResult","generations","gen","functionCall","message","additional_kwargs","function_call","Error","JSON","stringify","arguments","JsonOutputFunctionsParser","outputParser","_diff","prev","next","undefined","ops","parsePartialResult","generation","result","parse","text","parsedResult","e","getFormatInstructions","JsonKeyOutputFunctionsParser","lc_aliases","attrName","fields"],"sources":["/Users/youngchen/Downloads/cs224g-triage/node_modules/langchain/dist/output_parsers/openai_functions.js"],"sourcesContent":["import { compare, } from \"@langchain/core/utils/json_patch\";\nimport { BaseCumulativeTransformOutputParser, BaseLLMOutputParser, OutputParserException, } from \"@langchain/core/output_parsers\";\nimport { parsePartialJson } from \"@langchain/core/output_parsers\";\n/**\n * Class for parsing the output of an LLM. Can be configured to return\n * only the arguments of the function call in the output.\n */\nexport class OutputFunctionsParser extends BaseLLMOutputParser {\n    static lc_name() {\n        return \"OutputFunctionsParser\";\n    }\n    constructor(config) {\n        super();\n        Object.defineProperty(this, \"lc_namespace\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: [\"langchain\", \"output_parsers\", \"openai_functions\"]\n        });\n        Object.defineProperty(this, \"lc_serializable\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: true\n        });\n        Object.defineProperty(this, \"argsOnly\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: true\n        });\n        this.argsOnly = config?.argsOnly ?? this.argsOnly;\n    }\n    /**\n     * Parses the output and returns a string representation of the function\n     * call or its arguments.\n     * @param generations The output of the LLM to parse.\n     * @returns A string representation of the function call or its arguments.\n     */\n    async parseResult(generations) {\n        if (\"message\" in generations[0]) {\n            const gen = generations[0];\n            const functionCall = gen.message.additional_kwargs.function_call;\n            if (!functionCall) {\n                throw new Error(`No function_call in message ${JSON.stringify(generations)}`);\n            }\n            if (!functionCall.arguments) {\n                throw new Error(`No arguments in function_call ${JSON.stringify(generations)}`);\n            }\n            if (this.argsOnly) {\n                return functionCall.arguments;\n            }\n            return JSON.stringify(functionCall);\n        }\n        else {\n            throw new Error(`No message in generations ${JSON.stringify(generations)}`);\n        }\n    }\n}\n/**\n * Class for parsing the output of an LLM into a JSON object. Uses an\n * instance of `OutputFunctionsParser` to parse the output.\n */\nexport class JsonOutputFunctionsParser extends BaseCumulativeTransformOutputParser {\n    static lc_name() {\n        return \"JsonOutputFunctionsParser\";\n    }\n    constructor(config) {\n        super(config);\n        Object.defineProperty(this, \"lc_namespace\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: [\"langchain\", \"output_parsers\", \"openai_functions\"]\n        });\n        Object.defineProperty(this, \"lc_serializable\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: true\n        });\n        Object.defineProperty(this, \"outputParser\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"argsOnly\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: true\n        });\n        this.argsOnly = config?.argsOnly ?? this.argsOnly;\n        this.outputParser = new OutputFunctionsParser(config);\n    }\n    _diff(prev, next) {\n        if (!next) {\n            return undefined;\n        }\n        const ops = compare(prev ?? {}, next);\n        return ops;\n    }\n    async parsePartialResult(generations) {\n        const generation = generations[0];\n        if (!generation.message) {\n            return undefined;\n        }\n        const { message } = generation;\n        const functionCall = message.additional_kwargs.function_call;\n        if (!functionCall) {\n            return undefined;\n        }\n        if (this.argsOnly) {\n            return parsePartialJson(functionCall.arguments);\n        }\n        return {\n            ...functionCall,\n            arguments: parsePartialJson(functionCall.arguments),\n        };\n    }\n    /**\n     * Parses the output and returns a JSON object. If `argsOnly` is true,\n     * only the arguments of the function call are returned.\n     * @param generations The output of the LLM to parse.\n     * @returns A JSON object representation of the function call or its arguments.\n     */\n    async parseResult(generations) {\n        const result = await this.outputParser.parseResult(generations);\n        if (!result) {\n            throw new Error(`No result from \"OutputFunctionsParser\" ${JSON.stringify(generations)}`);\n        }\n        return this.parse(result);\n    }\n    async parse(text) {\n        try {\n            const parsedResult = JSON.parse(text);\n            if (this.argsOnly) {\n                return parsedResult;\n            }\n            parsedResult.arguments = JSON.parse(parsedResult.arguments);\n            return parsedResult;\n        }\n        catch (e) {\n            throw new OutputParserException(`Failed to parse. Text: \"${text}\". Error: ${e}`);\n        }\n    }\n    getFormatInstructions() {\n        return \"\";\n    }\n}\n/**\n * Class for parsing the output of an LLM into a JSON object and returning\n * a specific attribute. Uses an instance of `JsonOutputFunctionsParser`\n * to parse the output.\n */\nexport class JsonKeyOutputFunctionsParser extends BaseLLMOutputParser {\n    static lc_name() {\n        return \"JsonKeyOutputFunctionsParser\";\n    }\n    get lc_aliases() {\n        return {\n            attrName: \"key_name\",\n        };\n    }\n    constructor(fields) {\n        super(fields);\n        Object.defineProperty(this, \"lc_namespace\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: [\"langchain\", \"output_parsers\", \"openai_functions\"]\n        });\n        Object.defineProperty(this, \"lc_serializable\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: true\n        });\n        Object.defineProperty(this, \"outputParser\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: new JsonOutputFunctionsParser()\n        });\n        Object.defineProperty(this, \"attrName\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.attrName = fields.attrName;\n    }\n    /**\n     * Parses the output and returns a specific attribute of the parsed JSON\n     * object.\n     * @param generations The output of the LLM to parse.\n     * @returns The value of a specific attribute of the parsed JSON object.\n     */\n    async parseResult(generations) {\n        const result = await this.outputParser.parseResult(generations);\n        return result[this.attrName];\n    }\n}\n"],"mappings":"AAAA,SAASA,OAAO,QAAS,kCAAkC;AAC3D,SAASC,mCAAmC,EAAEC,mBAAmB,EAAEC,qBAAqB,QAAS,gCAAgC;AACjI,SAASC,gBAAgB,QAAQ,gCAAgC;AACjE;AACA;AACA;AACA;AACA,OAAO,MAAMC,qBAAqB,SAASH,mBAAmB,CAAC;EAC3D,OAAOI,OAAOA,CAAA,EAAG;IACb,OAAO,uBAAuB;EAClC;EACAC,WAAWA,CAACC,MAAM,EAAE;IAChB,KAAK,CAAC,CAAC;IACPC,MAAM,CAACC,cAAc,CAAC,IAAI,EAAE,cAAc,EAAE;MACxCC,UAAU,EAAE,IAAI;MAChBC,YAAY,EAAE,IAAI;MAClBC,QAAQ,EAAE,IAAI;MACdC,KAAK,EAAE,CAAC,WAAW,EAAE,gBAAgB,EAAE,kBAAkB;IAC7D,CAAC,CAAC;IACFL,MAAM,CAACC,cAAc,CAAC,IAAI,EAAE,iBAAiB,EAAE;MAC3CC,UAAU,EAAE,IAAI;MAChBC,YAAY,EAAE,IAAI;MAClBC,QAAQ,EAAE,IAAI;MACdC,KAAK,EAAE;IACX,CAAC,CAAC;IACFL,MAAM,CAACC,cAAc,CAAC,IAAI,EAAE,UAAU,EAAE;MACpCC,UAAU,EAAE,IAAI;MAChBC,YAAY,EAAE,IAAI;MAClBC,QAAQ,EAAE,IAAI;MACdC,KAAK,EAAE;IACX,CAAC,CAAC;IACF,IAAI,CAACC,QAAQ,GAAGP,MAAM,EAAEO,QAAQ,IAAI,IAAI,CAACA,QAAQ;EACrD;EACA;AACJ;AACA;AACA;AACA;AACA;EACI,MAAMC,WAAWA,CAACC,WAAW,EAAE;IAC3B,IAAI,SAAS,IAAIA,WAAW,CAAC,CAAC,CAAC,EAAE;MAC7B,MAAMC,GAAG,GAAGD,WAAW,CAAC,CAAC,CAAC;MAC1B,MAAME,YAAY,GAAGD,GAAG,CAACE,OAAO,CAACC,iBAAiB,CAACC,aAAa;MAChE,IAAI,CAACH,YAAY,EAAE;QACf,MAAM,IAAII,KAAK,CAAC,+BAA+BC,IAAI,CAACC,SAAS,CAACR,WAAW,CAAC,EAAE,CAAC;MACjF;MACA,IAAI,CAACE,YAAY,CAACO,SAAS,EAAE;QACzB,MAAM,IAAIH,KAAK,CAAC,iCAAiCC,IAAI,CAACC,SAAS,CAACR,WAAW,CAAC,EAAE,CAAC;MACnF;MACA,IAAI,IAAI,CAACF,QAAQ,EAAE;QACf,OAAOI,YAAY,CAACO,SAAS;MACjC;MACA,OAAOF,IAAI,CAACC,SAAS,CAACN,YAAY,CAAC;IACvC,CAAC,MACI;MACD,MAAM,IAAII,KAAK,CAAC,6BAA6BC,IAAI,CAACC,SAAS,CAACR,WAAW,CAAC,EAAE,CAAC;IAC/E;EACJ;AACJ;AACA;AACA;AACA;AACA;AACA,OAAO,MAAMU,yBAAyB,SAAS1B,mCAAmC,CAAC;EAC/E,OAAOK,OAAOA,CAAA,EAAG;IACb,OAAO,2BAA2B;EACtC;EACAC,WAAWA,CAACC,MAAM,EAAE;IAChB,KAAK,CAACA,MAAM,CAAC;IACbC,MAAM,CAACC,cAAc,CAAC,IAAI,EAAE,cAAc,EAAE;MACxCC,UAAU,EAAE,IAAI;MAChBC,YAAY,EAAE,IAAI;MAClBC,QAAQ,EAAE,IAAI;MACdC,KAAK,EAAE,CAAC,WAAW,EAAE,gBAAgB,EAAE,kBAAkB;IAC7D,CAAC,CAAC;IACFL,MAAM,CAACC,cAAc,CAAC,IAAI,EAAE,iBAAiB,EAAE;MAC3CC,UAAU,EAAE,IAAI;MAChBC,YAAY,EAAE,IAAI;MAClBC,QAAQ,EAAE,IAAI;MACdC,KAAK,EAAE;IACX,CAAC,CAAC;IACFL,MAAM,CAACC,cAAc,CAAC,IAAI,EAAE,cAAc,EAAE;MACxCC,UAAU,EAAE,IAAI;MAChBC,YAAY,EAAE,IAAI;MAClBC,QAAQ,EAAE,IAAI;MACdC,KAAK,EAAE,KAAK;IAChB,CAAC,CAAC;IACFL,MAAM,CAACC,cAAc,CAAC,IAAI,EAAE,UAAU,EAAE;MACpCC,UAAU,EAAE,IAAI;MAChBC,YAAY,EAAE,IAAI;MAClBC,QAAQ,EAAE,IAAI;MACdC,KAAK,EAAE;IACX,CAAC,CAAC;IACF,IAAI,CAACC,QAAQ,GAAGP,MAAM,EAAEO,QAAQ,IAAI,IAAI,CAACA,QAAQ;IACjD,IAAI,CAACa,YAAY,GAAG,IAAIvB,qBAAqB,CAACG,MAAM,CAAC;EACzD;EACAqB,KAAKA,CAACC,IAAI,EAAEC,IAAI,EAAE;IACd,IAAI,CAACA,IAAI,EAAE;MACP,OAAOC,SAAS;IACpB;IACA,MAAMC,GAAG,GAAGjC,OAAO,CAAC8B,IAAI,IAAI,CAAC,CAAC,EAAEC,IAAI,CAAC;IACrC,OAAOE,GAAG;EACd;EACA,MAAMC,kBAAkBA,CAACjB,WAAW,EAAE;IAClC,MAAMkB,UAAU,GAAGlB,WAAW,CAAC,CAAC,CAAC;IACjC,IAAI,CAACkB,UAAU,CAACf,OAAO,EAAE;MACrB,OAAOY,SAAS;IACpB;IACA,MAAM;MAAEZ;IAAQ,CAAC,GAAGe,UAAU;IAC9B,MAAMhB,YAAY,GAAGC,OAAO,CAACC,iBAAiB,CAACC,aAAa;IAC5D,IAAI,CAACH,YAAY,EAAE;MACf,OAAOa,SAAS;IACpB;IACA,IAAI,IAAI,CAACjB,QAAQ,EAAE;MACf,OAAOX,gBAAgB,CAACe,YAAY,CAACO,SAAS,CAAC;IACnD;IACA,OAAO;MACH,GAAGP,YAAY;MACfO,SAAS,EAAEtB,gBAAgB,CAACe,YAAY,CAACO,SAAS;IACtD,CAAC;EACL;EACA;AACJ;AACA;AACA;AACA;AACA;EACI,MAAMV,WAAWA,CAACC,WAAW,EAAE;IAC3B,MAAMmB,MAAM,GAAG,MAAM,IAAI,CAACR,YAAY,CAACZ,WAAW,CAACC,WAAW,CAAC;IAC/D,IAAI,CAACmB,MAAM,EAAE;MACT,MAAM,IAAIb,KAAK,CAAC,0CAA0CC,IAAI,CAACC,SAAS,CAACR,WAAW,CAAC,EAAE,CAAC;IAC5F;IACA,OAAO,IAAI,CAACoB,KAAK,CAACD,MAAM,CAAC;EAC7B;EACA,MAAMC,KAAKA,CAACC,IAAI,EAAE;IACd,IAAI;MACA,MAAMC,YAAY,GAAGf,IAAI,CAACa,KAAK,CAACC,IAAI,CAAC;MACrC,IAAI,IAAI,CAACvB,QAAQ,EAAE;QACf,OAAOwB,YAAY;MACvB;MACAA,YAAY,CAACb,SAAS,GAAGF,IAAI,CAACa,KAAK,CAACE,YAAY,CAACb,SAAS,CAAC;MAC3D,OAAOa,YAAY;IACvB,CAAC,CACD,OAAOC,CAAC,EAAE;MACN,MAAM,IAAIrC,qBAAqB,CAAC,2BAA2BmC,IAAI,aAAaE,CAAC,EAAE,CAAC;IACpF;EACJ;EACAC,qBAAqBA,CAAA,EAAG;IACpB,OAAO,EAAE;EACb;AACJ;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,MAAMC,4BAA4B,SAASxC,mBAAmB,CAAC;EAClE,OAAOI,OAAOA,CAAA,EAAG;IACb,OAAO,8BAA8B;EACzC;EACA,IAAIqC,UAAUA,CAAA,EAAG;IACb,OAAO;MACHC,QAAQ,EAAE;IACd,CAAC;EACL;EACArC,WAAWA,CAACsC,MAAM,EAAE;IAChB,KAAK,CAACA,MAAM,CAAC;IACbpC,MAAM,CAACC,cAAc,CAAC,IAAI,EAAE,cAAc,EAAE;MACxCC,UAAU,EAAE,IAAI;MAChBC,YAAY,EAAE,IAAI;MAClBC,QAAQ,EAAE,IAAI;MACdC,KAAK,EAAE,CAAC,WAAW,EAAE,gBAAgB,EAAE,kBAAkB;IAC7D,CAAC,CAAC;IACFL,MAAM,CAACC,cAAc,CAAC,IAAI,EAAE,iBAAiB,EAAE;MAC3CC,UAAU,EAAE,IAAI;MAChBC,YAAY,EAAE,IAAI;MAClBC,QAAQ,EAAE,IAAI;MACdC,KAAK,EAAE;IACX,CAAC,CAAC;IACFL,MAAM,CAACC,cAAc,CAAC,IAAI,EAAE,cAAc,EAAE;MACxCC,UAAU,EAAE,IAAI;MAChBC,YAAY,EAAE,IAAI;MAClBC,QAAQ,EAAE,IAAI;MACdC,KAAK,EAAE,IAAIa,yBAAyB,CAAC;IACzC,CAAC,CAAC;IACFlB,MAAM,CAACC,cAAc,CAAC,IAAI,EAAE,UAAU,EAAE;MACpCC,UAAU,EAAE,IAAI;MAChBC,YAAY,EAAE,IAAI;MAClBC,QAAQ,EAAE,IAAI;MACdC,KAAK,EAAE,KAAK;IAChB,CAAC,CAAC;IACF,IAAI,CAAC8B,QAAQ,GAAGC,MAAM,CAACD,QAAQ;EACnC;EACA;AACJ;AACA;AACA;AACA;AACA;EACI,MAAM5B,WAAWA,CAACC,WAAW,EAAE;IAC3B,MAAMmB,MAAM,GAAG,MAAM,IAAI,CAACR,YAAY,CAACZ,WAAW,CAACC,WAAW,CAAC;IAC/D,OAAOmB,MAAM,CAAC,IAAI,CAACQ,QAAQ,CAAC;EAChC;AACJ","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}