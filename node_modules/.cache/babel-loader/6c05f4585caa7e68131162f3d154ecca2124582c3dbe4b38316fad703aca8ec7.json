{"ast":null,"code":"import { CallbackManager, ensureHandler } from \"../callbacks/manager.js\";\nimport { AsyncLocalStorageProviderSingleton } from \"../singletons/index.js\";\nexport const DEFAULT_RECURSION_LIMIT = 25;\nexport async function getCallbackManagerForConfig(config) {\n  return CallbackManager._configureSync(config?.callbacks, undefined, config?.tags, undefined, config?.metadata);\n}\nexport function mergeConfigs(...configs) {\n  // We do not want to call ensureConfig on the empty state here as this may cause\n  // double loading of callbacks if async local storage is being used.\n  const copy = {};\n  for (const options of configs.filter(c => !!c)) {\n    for (const key of Object.keys(options)) {\n      if (key === \"metadata\") {\n        copy[key] = {\n          ...copy[key],\n          ...options[key]\n        };\n      } else if (key === \"tags\") {\n        const baseKeys = copy[key] ?? [];\n        copy[key] = [...new Set(baseKeys.concat(options[key] ?? []))];\n      } else if (key === \"configurable\") {\n        copy[key] = {\n          ...copy[key],\n          ...options[key]\n        };\n      } else if (key === \"timeout\") {\n        if (copy.timeout === undefined) {\n          copy.timeout = options.timeout;\n        } else if (options.timeout !== undefined) {\n          copy.timeout = Math.min(copy.timeout, options.timeout);\n        }\n      } else if (key === \"signal\") {\n        if (copy.signal === undefined) {\n          copy.signal = options.signal;\n        } else if (options.signal !== undefined) {\n          if (\"any\" in AbortSignal) {\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n            copy.signal = AbortSignal.any([copy.signal, options.signal]);\n          } else {\n            copy.signal = options.signal;\n          }\n        }\n      } else if (key === \"callbacks\") {\n        const baseCallbacks = copy.callbacks;\n        const providedCallbacks = options.callbacks;\n        // callbacks can be either undefined, Array<handler> or manager\n        // so merging two callbacks values has 6 cases\n        if (Array.isArray(providedCallbacks)) {\n          if (!baseCallbacks) {\n            copy.callbacks = providedCallbacks;\n          } else if (Array.isArray(baseCallbacks)) {\n            copy.callbacks = baseCallbacks.concat(providedCallbacks);\n          } else {\n            // baseCallbacks is a manager\n            const manager = baseCallbacks.copy();\n            for (const callback of providedCallbacks) {\n              manager.addHandler(ensureHandler(callback), true);\n            }\n            copy.callbacks = manager;\n          }\n        } else if (providedCallbacks) {\n          // providedCallbacks is a manager\n          if (!baseCallbacks) {\n            copy.callbacks = providedCallbacks;\n          } else if (Array.isArray(baseCallbacks)) {\n            const manager = providedCallbacks.copy();\n            for (const callback of baseCallbacks) {\n              manager.addHandler(ensureHandler(callback), true);\n            }\n            copy.callbacks = manager;\n          } else {\n            // baseCallbacks is also a manager\n            copy.callbacks = new CallbackManager(providedCallbacks._parentRunId, {\n              handlers: baseCallbacks.handlers.concat(providedCallbacks.handlers),\n              inheritableHandlers: baseCallbacks.inheritableHandlers.concat(providedCallbacks.inheritableHandlers),\n              tags: Array.from(new Set(baseCallbacks.tags.concat(providedCallbacks.tags))),\n              inheritableTags: Array.from(new Set(baseCallbacks.inheritableTags.concat(providedCallbacks.inheritableTags))),\n              metadata: {\n                ...baseCallbacks.metadata,\n                ...providedCallbacks.metadata\n              }\n            });\n          }\n        }\n      } else {\n        const typedKey = key;\n        copy[typedKey] = options[typedKey] ?? copy[typedKey];\n      }\n    }\n  }\n  return copy;\n}\nconst PRIMITIVES = new Set([\"string\", \"number\", \"boolean\"]);\n/**\n * Ensure that a passed config is an object with all required keys present.\n */\nexport function ensureConfig(config) {\n  const implicitConfig = AsyncLocalStorageProviderSingleton.getRunnableConfig();\n  let empty = {\n    tags: [],\n    metadata: {},\n    recursionLimit: 25,\n    runId: undefined\n  };\n  if (implicitConfig) {\n    // Don't allow runId and runName to be loaded implicitly, as this can cause\n    // child runs to improperly inherit their parents' run ids.\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    const {\n      runId,\n      runName,\n      ...rest\n    } = implicitConfig;\n    empty = Object.entries(rest).reduce(\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    (currentConfig, [key, value]) => {\n      if (value !== undefined) {\n        // eslint-disable-next-line no-param-reassign\n        currentConfig[key] = value;\n      }\n      return currentConfig;\n    }, empty);\n  }\n  if (config) {\n    empty = Object.entries(config).reduce(\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    (currentConfig, [key, value]) => {\n      if (value !== undefined) {\n        // eslint-disable-next-line no-param-reassign\n        currentConfig[key] = value;\n      }\n      return currentConfig;\n    }, empty);\n  }\n  if (empty?.configurable) {\n    for (const key of Object.keys(empty.configurable)) {\n      if (PRIMITIVES.has(typeof empty.configurable[key]) && !empty.metadata?.[key]) {\n        if (!empty.metadata) {\n          empty.metadata = {};\n        }\n        empty.metadata[key] = empty.configurable[key];\n      }\n    }\n  }\n  if (empty.timeout !== undefined) {\n    if (empty.timeout <= 0) {\n      throw new Error(\"Timeout must be a positive number\");\n    }\n    const timeoutSignal = AbortSignal.timeout(empty.timeout);\n    if (empty.signal !== undefined) {\n      if (\"any\" in AbortSignal) {\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        empty.signal = AbortSignal.any([empty.signal, timeoutSignal]);\n      }\n    } else {\n      empty.signal = timeoutSignal;\n    }\n    delete empty.timeout;\n  }\n  return empty;\n}\n/**\n * Helper function that patches runnable configs with updated properties.\n */\nexport function patchConfig(config = {}, {\n  callbacks,\n  maxConcurrency,\n  recursionLimit,\n  runName,\n  configurable,\n  runId\n} = {}) {\n  const newConfig = ensureConfig(config);\n  if (callbacks !== undefined) {\n    /**\n     * If we're replacing callbacks we need to unset runName\n     * since that should apply only to the same run as the original callbacks\n     */\n    delete newConfig.runName;\n    newConfig.callbacks = callbacks;\n  }\n  if (recursionLimit !== undefined) {\n    newConfig.recursionLimit = recursionLimit;\n  }\n  if (maxConcurrency !== undefined) {\n    newConfig.maxConcurrency = maxConcurrency;\n  }\n  if (runName !== undefined) {\n    newConfig.runName = runName;\n  }\n  if (configurable !== undefined) {\n    newConfig.configurable = {\n      ...newConfig.configurable,\n      ...configurable\n    };\n  }\n  if (runId !== undefined) {\n    delete newConfig.runId;\n  }\n  return newConfig;\n}\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport function pickRunnableConfigKeys(config) {\n  return config ? {\n    configurable: config.configurable,\n    recursionLimit: config.recursionLimit,\n    callbacks: config.callbacks,\n    tags: config.tags,\n    metadata: config.metadata,\n    maxConcurrency: config.maxConcurrency,\n    timeout: config.timeout,\n    signal: config.signal\n  } : undefined;\n}","map":{"version":3,"names":["CallbackManager","ensureHandler","AsyncLocalStorageProviderSingleton","DEFAULT_RECURSION_LIMIT","getCallbackManagerForConfig","config","_configureSync","callbacks","undefined","tags","metadata","mergeConfigs","configs","copy","options","filter","c","key","Object","keys","baseKeys","Set","concat","timeout","Math","min","signal","AbortSignal","any","baseCallbacks","providedCallbacks","Array","isArray","manager","callback","addHandler","_parentRunId","handlers","inheritableHandlers","from","inheritableTags","typedKey","PRIMITIVES","ensureConfig","implicitConfig","getRunnableConfig","empty","recursionLimit","runId","runName","rest","entries","reduce","currentConfig","value","configurable","has","Error","timeoutSignal","patchConfig","maxConcurrency","newConfig","pickRunnableConfigKeys"],"sources":["/Users/youngchen/Downloads/cs224g-triage/node_modules/@langchain/core/dist/runnables/config.js"],"sourcesContent":["import { CallbackManager, ensureHandler } from \"../callbacks/manager.js\";\nimport { AsyncLocalStorageProviderSingleton } from \"../singletons/index.js\";\nexport const DEFAULT_RECURSION_LIMIT = 25;\nexport async function getCallbackManagerForConfig(config) {\n    return CallbackManager._configureSync(config?.callbacks, undefined, config?.tags, undefined, config?.metadata);\n}\nexport function mergeConfigs(...configs) {\n    // We do not want to call ensureConfig on the empty state here as this may cause\n    // double loading of callbacks if async local storage is being used.\n    const copy = {};\n    for (const options of configs.filter((c) => !!c)) {\n        for (const key of Object.keys(options)) {\n            if (key === \"metadata\") {\n                copy[key] = { ...copy[key], ...options[key] };\n            }\n            else if (key === \"tags\") {\n                const baseKeys = copy[key] ?? [];\n                copy[key] = [...new Set(baseKeys.concat(options[key] ?? []))];\n            }\n            else if (key === \"configurable\") {\n                copy[key] = { ...copy[key], ...options[key] };\n            }\n            else if (key === \"timeout\") {\n                if (copy.timeout === undefined) {\n                    copy.timeout = options.timeout;\n                }\n                else if (options.timeout !== undefined) {\n                    copy.timeout = Math.min(copy.timeout, options.timeout);\n                }\n            }\n            else if (key === \"signal\") {\n                if (copy.signal === undefined) {\n                    copy.signal = options.signal;\n                }\n                else if (options.signal !== undefined) {\n                    if (\"any\" in AbortSignal) {\n                        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n                        copy.signal = AbortSignal.any([\n                            copy.signal,\n                            options.signal,\n                        ]);\n                    }\n                    else {\n                        copy.signal = options.signal;\n                    }\n                }\n            }\n            else if (key === \"callbacks\") {\n                const baseCallbacks = copy.callbacks;\n                const providedCallbacks = options.callbacks;\n                // callbacks can be either undefined, Array<handler> or manager\n                // so merging two callbacks values has 6 cases\n                if (Array.isArray(providedCallbacks)) {\n                    if (!baseCallbacks) {\n                        copy.callbacks = providedCallbacks;\n                    }\n                    else if (Array.isArray(baseCallbacks)) {\n                        copy.callbacks = baseCallbacks.concat(providedCallbacks);\n                    }\n                    else {\n                        // baseCallbacks is a manager\n                        const manager = baseCallbacks.copy();\n                        for (const callback of providedCallbacks) {\n                            manager.addHandler(ensureHandler(callback), true);\n                        }\n                        copy.callbacks = manager;\n                    }\n                }\n                else if (providedCallbacks) {\n                    // providedCallbacks is a manager\n                    if (!baseCallbacks) {\n                        copy.callbacks = providedCallbacks;\n                    }\n                    else if (Array.isArray(baseCallbacks)) {\n                        const manager = providedCallbacks.copy();\n                        for (const callback of baseCallbacks) {\n                            manager.addHandler(ensureHandler(callback), true);\n                        }\n                        copy.callbacks = manager;\n                    }\n                    else {\n                        // baseCallbacks is also a manager\n                        copy.callbacks = new CallbackManager(providedCallbacks._parentRunId, {\n                            handlers: baseCallbacks.handlers.concat(providedCallbacks.handlers),\n                            inheritableHandlers: baseCallbacks.inheritableHandlers.concat(providedCallbacks.inheritableHandlers),\n                            tags: Array.from(new Set(baseCallbacks.tags.concat(providedCallbacks.tags))),\n                            inheritableTags: Array.from(new Set(baseCallbacks.inheritableTags.concat(providedCallbacks.inheritableTags))),\n                            metadata: {\n                                ...baseCallbacks.metadata,\n                                ...providedCallbacks.metadata,\n                            },\n                        });\n                    }\n                }\n            }\n            else {\n                const typedKey = key;\n                copy[typedKey] = options[typedKey] ?? copy[typedKey];\n            }\n        }\n    }\n    return copy;\n}\nconst PRIMITIVES = new Set([\"string\", \"number\", \"boolean\"]);\n/**\n * Ensure that a passed config is an object with all required keys present.\n */\nexport function ensureConfig(config) {\n    const implicitConfig = AsyncLocalStorageProviderSingleton.getRunnableConfig();\n    let empty = {\n        tags: [],\n        metadata: {},\n        recursionLimit: 25,\n        runId: undefined,\n    };\n    if (implicitConfig) {\n        // Don't allow runId and runName to be loaded implicitly, as this can cause\n        // child runs to improperly inherit their parents' run ids.\n        // eslint-disable-next-line @typescript-eslint/no-unused-vars\n        const { runId, runName, ...rest } = implicitConfig;\n        empty = Object.entries(rest).reduce(\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        (currentConfig, [key, value]) => {\n            if (value !== undefined) {\n                // eslint-disable-next-line no-param-reassign\n                currentConfig[key] = value;\n            }\n            return currentConfig;\n        }, empty);\n    }\n    if (config) {\n        empty = Object.entries(config).reduce(\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        (currentConfig, [key, value]) => {\n            if (value !== undefined) {\n                // eslint-disable-next-line no-param-reassign\n                currentConfig[key] = value;\n            }\n            return currentConfig;\n        }, empty);\n    }\n    if (empty?.configurable) {\n        for (const key of Object.keys(empty.configurable)) {\n            if (PRIMITIVES.has(typeof empty.configurable[key]) &&\n                !empty.metadata?.[key]) {\n                if (!empty.metadata) {\n                    empty.metadata = {};\n                }\n                empty.metadata[key] = empty.configurable[key];\n            }\n        }\n    }\n    if (empty.timeout !== undefined) {\n        if (empty.timeout <= 0) {\n            throw new Error(\"Timeout must be a positive number\");\n        }\n        const timeoutSignal = AbortSignal.timeout(empty.timeout);\n        if (empty.signal !== undefined) {\n            if (\"any\" in AbortSignal) {\n                // eslint-disable-next-line @typescript-eslint/no-explicit-any\n                empty.signal = AbortSignal.any([empty.signal, timeoutSignal]);\n            }\n        }\n        else {\n            empty.signal = timeoutSignal;\n        }\n        delete empty.timeout;\n    }\n    return empty;\n}\n/**\n * Helper function that patches runnable configs with updated properties.\n */\nexport function patchConfig(config = {}, { callbacks, maxConcurrency, recursionLimit, runName, configurable, runId, } = {}) {\n    const newConfig = ensureConfig(config);\n    if (callbacks !== undefined) {\n        /**\n         * If we're replacing callbacks we need to unset runName\n         * since that should apply only to the same run as the original callbacks\n         */\n        delete newConfig.runName;\n        newConfig.callbacks = callbacks;\n    }\n    if (recursionLimit !== undefined) {\n        newConfig.recursionLimit = recursionLimit;\n    }\n    if (maxConcurrency !== undefined) {\n        newConfig.maxConcurrency = maxConcurrency;\n    }\n    if (runName !== undefined) {\n        newConfig.runName = runName;\n    }\n    if (configurable !== undefined) {\n        newConfig.configurable = { ...newConfig.configurable, ...configurable };\n    }\n    if (runId !== undefined) {\n        delete newConfig.runId;\n    }\n    return newConfig;\n}\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport function pickRunnableConfigKeys(config) {\n    return config\n        ? {\n            configurable: config.configurable,\n            recursionLimit: config.recursionLimit,\n            callbacks: config.callbacks,\n            tags: config.tags,\n            metadata: config.metadata,\n            maxConcurrency: config.maxConcurrency,\n            timeout: config.timeout,\n            signal: config.signal,\n        }\n        : undefined;\n}\n"],"mappings":"AAAA,SAASA,eAAe,EAAEC,aAAa,QAAQ,yBAAyB;AACxE,SAASC,kCAAkC,QAAQ,wBAAwB;AAC3E,OAAO,MAAMC,uBAAuB,GAAG,EAAE;AACzC,OAAO,eAAeC,2BAA2BA,CAACC,MAAM,EAAE;EACtD,OAAOL,eAAe,CAACM,cAAc,CAACD,MAAM,EAAEE,SAAS,EAAEC,SAAS,EAAEH,MAAM,EAAEI,IAAI,EAAED,SAAS,EAAEH,MAAM,EAAEK,QAAQ,CAAC;AAClH;AACA,OAAO,SAASC,YAAYA,CAAC,GAAGC,OAAO,EAAE;EACrC;EACA;EACA,MAAMC,IAAI,GAAG,CAAC,CAAC;EACf,KAAK,MAAMC,OAAO,IAAIF,OAAO,CAACG,MAAM,CAAEC,CAAC,IAAK,CAAC,CAACA,CAAC,CAAC,EAAE;IAC9C,KAAK,MAAMC,GAAG,IAAIC,MAAM,CAACC,IAAI,CAACL,OAAO,CAAC,EAAE;MACpC,IAAIG,GAAG,KAAK,UAAU,EAAE;QACpBJ,IAAI,CAACI,GAAG,CAAC,GAAG;UAAE,GAAGJ,IAAI,CAACI,GAAG,CAAC;UAAE,GAAGH,OAAO,CAACG,GAAG;QAAE,CAAC;MACjD,CAAC,MACI,IAAIA,GAAG,KAAK,MAAM,EAAE;QACrB,MAAMG,QAAQ,GAAGP,IAAI,CAACI,GAAG,CAAC,IAAI,EAAE;QAChCJ,IAAI,CAACI,GAAG,CAAC,GAAG,CAAC,GAAG,IAAII,GAAG,CAACD,QAAQ,CAACE,MAAM,CAACR,OAAO,CAACG,GAAG,CAAC,IAAI,EAAE,CAAC,CAAC,CAAC;MACjE,CAAC,MACI,IAAIA,GAAG,KAAK,cAAc,EAAE;QAC7BJ,IAAI,CAACI,GAAG,CAAC,GAAG;UAAE,GAAGJ,IAAI,CAACI,GAAG,CAAC;UAAE,GAAGH,OAAO,CAACG,GAAG;QAAE,CAAC;MACjD,CAAC,MACI,IAAIA,GAAG,KAAK,SAAS,EAAE;QACxB,IAAIJ,IAAI,CAACU,OAAO,KAAKf,SAAS,EAAE;UAC5BK,IAAI,CAACU,OAAO,GAAGT,OAAO,CAACS,OAAO;QAClC,CAAC,MACI,IAAIT,OAAO,CAACS,OAAO,KAAKf,SAAS,EAAE;UACpCK,IAAI,CAACU,OAAO,GAAGC,IAAI,CAACC,GAAG,CAACZ,IAAI,CAACU,OAAO,EAAET,OAAO,CAACS,OAAO,CAAC;QAC1D;MACJ,CAAC,MACI,IAAIN,GAAG,KAAK,QAAQ,EAAE;QACvB,IAAIJ,IAAI,CAACa,MAAM,KAAKlB,SAAS,EAAE;UAC3BK,IAAI,CAACa,MAAM,GAAGZ,OAAO,CAACY,MAAM;QAChC,CAAC,MACI,IAAIZ,OAAO,CAACY,MAAM,KAAKlB,SAAS,EAAE;UACnC,IAAI,KAAK,IAAImB,WAAW,EAAE;YACtB;YACAd,IAAI,CAACa,MAAM,GAAGC,WAAW,CAACC,GAAG,CAAC,CAC1Bf,IAAI,CAACa,MAAM,EACXZ,OAAO,CAACY,MAAM,CACjB,CAAC;UACN,CAAC,MACI;YACDb,IAAI,CAACa,MAAM,GAAGZ,OAAO,CAACY,MAAM;UAChC;QACJ;MACJ,CAAC,MACI,IAAIT,GAAG,KAAK,WAAW,EAAE;QAC1B,MAAMY,aAAa,GAAGhB,IAAI,CAACN,SAAS;QACpC,MAAMuB,iBAAiB,GAAGhB,OAAO,CAACP,SAAS;QAC3C;QACA;QACA,IAAIwB,KAAK,CAACC,OAAO,CAACF,iBAAiB,CAAC,EAAE;UAClC,IAAI,CAACD,aAAa,EAAE;YAChBhB,IAAI,CAACN,SAAS,GAAGuB,iBAAiB;UACtC,CAAC,MACI,IAAIC,KAAK,CAACC,OAAO,CAACH,aAAa,CAAC,EAAE;YACnChB,IAAI,CAACN,SAAS,GAAGsB,aAAa,CAACP,MAAM,CAACQ,iBAAiB,CAAC;UAC5D,CAAC,MACI;YACD;YACA,MAAMG,OAAO,GAAGJ,aAAa,CAAChB,IAAI,CAAC,CAAC;YACpC,KAAK,MAAMqB,QAAQ,IAAIJ,iBAAiB,EAAE;cACtCG,OAAO,CAACE,UAAU,CAAClC,aAAa,CAACiC,QAAQ,CAAC,EAAE,IAAI,CAAC;YACrD;YACArB,IAAI,CAACN,SAAS,GAAG0B,OAAO;UAC5B;QACJ,CAAC,MACI,IAAIH,iBAAiB,EAAE;UACxB;UACA,IAAI,CAACD,aAAa,EAAE;YAChBhB,IAAI,CAACN,SAAS,GAAGuB,iBAAiB;UACtC,CAAC,MACI,IAAIC,KAAK,CAACC,OAAO,CAACH,aAAa,CAAC,EAAE;YACnC,MAAMI,OAAO,GAAGH,iBAAiB,CAACjB,IAAI,CAAC,CAAC;YACxC,KAAK,MAAMqB,QAAQ,IAAIL,aAAa,EAAE;cAClCI,OAAO,CAACE,UAAU,CAAClC,aAAa,CAACiC,QAAQ,CAAC,EAAE,IAAI,CAAC;YACrD;YACArB,IAAI,CAACN,SAAS,GAAG0B,OAAO;UAC5B,CAAC,MACI;YACD;YACApB,IAAI,CAACN,SAAS,GAAG,IAAIP,eAAe,CAAC8B,iBAAiB,CAACM,YAAY,EAAE;cACjEC,QAAQ,EAAER,aAAa,CAACQ,QAAQ,CAACf,MAAM,CAACQ,iBAAiB,CAACO,QAAQ,CAAC;cACnEC,mBAAmB,EAAET,aAAa,CAACS,mBAAmB,CAAChB,MAAM,CAACQ,iBAAiB,CAACQ,mBAAmB,CAAC;cACpG7B,IAAI,EAAEsB,KAAK,CAACQ,IAAI,CAAC,IAAIlB,GAAG,CAACQ,aAAa,CAACpB,IAAI,CAACa,MAAM,CAACQ,iBAAiB,CAACrB,IAAI,CAAC,CAAC,CAAC;cAC5E+B,eAAe,EAAET,KAAK,CAACQ,IAAI,CAAC,IAAIlB,GAAG,CAACQ,aAAa,CAACW,eAAe,CAAClB,MAAM,CAACQ,iBAAiB,CAACU,eAAe,CAAC,CAAC,CAAC;cAC7G9B,QAAQ,EAAE;gBACN,GAAGmB,aAAa,CAACnB,QAAQ;gBACzB,GAAGoB,iBAAiB,CAACpB;cACzB;YACJ,CAAC,CAAC;UACN;QACJ;MACJ,CAAC,MACI;QACD,MAAM+B,QAAQ,GAAGxB,GAAG;QACpBJ,IAAI,CAAC4B,QAAQ,CAAC,GAAG3B,OAAO,CAAC2B,QAAQ,CAAC,IAAI5B,IAAI,CAAC4B,QAAQ,CAAC;MACxD;IACJ;EACJ;EACA,OAAO5B,IAAI;AACf;AACA,MAAM6B,UAAU,GAAG,IAAIrB,GAAG,CAAC,CAAC,QAAQ,EAAE,QAAQ,EAAE,SAAS,CAAC,CAAC;AAC3D;AACA;AACA;AACA,OAAO,SAASsB,YAAYA,CAACtC,MAAM,EAAE;EACjC,MAAMuC,cAAc,GAAG1C,kCAAkC,CAAC2C,iBAAiB,CAAC,CAAC;EAC7E,IAAIC,KAAK,GAAG;IACRrC,IAAI,EAAE,EAAE;IACRC,QAAQ,EAAE,CAAC,CAAC;IACZqC,cAAc,EAAE,EAAE;IAClBC,KAAK,EAAExC;EACX,CAAC;EACD,IAAIoC,cAAc,EAAE;IAChB;IACA;IACA;IACA,MAAM;MAAEI,KAAK;MAAEC,OAAO;MAAE,GAAGC;IAAK,CAAC,GAAGN,cAAc;IAClDE,KAAK,GAAG5B,MAAM,CAACiC,OAAO,CAACD,IAAI,CAAC,CAACE,MAAM;IACnC;IACA,CAACC,aAAa,EAAE,CAACpC,GAAG,EAAEqC,KAAK,CAAC,KAAK;MAC7B,IAAIA,KAAK,KAAK9C,SAAS,EAAE;QACrB;QACA6C,aAAa,CAACpC,GAAG,CAAC,GAAGqC,KAAK;MAC9B;MACA,OAAOD,aAAa;IACxB,CAAC,EAAEP,KAAK,CAAC;EACb;EACA,IAAIzC,MAAM,EAAE;IACRyC,KAAK,GAAG5B,MAAM,CAACiC,OAAO,CAAC9C,MAAM,CAAC,CAAC+C,MAAM;IACrC;IACA,CAACC,aAAa,EAAE,CAACpC,GAAG,EAAEqC,KAAK,CAAC,KAAK;MAC7B,IAAIA,KAAK,KAAK9C,SAAS,EAAE;QACrB;QACA6C,aAAa,CAACpC,GAAG,CAAC,GAAGqC,KAAK;MAC9B;MACA,OAAOD,aAAa;IACxB,CAAC,EAAEP,KAAK,CAAC;EACb;EACA,IAAIA,KAAK,EAAES,YAAY,EAAE;IACrB,KAAK,MAAMtC,GAAG,IAAIC,MAAM,CAACC,IAAI,CAAC2B,KAAK,CAACS,YAAY,CAAC,EAAE;MAC/C,IAAIb,UAAU,CAACc,GAAG,CAAC,OAAOV,KAAK,CAACS,YAAY,CAACtC,GAAG,CAAC,CAAC,IAC9C,CAAC6B,KAAK,CAACpC,QAAQ,GAAGO,GAAG,CAAC,EAAE;QACxB,IAAI,CAAC6B,KAAK,CAACpC,QAAQ,EAAE;UACjBoC,KAAK,CAACpC,QAAQ,GAAG,CAAC,CAAC;QACvB;QACAoC,KAAK,CAACpC,QAAQ,CAACO,GAAG,CAAC,GAAG6B,KAAK,CAACS,YAAY,CAACtC,GAAG,CAAC;MACjD;IACJ;EACJ;EACA,IAAI6B,KAAK,CAACvB,OAAO,KAAKf,SAAS,EAAE;IAC7B,IAAIsC,KAAK,CAACvB,OAAO,IAAI,CAAC,EAAE;MACpB,MAAM,IAAIkC,KAAK,CAAC,mCAAmC,CAAC;IACxD;IACA,MAAMC,aAAa,GAAG/B,WAAW,CAACJ,OAAO,CAACuB,KAAK,CAACvB,OAAO,CAAC;IACxD,IAAIuB,KAAK,CAACpB,MAAM,KAAKlB,SAAS,EAAE;MAC5B,IAAI,KAAK,IAAImB,WAAW,EAAE;QACtB;QACAmB,KAAK,CAACpB,MAAM,GAAGC,WAAW,CAACC,GAAG,CAAC,CAACkB,KAAK,CAACpB,MAAM,EAAEgC,aAAa,CAAC,CAAC;MACjE;IACJ,CAAC,MACI;MACDZ,KAAK,CAACpB,MAAM,GAAGgC,aAAa;IAChC;IACA,OAAOZ,KAAK,CAACvB,OAAO;EACxB;EACA,OAAOuB,KAAK;AAChB;AACA;AACA;AACA;AACA,OAAO,SAASa,WAAWA,CAACtD,MAAM,GAAG,CAAC,CAAC,EAAE;EAAEE,SAAS;EAAEqD,cAAc;EAAEb,cAAc;EAAEE,OAAO;EAAEM,YAAY;EAAEP;AAAO,CAAC,GAAG,CAAC,CAAC,EAAE;EACxH,MAAMa,SAAS,GAAGlB,YAAY,CAACtC,MAAM,CAAC;EACtC,IAAIE,SAAS,KAAKC,SAAS,EAAE;IACzB;AACR;AACA;AACA;IACQ,OAAOqD,SAAS,CAACZ,OAAO;IACxBY,SAAS,CAACtD,SAAS,GAAGA,SAAS;EACnC;EACA,IAAIwC,cAAc,KAAKvC,SAAS,EAAE;IAC9BqD,SAAS,CAACd,cAAc,GAAGA,cAAc;EAC7C;EACA,IAAIa,cAAc,KAAKpD,SAAS,EAAE;IAC9BqD,SAAS,CAACD,cAAc,GAAGA,cAAc;EAC7C;EACA,IAAIX,OAAO,KAAKzC,SAAS,EAAE;IACvBqD,SAAS,CAACZ,OAAO,GAAGA,OAAO;EAC/B;EACA,IAAIM,YAAY,KAAK/C,SAAS,EAAE;IAC5BqD,SAAS,CAACN,YAAY,GAAG;MAAE,GAAGM,SAAS,CAACN,YAAY;MAAE,GAAGA;IAAa,CAAC;EAC3E;EACA,IAAIP,KAAK,KAAKxC,SAAS,EAAE;IACrB,OAAOqD,SAAS,CAACb,KAAK;EAC1B;EACA,OAAOa,SAAS;AACpB;AACA;AACA,OAAO,SAASC,sBAAsBA,CAACzD,MAAM,EAAE;EAC3C,OAAOA,MAAM,GACP;IACEkD,YAAY,EAAElD,MAAM,CAACkD,YAAY;IACjCR,cAAc,EAAE1C,MAAM,CAAC0C,cAAc;IACrCxC,SAAS,EAAEF,MAAM,CAACE,SAAS;IAC3BE,IAAI,EAAEJ,MAAM,CAACI,IAAI;IACjBC,QAAQ,EAAEL,MAAM,CAACK,QAAQ;IACzBkD,cAAc,EAAEvD,MAAM,CAACuD,cAAc;IACrCrC,OAAO,EAAElB,MAAM,CAACkB,OAAO;IACvBG,MAAM,EAAErB,MAAM,CAACqB;EACnB,CAAC,GACClB,SAAS;AACnB","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}