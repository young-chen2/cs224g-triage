{"ast":null,"code":"import { BasePromptTemplate } from \"./base.js\";\nimport { ChatPromptTemplate } from \"./chat.js\";\n/**\n * Class that handles a sequence of prompts, each of which may require\n * different input variables. Includes methods for formatting these\n * prompts, extracting required input values, and handling partial\n * prompts.\n * @example\n * ```typescript\n * const composedPrompt = new PipelinePromptTemplate({\n *   pipelinePrompts: [\n *     {\n *       name: \"introduction\",\n *       prompt: PromptTemplate.fromTemplate(`You are impersonating {person}.`),\n *     },\n *     {\n *       name: \"example\",\n *       prompt: PromptTemplate.fromTemplate(\n *         `Here's an example of an interaction:\n * Q: {example_q}\n * A: {example_a}`,\n *       ),\n *     },\n *     {\n *       name: \"start\",\n *       prompt: PromptTemplate.fromTemplate(\n *         `Now, do this for real!\n * Q: {input}\n * A:`,\n *       ),\n *     },\n *   ],\n *   finalPrompt: PromptTemplate.fromTemplate(\n *     `{introduction}\n * {example}\n * {start}`,\n *   ),\n * });\n *\n * const formattedPrompt = await composedPrompt.format({\n *   person: \"Elon Musk\",\n *   example_q: `What's your favorite car?`,\n *   example_a: \"Tesla\",\n *   input: `What's your favorite social media site?`,\n * });\n * ```\n */\nexport class PipelinePromptTemplate extends BasePromptTemplate {\n  static lc_name() {\n    return \"PipelinePromptTemplate\";\n  }\n  constructor(input) {\n    super({\n      ...input,\n      inputVariables: []\n    });\n    Object.defineProperty(this, \"pipelinePrompts\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, \"finalPrompt\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    this.pipelinePrompts = input.pipelinePrompts;\n    this.finalPrompt = input.finalPrompt;\n    this.inputVariables = this.computeInputValues();\n  }\n  /**\n   * Computes the input values required by the pipeline prompts.\n   * @returns Array of input values required by the pipeline prompts.\n   */\n  computeInputValues() {\n    const intermediateValues = this.pipelinePrompts.map(pipelinePrompt => pipelinePrompt.name);\n    const inputValues = this.pipelinePrompts.map(pipelinePrompt => pipelinePrompt.prompt.inputVariables.filter(inputValue => !intermediateValues.includes(inputValue))).flat();\n    return [...new Set(inputValues)];\n  }\n  static extractRequiredInputValues(allValues, requiredValueNames) {\n    return requiredValueNames.reduce((requiredValues, valueName) => {\n      // eslint-disable-next-line no-param-reassign\n      requiredValues[valueName] = allValues[valueName];\n      return requiredValues;\n    }, {});\n  }\n  /**\n   * Formats the pipeline prompts based on the provided input values.\n   * @param values Input values to format the pipeline prompts.\n   * @returns Promise that resolves with the formatted input values.\n   */\n  async formatPipelinePrompts(values) {\n    const allValues = await this.mergePartialAndUserVariables(values);\n    for (const {\n      name: pipelinePromptName,\n      prompt: pipelinePrompt\n    } of this.pipelinePrompts) {\n      const pipelinePromptInputValues = PipelinePromptTemplate.extractRequiredInputValues(allValues, pipelinePrompt.inputVariables);\n      // eslint-disable-next-line no-instanceof/no-instanceof\n      if (pipelinePrompt instanceof ChatPromptTemplate) {\n        allValues[pipelinePromptName] = await pipelinePrompt.formatMessages(pipelinePromptInputValues);\n      } else {\n        allValues[pipelinePromptName] = await pipelinePrompt.format(pipelinePromptInputValues);\n      }\n    }\n    return PipelinePromptTemplate.extractRequiredInputValues(allValues, this.finalPrompt.inputVariables);\n  }\n  /**\n   * Formats the final prompt value based on the provided input values.\n   * @param values Input values to format the final prompt value.\n   * @returns Promise that resolves with the formatted final prompt value.\n   */\n  async formatPromptValue(values) {\n    return this.finalPrompt.formatPromptValue(await this.formatPipelinePrompts(values));\n  }\n  async format(values) {\n    return this.finalPrompt.format(await this.formatPipelinePrompts(values));\n  }\n  /**\n   * Handles partial prompts, which are prompts that have been partially\n   * filled with input values.\n   * @param values Partial input values.\n   * @returns Promise that resolves with a new PipelinePromptTemplate instance with updated input variables.\n   */\n  async partial(values) {\n    const promptDict = {\n      ...this\n    };\n    promptDict.inputVariables = this.inputVariables.filter(iv => !(iv in values));\n    promptDict.partialVariables = {\n      ...(this.partialVariables ?? {}),\n      ...values\n    };\n    return new PipelinePromptTemplate(promptDict);\n  }\n  serialize() {\n    throw new Error(\"Not implemented.\");\n  }\n  _getPromptType() {\n    return \"pipeline\";\n  }\n}","map":{"version":3,"names":["BasePromptTemplate","ChatPromptTemplate","PipelinePromptTemplate","lc_name","constructor","input","inputVariables","Object","defineProperty","enumerable","configurable","writable","value","pipelinePrompts","finalPrompt","computeInputValues","intermediateValues","map","pipelinePrompt","name","inputValues","prompt","filter","inputValue","includes","flat","Set","extractRequiredInputValues","allValues","requiredValueNames","reduce","requiredValues","valueName","formatPipelinePrompts","values","mergePartialAndUserVariables","pipelinePromptName","pipelinePromptInputValues","formatMessages","format","formatPromptValue","partial","promptDict","iv","partialVariables","serialize","Error","_getPromptType"],"sources":["/Users/youngchen/Downloads/cs224g-triage/node_modules/@langchain/core/dist/prompts/pipeline.js"],"sourcesContent":["import { BasePromptTemplate } from \"./base.js\";\nimport { ChatPromptTemplate } from \"./chat.js\";\n/**\n * Class that handles a sequence of prompts, each of which may require\n * different input variables. Includes methods for formatting these\n * prompts, extracting required input values, and handling partial\n * prompts.\n * @example\n * ```typescript\n * const composedPrompt = new PipelinePromptTemplate({\n *   pipelinePrompts: [\n *     {\n *       name: \"introduction\",\n *       prompt: PromptTemplate.fromTemplate(`You are impersonating {person}.`),\n *     },\n *     {\n *       name: \"example\",\n *       prompt: PromptTemplate.fromTemplate(\n *         `Here's an example of an interaction:\n * Q: {example_q}\n * A: {example_a}`,\n *       ),\n *     },\n *     {\n *       name: \"start\",\n *       prompt: PromptTemplate.fromTemplate(\n *         `Now, do this for real!\n * Q: {input}\n * A:`,\n *       ),\n *     },\n *   ],\n *   finalPrompt: PromptTemplate.fromTemplate(\n *     `{introduction}\n * {example}\n * {start}`,\n *   ),\n * });\n *\n * const formattedPrompt = await composedPrompt.format({\n *   person: \"Elon Musk\",\n *   example_q: `What's your favorite car?`,\n *   example_a: \"Tesla\",\n *   input: `What's your favorite social media site?`,\n * });\n * ```\n */\nexport class PipelinePromptTemplate extends BasePromptTemplate {\n    static lc_name() {\n        return \"PipelinePromptTemplate\";\n    }\n    constructor(input) {\n        super({ ...input, inputVariables: [] });\n        Object.defineProperty(this, \"pipelinePrompts\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"finalPrompt\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.pipelinePrompts = input.pipelinePrompts;\n        this.finalPrompt = input.finalPrompt;\n        this.inputVariables = this.computeInputValues();\n    }\n    /**\n     * Computes the input values required by the pipeline prompts.\n     * @returns Array of input values required by the pipeline prompts.\n     */\n    computeInputValues() {\n        const intermediateValues = this.pipelinePrompts.map((pipelinePrompt) => pipelinePrompt.name);\n        const inputValues = this.pipelinePrompts\n            .map((pipelinePrompt) => pipelinePrompt.prompt.inputVariables.filter((inputValue) => !intermediateValues.includes(inputValue)))\n            .flat();\n        return [...new Set(inputValues)];\n    }\n    static extractRequiredInputValues(allValues, requiredValueNames) {\n        return requiredValueNames.reduce((requiredValues, valueName) => {\n            // eslint-disable-next-line no-param-reassign\n            requiredValues[valueName] = allValues[valueName];\n            return requiredValues;\n        }, {});\n    }\n    /**\n     * Formats the pipeline prompts based on the provided input values.\n     * @param values Input values to format the pipeline prompts.\n     * @returns Promise that resolves with the formatted input values.\n     */\n    async formatPipelinePrompts(values) {\n        const allValues = await this.mergePartialAndUserVariables(values);\n        for (const { name: pipelinePromptName, prompt: pipelinePrompt } of this\n            .pipelinePrompts) {\n            const pipelinePromptInputValues = PipelinePromptTemplate.extractRequiredInputValues(allValues, pipelinePrompt.inputVariables);\n            // eslint-disable-next-line no-instanceof/no-instanceof\n            if (pipelinePrompt instanceof ChatPromptTemplate) {\n                allValues[pipelinePromptName] = await pipelinePrompt.formatMessages(pipelinePromptInputValues);\n            }\n            else {\n                allValues[pipelinePromptName] = await pipelinePrompt.format(pipelinePromptInputValues);\n            }\n        }\n        return PipelinePromptTemplate.extractRequiredInputValues(allValues, this.finalPrompt.inputVariables);\n    }\n    /**\n     * Formats the final prompt value based on the provided input values.\n     * @param values Input values to format the final prompt value.\n     * @returns Promise that resolves with the formatted final prompt value.\n     */\n    async formatPromptValue(values) {\n        return this.finalPrompt.formatPromptValue(await this.formatPipelinePrompts(values));\n    }\n    async format(values) {\n        return this.finalPrompt.format(await this.formatPipelinePrompts(values));\n    }\n    /**\n     * Handles partial prompts, which are prompts that have been partially\n     * filled with input values.\n     * @param values Partial input values.\n     * @returns Promise that resolves with a new PipelinePromptTemplate instance with updated input variables.\n     */\n    async partial(values) {\n        const promptDict = { ...this };\n        promptDict.inputVariables = this.inputVariables.filter((iv) => !(iv in values));\n        promptDict.partialVariables = {\n            ...(this.partialVariables ?? {}),\n            ...values,\n        };\n        return new PipelinePromptTemplate(promptDict);\n    }\n    serialize() {\n        throw new Error(\"Not implemented.\");\n    }\n    _getPromptType() {\n        return \"pipeline\";\n    }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}