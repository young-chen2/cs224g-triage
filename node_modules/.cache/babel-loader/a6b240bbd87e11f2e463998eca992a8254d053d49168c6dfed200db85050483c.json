{"ast":null,"code":"import { parseDef } from \"../parseDef.js\";\nconst isJsonSchema7AllOfType = type => {\n  if (\"type\" in type && type.type === \"string\") return false;\n  return \"allOf\" in type;\n};\nexport function parseIntersectionDef(def, refs) {\n  const allOf = [parseDef(def.left._def, {\n    ...refs,\n    currentPath: [...refs.currentPath, \"allOf\", \"0\"]\n  }), parseDef(def.right._def, {\n    ...refs,\n    currentPath: [...refs.currentPath, \"allOf\", \"1\"]\n  })].filter(x => !!x);\n  let unevaluatedProperties = refs.target === \"jsonSchema2019-09\" ? {\n    unevaluatedProperties: false\n  } : undefined;\n  const mergedAllOf = [];\n  // If either of the schemas is an allOf, merge them into a single allOf\n  allOf.forEach(schema => {\n    if (isJsonSchema7AllOfType(schema)) {\n      mergedAllOf.push(...schema.allOf);\n      if (schema.unevaluatedProperties === undefined) {\n        // If one of the schemas has no unevaluatedProperties set,\n        // the merged schema should also have no unevaluatedProperties set\n        unevaluatedProperties = undefined;\n      }\n    } else {\n      let nestedSchema = schema;\n      if (\"additionalProperties\" in schema && schema.additionalProperties === false) {\n        const {\n          additionalProperties,\n          ...rest\n        } = schema;\n        nestedSchema = rest;\n      } else {\n        // As soon as one of the schemas has additionalProperties set not to false, we allow unevaluatedProperties\n        unevaluatedProperties = undefined;\n      }\n      mergedAllOf.push(nestedSchema);\n    }\n  });\n  return mergedAllOf.length ? {\n    allOf: mergedAllOf,\n    ...unevaluatedProperties\n  } : undefined;\n}","map":{"version":3,"names":["parseDef","isJsonSchema7AllOfType","type","parseIntersectionDef","def","refs","allOf","left","_def","currentPath","right","filter","x","unevaluatedProperties","target","undefined","mergedAllOf","forEach","schema","push","nestedSchema","additionalProperties","rest","length"],"sources":["/Users/youngchen/Downloads/cs224g-triage/node_modules/zod-to-json-schema/dist/esm/parsers/intersection.js"],"sourcesContent":["import { parseDef } from \"../parseDef.js\";\nconst isJsonSchema7AllOfType = (type) => {\n    if (\"type\" in type && type.type === \"string\")\n        return false;\n    return \"allOf\" in type;\n};\nexport function parseIntersectionDef(def, refs) {\n    const allOf = [\n        parseDef(def.left._def, {\n            ...refs,\n            currentPath: [...refs.currentPath, \"allOf\", \"0\"],\n        }),\n        parseDef(def.right._def, {\n            ...refs,\n            currentPath: [...refs.currentPath, \"allOf\", \"1\"],\n        }),\n    ].filter((x) => !!x);\n    let unevaluatedProperties = refs.target === \"jsonSchema2019-09\"\n        ? { unevaluatedProperties: false }\n        : undefined;\n    const mergedAllOf = [];\n    // If either of the schemas is an allOf, merge them into a single allOf\n    allOf.forEach((schema) => {\n        if (isJsonSchema7AllOfType(schema)) {\n            mergedAllOf.push(...schema.allOf);\n            if (schema.unevaluatedProperties === undefined) {\n                // If one of the schemas has no unevaluatedProperties set,\n                // the merged schema should also have no unevaluatedProperties set\n                unevaluatedProperties = undefined;\n            }\n        }\n        else {\n            let nestedSchema = schema;\n            if (\"additionalProperties\" in schema &&\n                schema.additionalProperties === false) {\n                const { additionalProperties, ...rest } = schema;\n                nestedSchema = rest;\n            }\n            else {\n                // As soon as one of the schemas has additionalProperties set not to false, we allow unevaluatedProperties\n                unevaluatedProperties = undefined;\n            }\n            mergedAllOf.push(nestedSchema);\n        }\n    });\n    return mergedAllOf.length\n        ? {\n            allOf: mergedAllOf,\n            ...unevaluatedProperties,\n        }\n        : undefined;\n}\n"],"mappings":"AAAA,SAASA,QAAQ,QAAQ,gBAAgB;AACzC,MAAMC,sBAAsB,GAAIC,IAAI,IAAK;EACrC,IAAI,MAAM,IAAIA,IAAI,IAAIA,IAAI,CAACA,IAAI,KAAK,QAAQ,EACxC,OAAO,KAAK;EAChB,OAAO,OAAO,IAAIA,IAAI;AAC1B,CAAC;AACD,OAAO,SAASC,oBAAoBA,CAACC,GAAG,EAAEC,IAAI,EAAE;EAC5C,MAAMC,KAAK,GAAG,CACVN,QAAQ,CAACI,GAAG,CAACG,IAAI,CAACC,IAAI,EAAE;IACpB,GAAGH,IAAI;IACPI,WAAW,EAAE,CAAC,GAAGJ,IAAI,CAACI,WAAW,EAAE,OAAO,EAAE,GAAG;EACnD,CAAC,CAAC,EACFT,QAAQ,CAACI,GAAG,CAACM,KAAK,CAACF,IAAI,EAAE;IACrB,GAAGH,IAAI;IACPI,WAAW,EAAE,CAAC,GAAGJ,IAAI,CAACI,WAAW,EAAE,OAAO,EAAE,GAAG;EACnD,CAAC,CAAC,CACL,CAACE,MAAM,CAAEC,CAAC,IAAK,CAAC,CAACA,CAAC,CAAC;EACpB,IAAIC,qBAAqB,GAAGR,IAAI,CAACS,MAAM,KAAK,mBAAmB,GACzD;IAAED,qBAAqB,EAAE;EAAM,CAAC,GAChCE,SAAS;EACf,MAAMC,WAAW,GAAG,EAAE;EACtB;EACAV,KAAK,CAACW,OAAO,CAAEC,MAAM,IAAK;IACtB,IAAIjB,sBAAsB,CAACiB,MAAM,CAAC,EAAE;MAChCF,WAAW,CAACG,IAAI,CAAC,GAAGD,MAAM,CAACZ,KAAK,CAAC;MACjC,IAAIY,MAAM,CAACL,qBAAqB,KAAKE,SAAS,EAAE;QAC5C;QACA;QACAF,qBAAqB,GAAGE,SAAS;MACrC;IACJ,CAAC,MACI;MACD,IAAIK,YAAY,GAAGF,MAAM;MACzB,IAAI,sBAAsB,IAAIA,MAAM,IAChCA,MAAM,CAACG,oBAAoB,KAAK,KAAK,EAAE;QACvC,MAAM;UAAEA,oBAAoB;UAAE,GAAGC;QAAK,CAAC,GAAGJ,MAAM;QAChDE,YAAY,GAAGE,IAAI;MACvB,CAAC,MACI;QACD;QACAT,qBAAqB,GAAGE,SAAS;MACrC;MACAC,WAAW,CAACG,IAAI,CAACC,YAAY,CAAC;IAClC;EACJ,CAAC,CAAC;EACF,OAAOJ,WAAW,CAACO,MAAM,GACnB;IACEjB,KAAK,EAAEU,WAAW;IAClB,GAAGH;EACP,CAAC,GACCE,SAAS;AACnB","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}