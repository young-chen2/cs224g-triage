{"ast":null,"code":"import { Document, BaseDocumentTransformer } from \"@langchain/core/documents\";\nimport { getEncoding } from \"@langchain/core/utils/tiktoken\";\nexport class TextSplitter extends BaseDocumentTransformer {\n  constructor(fields) {\n    super(fields);\n    Object.defineProperty(this, \"lc_namespace\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: [\"langchain\", \"document_transformers\", \"text_splitters\"]\n    });\n    Object.defineProperty(this, \"chunkSize\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: 1000\n    });\n    Object.defineProperty(this, \"chunkOverlap\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: 200\n    });\n    Object.defineProperty(this, \"keepSeparator\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: false\n    });\n    Object.defineProperty(this, \"lengthFunction\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    this.chunkSize = fields?.chunkSize ?? this.chunkSize;\n    this.chunkOverlap = fields?.chunkOverlap ?? this.chunkOverlap;\n    this.keepSeparator = fields?.keepSeparator ?? this.keepSeparator;\n    this.lengthFunction = fields?.lengthFunction ?? (text => text.length);\n    if (this.chunkOverlap >= this.chunkSize) {\n      throw new Error(\"Cannot have chunkOverlap >= chunkSize\");\n    }\n  }\n  async transformDocuments(documents, chunkHeaderOptions = {}) {\n    return this.splitDocuments(documents, chunkHeaderOptions);\n  }\n  splitOnSeparator(text, separator) {\n    let splits;\n    if (separator) {\n      if (this.keepSeparator) {\n        const regexEscapedSeparator = separator.replace(/[/\\-\\\\^$*+?.()|[\\]{}]/g, \"\\\\$&\");\n        splits = text.split(new RegExp(`(?=${regexEscapedSeparator})`));\n      } else {\n        splits = text.split(separator);\n      }\n    } else {\n      splits = text.split(\"\");\n    }\n    return splits.filter(s => s !== \"\");\n  }\n  async createDocuments(texts,\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  metadatas = [], chunkHeaderOptions = {}) {\n    // if no metadata is provided, we create an empty one for each text\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    const _metadatas = metadatas.length > 0 ? metadatas : [...Array(texts.length)].map(() => ({}));\n    const {\n      chunkHeader = \"\",\n      chunkOverlapHeader = \"(cont'd) \",\n      appendChunkOverlapHeader = false\n    } = chunkHeaderOptions;\n    const documents = new Array();\n    for (let i = 0; i < texts.length; i += 1) {\n      const text = texts[i];\n      let lineCounterIndex = 1;\n      let prevChunk = null;\n      let indexPrevChunk = -1;\n      for (const chunk of await this.splitText(text)) {\n        let pageContent = chunkHeader;\n        // we need to count the \\n that are in the text before getting removed by the splitting\n        const indexChunk = text.indexOf(chunk, indexPrevChunk + 1);\n        if (prevChunk === null) {\n          const newLinesBeforeFirstChunk = this.numberOfNewLines(text, 0, indexChunk);\n          lineCounterIndex += newLinesBeforeFirstChunk;\n        } else {\n          const indexEndPrevChunk = indexPrevChunk + (await this.lengthFunction(prevChunk));\n          if (indexEndPrevChunk < indexChunk) {\n            const numberOfIntermediateNewLines = this.numberOfNewLines(text, indexEndPrevChunk, indexChunk);\n            lineCounterIndex += numberOfIntermediateNewLines;\n          } else if (indexEndPrevChunk > indexChunk) {\n            const numberOfIntermediateNewLines = this.numberOfNewLines(text, indexChunk, indexEndPrevChunk);\n            lineCounterIndex -= numberOfIntermediateNewLines;\n          }\n          if (appendChunkOverlapHeader) {\n            pageContent += chunkOverlapHeader;\n          }\n        }\n        const newLinesCount = this.numberOfNewLines(chunk);\n        const loc = _metadatas[i].loc && typeof _metadatas[i].loc === \"object\" ? {\n          ..._metadatas[i].loc\n        } : {};\n        loc.lines = {\n          from: lineCounterIndex,\n          to: lineCounterIndex + newLinesCount\n        };\n        const metadataWithLinesNumber = {\n          ..._metadatas[i],\n          loc\n        };\n        pageContent += chunk;\n        documents.push(new Document({\n          pageContent,\n          metadata: metadataWithLinesNumber\n        }));\n        lineCounterIndex += newLinesCount;\n        prevChunk = chunk;\n        indexPrevChunk = indexChunk;\n      }\n    }\n    return documents;\n  }\n  numberOfNewLines(text, start, end) {\n    const textSection = text.slice(start, end);\n    return (textSection.match(/\\n/g) || []).length;\n  }\n  async splitDocuments(documents, chunkHeaderOptions = {}) {\n    const selectedDocuments = documents.filter(doc => doc.pageContent !== undefined);\n    const texts = selectedDocuments.map(doc => doc.pageContent);\n    const metadatas = selectedDocuments.map(doc => doc.metadata);\n    return this.createDocuments(texts, metadatas, chunkHeaderOptions);\n  }\n  joinDocs(docs, separator) {\n    const text = docs.join(separator).trim();\n    return text === \"\" ? null : text;\n  }\n  async mergeSplits(splits, separator) {\n    const docs = [];\n    const currentDoc = [];\n    let total = 0;\n    for (const d of splits) {\n      const _len = await this.lengthFunction(d);\n      if (total + _len + currentDoc.length * separator.length > this.chunkSize) {\n        if (total > this.chunkSize) {\n          console.warn(`Created a chunk of size ${total}, +\nwhich is longer than the specified ${this.chunkSize}`);\n        }\n        if (currentDoc.length > 0) {\n          const doc = this.joinDocs(currentDoc, separator);\n          if (doc !== null) {\n            docs.push(doc);\n          }\n          // Keep on popping if:\n          // - we have a larger chunk than in the chunk overlap\n          // - or if we still have any chunks and the length is long\n          while (total > this.chunkOverlap || total + _len + currentDoc.length * separator.length > this.chunkSize && total > 0) {\n            total -= await this.lengthFunction(currentDoc[0]);\n            currentDoc.shift();\n          }\n        }\n      }\n      currentDoc.push(d);\n      total += _len;\n    }\n    const doc = this.joinDocs(currentDoc, separator);\n    if (doc !== null) {\n      docs.push(doc);\n    }\n    return docs;\n  }\n}\nexport class CharacterTextSplitter extends TextSplitter {\n  static lc_name() {\n    return \"CharacterTextSplitter\";\n  }\n  constructor(fields) {\n    super(fields);\n    Object.defineProperty(this, \"separator\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: \"\\n\\n\"\n    });\n    this.separator = fields?.separator ?? this.separator;\n  }\n  async splitText(text) {\n    // First we naively split the large input into a bunch of smaller ones.\n    const splits = this.splitOnSeparator(text, this.separator);\n    return this.mergeSplits(splits, this.keepSeparator ? \"\" : this.separator);\n  }\n}\nexport const SupportedTextSplitterLanguages = [\"cpp\", \"go\", \"java\", \"js\", \"php\", \"proto\", \"python\", \"rst\", \"ruby\", \"rust\", \"scala\", \"swift\", \"markdown\", \"latex\", \"html\", \"sol\"];\nexport class RecursiveCharacterTextSplitter extends TextSplitter {\n  static lc_name() {\n    return \"RecursiveCharacterTextSplitter\";\n  }\n  constructor(fields) {\n    super(fields);\n    Object.defineProperty(this, \"separators\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: [\"\\n\\n\", \"\\n\", \" \", \"\"]\n    });\n    this.separators = fields?.separators ?? this.separators;\n    this.keepSeparator = fields?.keepSeparator ?? true;\n  }\n  async _splitText(text, separators) {\n    const finalChunks = [];\n    // Get appropriate separator to use\n    let separator = separators[separators.length - 1];\n    let newSeparators;\n    for (let i = 0; i < separators.length; i += 1) {\n      const s = separators[i];\n      if (s === \"\") {\n        separator = s;\n        break;\n      }\n      if (text.includes(s)) {\n        separator = s;\n        newSeparators = separators.slice(i + 1);\n        break;\n      }\n    }\n    // Now that we have the separator, split the text\n    const splits = this.splitOnSeparator(text, separator);\n    // Now go merging things, recursively splitting longer texts.\n    let goodSplits = [];\n    const _separator = this.keepSeparator ? \"\" : separator;\n    for (const s of splits) {\n      if ((await this.lengthFunction(s)) < this.chunkSize) {\n        goodSplits.push(s);\n      } else {\n        if (goodSplits.length) {\n          const mergedText = await this.mergeSplits(goodSplits, _separator);\n          finalChunks.push(...mergedText);\n          goodSplits = [];\n        }\n        if (!newSeparators) {\n          finalChunks.push(s);\n        } else {\n          const otherInfo = await this._splitText(s, newSeparators);\n          finalChunks.push(...otherInfo);\n        }\n      }\n    }\n    if (goodSplits.length) {\n      const mergedText = await this.mergeSplits(goodSplits, _separator);\n      finalChunks.push(...mergedText);\n    }\n    return finalChunks;\n  }\n  async splitText(text) {\n    return this._splitText(text, this.separators);\n  }\n  static fromLanguage(language, options) {\n    return new RecursiveCharacterTextSplitter({\n      ...options,\n      separators: RecursiveCharacterTextSplitter.getSeparatorsForLanguage(language)\n    });\n  }\n  static getSeparatorsForLanguage(language) {\n    if (language === \"cpp\") {\n      return [\n      // Split along class definitions\n      \"\\nclass \",\n      // Split along function definitions\n      \"\\nvoid \", \"\\nint \", \"\\nfloat \", \"\\ndouble \",\n      // Split along control flow statements\n      \"\\nif \", \"\\nfor \", \"\\nwhile \", \"\\nswitch \", \"\\ncase \",\n      // Split by the normal type of lines\n      \"\\n\\n\", \"\\n\", \" \", \"\"];\n    } else if (language === \"go\") {\n      return [\n      // Split along function definitions\n      \"\\nfunc \", \"\\nvar \", \"\\nconst \", \"\\ntype \",\n      // Split along control flow statements\n      \"\\nif \", \"\\nfor \", \"\\nswitch \", \"\\ncase \",\n      // Split by the normal type of lines\n      \"\\n\\n\", \"\\n\", \" \", \"\"];\n    } else if (language === \"java\") {\n      return [\n      // Split along class definitions\n      \"\\nclass \",\n      // Split along method definitions\n      \"\\npublic \", \"\\nprotected \", \"\\nprivate \", \"\\nstatic \",\n      // Split along control flow statements\n      \"\\nif \", \"\\nfor \", \"\\nwhile \", \"\\nswitch \", \"\\ncase \",\n      // Split by the normal type of lines\n      \"\\n\\n\", \"\\n\", \" \", \"\"];\n    } else if (language === \"js\") {\n      return [\n      // Split along function definitions\n      \"\\nfunction \", \"\\nconst \", \"\\nlet \", \"\\nvar \", \"\\nclass \",\n      // Split along control flow statements\n      \"\\nif \", \"\\nfor \", \"\\nwhile \", \"\\nswitch \", \"\\ncase \", \"\\ndefault \",\n      // Split by the normal type of lines\n      \"\\n\\n\", \"\\n\", \" \", \"\"];\n    } else if (language === \"php\") {\n      return [\n      // Split along function definitions\n      \"\\nfunction \",\n      // Split along class definitions\n      \"\\nclass \",\n      // Split along control flow statements\n      \"\\nif \", \"\\nforeach \", \"\\nwhile \", \"\\ndo \", \"\\nswitch \", \"\\ncase \",\n      // Split by the normal type of lines\n      \"\\n\\n\", \"\\n\", \" \", \"\"];\n    } else if (language === \"proto\") {\n      return [\n      // Split along message definitions\n      \"\\nmessage \",\n      // Split along service definitions\n      \"\\nservice \",\n      // Split along enum definitions\n      \"\\nenum \",\n      // Split along option definitions\n      \"\\noption \",\n      // Split along import statements\n      \"\\nimport \",\n      // Split along syntax declarations\n      \"\\nsyntax \",\n      // Split by the normal type of lines\n      \"\\n\\n\", \"\\n\", \" \", \"\"];\n    } else if (language === \"python\") {\n      return [\n      // First, try to split along class definitions\n      \"\\nclass \", \"\\ndef \", \"\\n\\tdef \",\n      // Now split by the normal type of lines\n      \"\\n\\n\", \"\\n\", \" \", \"\"];\n    } else if (language === \"rst\") {\n      return [\n      // Split along section titles\n      \"\\n===\\n\", \"\\n---\\n\", \"\\n***\\n\",\n      // Split along directive markers\n      \"\\n.. \",\n      // Split by the normal type of lines\n      \"\\n\\n\", \"\\n\", \" \", \"\"];\n    } else if (language === \"ruby\") {\n      return [\n      // Split along method definitions\n      \"\\ndef \", \"\\nclass \",\n      // Split along control flow statements\n      \"\\nif \", \"\\nunless \", \"\\nwhile \", \"\\nfor \", \"\\ndo \", \"\\nbegin \", \"\\nrescue \",\n      // Split by the normal type of lines\n      \"\\n\\n\", \"\\n\", \" \", \"\"];\n    } else if (language === \"rust\") {\n      return [\n      // Split along function definitions\n      \"\\nfn \", \"\\nconst \", \"\\nlet \",\n      // Split along control flow statements\n      \"\\nif \", \"\\nwhile \", \"\\nfor \", \"\\nloop \", \"\\nmatch \", \"\\nconst \",\n      // Split by the normal type of lines\n      \"\\n\\n\", \"\\n\", \" \", \"\"];\n    } else if (language === \"scala\") {\n      return [\n      // Split along class definitions\n      \"\\nclass \", \"\\nobject \",\n      // Split along method definitions\n      \"\\ndef \", \"\\nval \", \"\\nvar \",\n      // Split along control flow statements\n      \"\\nif \", \"\\nfor \", \"\\nwhile \", \"\\nmatch \", \"\\ncase \",\n      // Split by the normal type of lines\n      \"\\n\\n\", \"\\n\", \" \", \"\"];\n    } else if (language === \"swift\") {\n      return [\n      // Split along function definitions\n      \"\\nfunc \",\n      // Split along class definitions\n      \"\\nclass \", \"\\nstruct \", \"\\nenum \",\n      // Split along control flow statements\n      \"\\nif \", \"\\nfor \", \"\\nwhile \", \"\\ndo \", \"\\nswitch \", \"\\ncase \",\n      // Split by the normal type of lines\n      \"\\n\\n\", \"\\n\", \" \", \"\"];\n    } else if (language === \"markdown\") {\n      return [\n      // First, try to split along Markdown headings (starting with level 2)\n      \"\\n## \", \"\\n### \", \"\\n#### \", \"\\n##### \", \"\\n###### \",\n      // Note the alternative syntax for headings (below) is not handled here\n      // Heading level 2\n      // ---------------\n      // End of code block\n      \"```\\n\\n\",\n      // Horizontal lines\n      \"\\n\\n***\\n\\n\", \"\\n\\n---\\n\\n\", \"\\n\\n___\\n\\n\",\n      // Note that this splitter doesn't handle horizontal lines defined\n      // by *three or more* of ***, ---, or ___, but this is not handled\n      \"\\n\\n\", \"\\n\", \" \", \"\"];\n    } else if (language === \"latex\") {\n      return [\n      // First, try to split along Latex sections\n      \"\\n\\\\chapter{\", \"\\n\\\\section{\", \"\\n\\\\subsection{\", \"\\n\\\\subsubsection{\",\n      // Now split by environments\n      \"\\n\\\\begin{enumerate}\", \"\\n\\\\begin{itemize}\", \"\\n\\\\begin{description}\", \"\\n\\\\begin{list}\", \"\\n\\\\begin{quote}\", \"\\n\\\\begin{quotation}\", \"\\n\\\\begin{verse}\", \"\\n\\\\begin{verbatim}\",\n      // Now split by math environments\n      \"\\n\\\\begin{align}\", \"$$\", \"$\",\n      // Now split by the normal type of lines\n      \"\\n\\n\", \"\\n\", \" \", \"\"];\n    } else if (language === \"html\") {\n      return [\n      // First, try to split along HTML tags\n      \"<body>\", \"<div>\", \"<p>\", \"<br>\", \"<li>\", \"<h1>\", \"<h2>\", \"<h3>\", \"<h4>\", \"<h5>\", \"<h6>\", \"<span>\", \"<table>\", \"<tr>\", \"<td>\", \"<th>\", \"<ul>\", \"<ol>\", \"<header>\", \"<footer>\", \"<nav>\",\n      // Head\n      \"<head>\", \"<style>\", \"<script>\", \"<meta>\", \"<title>\",\n      // Normal type of lines\n      \" \", \"\"];\n    } else if (language === \"sol\") {\n      return [\n      // Split along compiler informations definitions\n      \"\\npragma \", \"\\nusing \",\n      // Split along contract definitions\n      \"\\ncontract \", \"\\ninterface \", \"\\nlibrary \",\n      // Split along method definitions\n      \"\\nconstructor \", \"\\ntype \", \"\\nfunction \", \"\\nevent \", \"\\nmodifier \", \"\\nerror \", \"\\nstruct \", \"\\nenum \",\n      // Split along control flow statements\n      \"\\nif \", \"\\nfor \", \"\\nwhile \", \"\\ndo while \", \"\\nassembly \",\n      // Split by the normal type of lines\n      \"\\n\\n\", \"\\n\", \" \", \"\"];\n    } else {\n      throw new Error(`Language ${language} is not supported.`);\n    }\n  }\n}\n/**\n * Implementation of splitter which looks at tokens.\n */\nexport class TokenTextSplitter extends TextSplitter {\n  static lc_name() {\n    return \"TokenTextSplitter\";\n  }\n  constructor(fields) {\n    super(fields);\n    Object.defineProperty(this, \"encodingName\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, \"allowedSpecial\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, \"disallowedSpecial\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, \"tokenizer\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    this.encodingName = fields?.encodingName ?? \"gpt2\";\n    this.allowedSpecial = fields?.allowedSpecial ?? [];\n    this.disallowedSpecial = fields?.disallowedSpecial ?? \"all\";\n  }\n  async splitText(text) {\n    if (!this.tokenizer) {\n      this.tokenizer = await getEncoding(this.encodingName);\n    }\n    const splits = [];\n    const input_ids = this.tokenizer.encode(text, this.allowedSpecial, this.disallowedSpecial);\n    let start_idx = 0;\n    while (start_idx < input_ids.length) {\n      if (start_idx > 0) {\n        start_idx -= this.chunkOverlap;\n      }\n      const end_idx = Math.min(start_idx + this.chunkSize, input_ids.length);\n      const chunk_ids = input_ids.slice(start_idx, end_idx);\n      splits.push(this.tokenizer.decode(chunk_ids));\n      start_idx = end_idx;\n    }\n    return splits;\n  }\n}\nexport class MarkdownTextSplitter extends RecursiveCharacterTextSplitter {\n  constructor(fields) {\n    super({\n      ...fields,\n      separators: RecursiveCharacterTextSplitter.getSeparatorsForLanguage(\"markdown\")\n    });\n  }\n}\nexport class LatexTextSplitter extends RecursiveCharacterTextSplitter {\n  constructor(fields) {\n    super({\n      ...fields,\n      separators: RecursiveCharacterTextSplitter.getSeparatorsForLanguage(\"latex\")\n    });\n  }\n}","map":{"version":3,"names":["Document","BaseDocumentTransformer","getEncoding","TextSplitter","constructor","fields","Object","defineProperty","enumerable","configurable","writable","value","chunkSize","chunkOverlap","keepSeparator","lengthFunction","text","length","Error","transformDocuments","documents","chunkHeaderOptions","splitDocuments","splitOnSeparator","separator","splits","regexEscapedSeparator","replace","split","RegExp","filter","s","createDocuments","texts","metadatas","_metadatas","Array","map","chunkHeader","chunkOverlapHeader","appendChunkOverlapHeader","i","lineCounterIndex","prevChunk","indexPrevChunk","chunk","splitText","pageContent","indexChunk","indexOf","newLinesBeforeFirstChunk","numberOfNewLines","indexEndPrevChunk","numberOfIntermediateNewLines","newLinesCount","loc","lines","from","to","metadataWithLinesNumber","push","metadata","start","end","textSection","slice","match","selectedDocuments","doc","undefined","joinDocs","docs","join","trim","mergeSplits","currentDoc","total","d","_len","console","warn","shift","CharacterTextSplitter","lc_name","SupportedTextSplitterLanguages","RecursiveCharacterTextSplitter","separators","_splitText","finalChunks","newSeparators","includes","goodSplits","_separator","mergedText","otherInfo","fromLanguage","language","options","getSeparatorsForLanguage","TokenTextSplitter","encodingName","allowedSpecial","disallowedSpecial","tokenizer","input_ids","encode","start_idx","end_idx","Math","min","chunk_ids","decode","MarkdownTextSplitter","LatexTextSplitter"],"sources":["/Users/youngchen/Downloads/cs224g-triage/node_modules/@langchain/textsplitters/dist/text_splitter.js"],"sourcesContent":["import { Document, BaseDocumentTransformer } from \"@langchain/core/documents\";\nimport { getEncoding } from \"@langchain/core/utils/tiktoken\";\nexport class TextSplitter extends BaseDocumentTransformer {\n    constructor(fields) {\n        super(fields);\n        Object.defineProperty(this, \"lc_namespace\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: [\"langchain\", \"document_transformers\", \"text_splitters\"]\n        });\n        Object.defineProperty(this, \"chunkSize\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 1000\n        });\n        Object.defineProperty(this, \"chunkOverlap\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 200\n        });\n        Object.defineProperty(this, \"keepSeparator\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: false\n        });\n        Object.defineProperty(this, \"lengthFunction\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.chunkSize = fields?.chunkSize ?? this.chunkSize;\n        this.chunkOverlap = fields?.chunkOverlap ?? this.chunkOverlap;\n        this.keepSeparator = fields?.keepSeparator ?? this.keepSeparator;\n        this.lengthFunction =\n            fields?.lengthFunction ?? ((text) => text.length);\n        if (this.chunkOverlap >= this.chunkSize) {\n            throw new Error(\"Cannot have chunkOverlap >= chunkSize\");\n        }\n    }\n    async transformDocuments(documents, chunkHeaderOptions = {}) {\n        return this.splitDocuments(documents, chunkHeaderOptions);\n    }\n    splitOnSeparator(text, separator) {\n        let splits;\n        if (separator) {\n            if (this.keepSeparator) {\n                const regexEscapedSeparator = separator.replace(/[/\\-\\\\^$*+?.()|[\\]{}]/g, \"\\\\$&\");\n                splits = text.split(new RegExp(`(?=${regexEscapedSeparator})`));\n            }\n            else {\n                splits = text.split(separator);\n            }\n        }\n        else {\n            splits = text.split(\"\");\n        }\n        return splits.filter((s) => s !== \"\");\n    }\n    async createDocuments(texts, \n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    metadatas = [], chunkHeaderOptions = {}) {\n        // if no metadata is provided, we create an empty one for each text\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        const _metadatas = metadatas.length > 0\n            ? metadatas\n            : [...Array(texts.length)].map(() => ({}));\n        const { chunkHeader = \"\", chunkOverlapHeader = \"(cont'd) \", appendChunkOverlapHeader = false, } = chunkHeaderOptions;\n        const documents = new Array();\n        for (let i = 0; i < texts.length; i += 1) {\n            const text = texts[i];\n            let lineCounterIndex = 1;\n            let prevChunk = null;\n            let indexPrevChunk = -1;\n            for (const chunk of await this.splitText(text)) {\n                let pageContent = chunkHeader;\n                // we need to count the \\n that are in the text before getting removed by the splitting\n                const indexChunk = text.indexOf(chunk, indexPrevChunk + 1);\n                if (prevChunk === null) {\n                    const newLinesBeforeFirstChunk = this.numberOfNewLines(text, 0, indexChunk);\n                    lineCounterIndex += newLinesBeforeFirstChunk;\n                }\n                else {\n                    const indexEndPrevChunk = indexPrevChunk + (await this.lengthFunction(prevChunk));\n                    if (indexEndPrevChunk < indexChunk) {\n                        const numberOfIntermediateNewLines = this.numberOfNewLines(text, indexEndPrevChunk, indexChunk);\n                        lineCounterIndex += numberOfIntermediateNewLines;\n                    }\n                    else if (indexEndPrevChunk > indexChunk) {\n                        const numberOfIntermediateNewLines = this.numberOfNewLines(text, indexChunk, indexEndPrevChunk);\n                        lineCounterIndex -= numberOfIntermediateNewLines;\n                    }\n                    if (appendChunkOverlapHeader) {\n                        pageContent += chunkOverlapHeader;\n                    }\n                }\n                const newLinesCount = this.numberOfNewLines(chunk);\n                const loc = _metadatas[i].loc && typeof _metadatas[i].loc === \"object\"\n                    ? { ..._metadatas[i].loc }\n                    : {};\n                loc.lines = {\n                    from: lineCounterIndex,\n                    to: lineCounterIndex + newLinesCount,\n                };\n                const metadataWithLinesNumber = {\n                    ..._metadatas[i],\n                    loc,\n                };\n                pageContent += chunk;\n                documents.push(new Document({\n                    pageContent,\n                    metadata: metadataWithLinesNumber,\n                }));\n                lineCounterIndex += newLinesCount;\n                prevChunk = chunk;\n                indexPrevChunk = indexChunk;\n            }\n        }\n        return documents;\n    }\n    numberOfNewLines(text, start, end) {\n        const textSection = text.slice(start, end);\n        return (textSection.match(/\\n/g) || []).length;\n    }\n    async splitDocuments(documents, chunkHeaderOptions = {}) {\n        const selectedDocuments = documents.filter((doc) => doc.pageContent !== undefined);\n        const texts = selectedDocuments.map((doc) => doc.pageContent);\n        const metadatas = selectedDocuments.map((doc) => doc.metadata);\n        return this.createDocuments(texts, metadatas, chunkHeaderOptions);\n    }\n    joinDocs(docs, separator) {\n        const text = docs.join(separator).trim();\n        return text === \"\" ? null : text;\n    }\n    async mergeSplits(splits, separator) {\n        const docs = [];\n        const currentDoc = [];\n        let total = 0;\n        for (const d of splits) {\n            const _len = await this.lengthFunction(d);\n            if (total + _len + currentDoc.length * separator.length >\n                this.chunkSize) {\n                if (total > this.chunkSize) {\n                    console.warn(`Created a chunk of size ${total}, +\nwhich is longer than the specified ${this.chunkSize}`);\n                }\n                if (currentDoc.length > 0) {\n                    const doc = this.joinDocs(currentDoc, separator);\n                    if (doc !== null) {\n                        docs.push(doc);\n                    }\n                    // Keep on popping if:\n                    // - we have a larger chunk than in the chunk overlap\n                    // - or if we still have any chunks and the length is long\n                    while (total > this.chunkOverlap ||\n                        (total + _len + currentDoc.length * separator.length >\n                            this.chunkSize &&\n                            total > 0)) {\n                        total -= await this.lengthFunction(currentDoc[0]);\n                        currentDoc.shift();\n                    }\n                }\n            }\n            currentDoc.push(d);\n            total += _len;\n        }\n        const doc = this.joinDocs(currentDoc, separator);\n        if (doc !== null) {\n            docs.push(doc);\n        }\n        return docs;\n    }\n}\nexport class CharacterTextSplitter extends TextSplitter {\n    static lc_name() {\n        return \"CharacterTextSplitter\";\n    }\n    constructor(fields) {\n        super(fields);\n        Object.defineProperty(this, \"separator\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: \"\\n\\n\"\n        });\n        this.separator = fields?.separator ?? this.separator;\n    }\n    async splitText(text) {\n        // First we naively split the large input into a bunch of smaller ones.\n        const splits = this.splitOnSeparator(text, this.separator);\n        return this.mergeSplits(splits, this.keepSeparator ? \"\" : this.separator);\n    }\n}\nexport const SupportedTextSplitterLanguages = [\n    \"cpp\",\n    \"go\",\n    \"java\",\n    \"js\",\n    \"php\",\n    \"proto\",\n    \"python\",\n    \"rst\",\n    \"ruby\",\n    \"rust\",\n    \"scala\",\n    \"swift\",\n    \"markdown\",\n    \"latex\",\n    \"html\",\n    \"sol\",\n];\nexport class RecursiveCharacterTextSplitter extends TextSplitter {\n    static lc_name() {\n        return \"RecursiveCharacterTextSplitter\";\n    }\n    constructor(fields) {\n        super(fields);\n        Object.defineProperty(this, \"separators\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: [\"\\n\\n\", \"\\n\", \" \", \"\"]\n        });\n        this.separators = fields?.separators ?? this.separators;\n        this.keepSeparator = fields?.keepSeparator ?? true;\n    }\n    async _splitText(text, separators) {\n        const finalChunks = [];\n        // Get appropriate separator to use\n        let separator = separators[separators.length - 1];\n        let newSeparators;\n        for (let i = 0; i < separators.length; i += 1) {\n            const s = separators[i];\n            if (s === \"\") {\n                separator = s;\n                break;\n            }\n            if (text.includes(s)) {\n                separator = s;\n                newSeparators = separators.slice(i + 1);\n                break;\n            }\n        }\n        // Now that we have the separator, split the text\n        const splits = this.splitOnSeparator(text, separator);\n        // Now go merging things, recursively splitting longer texts.\n        let goodSplits = [];\n        const _separator = this.keepSeparator ? \"\" : separator;\n        for (const s of splits) {\n            if ((await this.lengthFunction(s)) < this.chunkSize) {\n                goodSplits.push(s);\n            }\n            else {\n                if (goodSplits.length) {\n                    const mergedText = await this.mergeSplits(goodSplits, _separator);\n                    finalChunks.push(...mergedText);\n                    goodSplits = [];\n                }\n                if (!newSeparators) {\n                    finalChunks.push(s);\n                }\n                else {\n                    const otherInfo = await this._splitText(s, newSeparators);\n                    finalChunks.push(...otherInfo);\n                }\n            }\n        }\n        if (goodSplits.length) {\n            const mergedText = await this.mergeSplits(goodSplits, _separator);\n            finalChunks.push(...mergedText);\n        }\n        return finalChunks;\n    }\n    async splitText(text) {\n        return this._splitText(text, this.separators);\n    }\n    static fromLanguage(language, options) {\n        return new RecursiveCharacterTextSplitter({\n            ...options,\n            separators: RecursiveCharacterTextSplitter.getSeparatorsForLanguage(language),\n        });\n    }\n    static getSeparatorsForLanguage(language) {\n        if (language === \"cpp\") {\n            return [\n                // Split along class definitions\n                \"\\nclass \",\n                // Split along function definitions\n                \"\\nvoid \",\n                \"\\nint \",\n                \"\\nfloat \",\n                \"\\ndouble \",\n                // Split along control flow statements\n                \"\\nif \",\n                \"\\nfor \",\n                \"\\nwhile \",\n                \"\\nswitch \",\n                \"\\ncase \",\n                // Split by the normal type of lines\n                \"\\n\\n\",\n                \"\\n\",\n                \" \",\n                \"\",\n            ];\n        }\n        else if (language === \"go\") {\n            return [\n                // Split along function definitions\n                \"\\nfunc \",\n                \"\\nvar \",\n                \"\\nconst \",\n                \"\\ntype \",\n                // Split along control flow statements\n                \"\\nif \",\n                \"\\nfor \",\n                \"\\nswitch \",\n                \"\\ncase \",\n                // Split by the normal type of lines\n                \"\\n\\n\",\n                \"\\n\",\n                \" \",\n                \"\",\n            ];\n        }\n        else if (language === \"java\") {\n            return [\n                // Split along class definitions\n                \"\\nclass \",\n                // Split along method definitions\n                \"\\npublic \",\n                \"\\nprotected \",\n                \"\\nprivate \",\n                \"\\nstatic \",\n                // Split along control flow statements\n                \"\\nif \",\n                \"\\nfor \",\n                \"\\nwhile \",\n                \"\\nswitch \",\n                \"\\ncase \",\n                // Split by the normal type of lines\n                \"\\n\\n\",\n                \"\\n\",\n                \" \",\n                \"\",\n            ];\n        }\n        else if (language === \"js\") {\n            return [\n                // Split along function definitions\n                \"\\nfunction \",\n                \"\\nconst \",\n                \"\\nlet \",\n                \"\\nvar \",\n                \"\\nclass \",\n                // Split along control flow statements\n                \"\\nif \",\n                \"\\nfor \",\n                \"\\nwhile \",\n                \"\\nswitch \",\n                \"\\ncase \",\n                \"\\ndefault \",\n                // Split by the normal type of lines\n                \"\\n\\n\",\n                \"\\n\",\n                \" \",\n                \"\",\n            ];\n        }\n        else if (language === \"php\") {\n            return [\n                // Split along function definitions\n                \"\\nfunction \",\n                // Split along class definitions\n                \"\\nclass \",\n                // Split along control flow statements\n                \"\\nif \",\n                \"\\nforeach \",\n                \"\\nwhile \",\n                \"\\ndo \",\n                \"\\nswitch \",\n                \"\\ncase \",\n                // Split by the normal type of lines\n                \"\\n\\n\",\n                \"\\n\",\n                \" \",\n                \"\",\n            ];\n        }\n        else if (language === \"proto\") {\n            return [\n                // Split along message definitions\n                \"\\nmessage \",\n                // Split along service definitions\n                \"\\nservice \",\n                // Split along enum definitions\n                \"\\nenum \",\n                // Split along option definitions\n                \"\\noption \",\n                // Split along import statements\n                \"\\nimport \",\n                // Split along syntax declarations\n                \"\\nsyntax \",\n                // Split by the normal type of lines\n                \"\\n\\n\",\n                \"\\n\",\n                \" \",\n                \"\",\n            ];\n        }\n        else if (language === \"python\") {\n            return [\n                // First, try to split along class definitions\n                \"\\nclass \",\n                \"\\ndef \",\n                \"\\n\\tdef \",\n                // Now split by the normal type of lines\n                \"\\n\\n\",\n                \"\\n\",\n                \" \",\n                \"\",\n            ];\n        }\n        else if (language === \"rst\") {\n            return [\n                // Split along section titles\n                \"\\n===\\n\",\n                \"\\n---\\n\",\n                \"\\n***\\n\",\n                // Split along directive markers\n                \"\\n.. \",\n                // Split by the normal type of lines\n                \"\\n\\n\",\n                \"\\n\",\n                \" \",\n                \"\",\n            ];\n        }\n        else if (language === \"ruby\") {\n            return [\n                // Split along method definitions\n                \"\\ndef \",\n                \"\\nclass \",\n                // Split along control flow statements\n                \"\\nif \",\n                \"\\nunless \",\n                \"\\nwhile \",\n                \"\\nfor \",\n                \"\\ndo \",\n                \"\\nbegin \",\n                \"\\nrescue \",\n                // Split by the normal type of lines\n                \"\\n\\n\",\n                \"\\n\",\n                \" \",\n                \"\",\n            ];\n        }\n        else if (language === \"rust\") {\n            return [\n                // Split along function definitions\n                \"\\nfn \",\n                \"\\nconst \",\n                \"\\nlet \",\n                // Split along control flow statements\n                \"\\nif \",\n                \"\\nwhile \",\n                \"\\nfor \",\n                \"\\nloop \",\n                \"\\nmatch \",\n                \"\\nconst \",\n                // Split by the normal type of lines\n                \"\\n\\n\",\n                \"\\n\",\n                \" \",\n                \"\",\n            ];\n        }\n        else if (language === \"scala\") {\n            return [\n                // Split along class definitions\n                \"\\nclass \",\n                \"\\nobject \",\n                // Split along method definitions\n                \"\\ndef \",\n                \"\\nval \",\n                \"\\nvar \",\n                // Split along control flow statements\n                \"\\nif \",\n                \"\\nfor \",\n                \"\\nwhile \",\n                \"\\nmatch \",\n                \"\\ncase \",\n                // Split by the normal type of lines\n                \"\\n\\n\",\n                \"\\n\",\n                \" \",\n                \"\",\n            ];\n        }\n        else if (language === \"swift\") {\n            return [\n                // Split along function definitions\n                \"\\nfunc \",\n                // Split along class definitions\n                \"\\nclass \",\n                \"\\nstruct \",\n                \"\\nenum \",\n                // Split along control flow statements\n                \"\\nif \",\n                \"\\nfor \",\n                \"\\nwhile \",\n                \"\\ndo \",\n                \"\\nswitch \",\n                \"\\ncase \",\n                // Split by the normal type of lines\n                \"\\n\\n\",\n                \"\\n\",\n                \" \",\n                \"\",\n            ];\n        }\n        else if (language === \"markdown\") {\n            return [\n                // First, try to split along Markdown headings (starting with level 2)\n                \"\\n## \",\n                \"\\n### \",\n                \"\\n#### \",\n                \"\\n##### \",\n                \"\\n###### \",\n                // Note the alternative syntax for headings (below) is not handled here\n                // Heading level 2\n                // ---------------\n                // End of code block\n                \"```\\n\\n\",\n                // Horizontal lines\n                \"\\n\\n***\\n\\n\",\n                \"\\n\\n---\\n\\n\",\n                \"\\n\\n___\\n\\n\",\n                // Note that this splitter doesn't handle horizontal lines defined\n                // by *three or more* of ***, ---, or ___, but this is not handled\n                \"\\n\\n\",\n                \"\\n\",\n                \" \",\n                \"\",\n            ];\n        }\n        else if (language === \"latex\") {\n            return [\n                // First, try to split along Latex sections\n                \"\\n\\\\chapter{\",\n                \"\\n\\\\section{\",\n                \"\\n\\\\subsection{\",\n                \"\\n\\\\subsubsection{\",\n                // Now split by environments\n                \"\\n\\\\begin{enumerate}\",\n                \"\\n\\\\begin{itemize}\",\n                \"\\n\\\\begin{description}\",\n                \"\\n\\\\begin{list}\",\n                \"\\n\\\\begin{quote}\",\n                \"\\n\\\\begin{quotation}\",\n                \"\\n\\\\begin{verse}\",\n                \"\\n\\\\begin{verbatim}\",\n                // Now split by math environments\n                \"\\n\\\\begin{align}\",\n                \"$$\",\n                \"$\",\n                // Now split by the normal type of lines\n                \"\\n\\n\",\n                \"\\n\",\n                \" \",\n                \"\",\n            ];\n        }\n        else if (language === \"html\") {\n            return [\n                // First, try to split along HTML tags\n                \"<body>\",\n                \"<div>\",\n                \"<p>\",\n                \"<br>\",\n                \"<li>\",\n                \"<h1>\",\n                \"<h2>\",\n                \"<h3>\",\n                \"<h4>\",\n                \"<h5>\",\n                \"<h6>\",\n                \"<span>\",\n                \"<table>\",\n                \"<tr>\",\n                \"<td>\",\n                \"<th>\",\n                \"<ul>\",\n                \"<ol>\",\n                \"<header>\",\n                \"<footer>\",\n                \"<nav>\",\n                // Head\n                \"<head>\",\n                \"<style>\",\n                \"<script>\",\n                \"<meta>\",\n                \"<title>\",\n                // Normal type of lines\n                \" \",\n                \"\",\n            ];\n        }\n        else if (language === \"sol\") {\n            return [\n                // Split along compiler informations definitions\n                \"\\npragma \",\n                \"\\nusing \",\n                // Split along contract definitions\n                \"\\ncontract \",\n                \"\\ninterface \",\n                \"\\nlibrary \",\n                // Split along method definitions\n                \"\\nconstructor \",\n                \"\\ntype \",\n                \"\\nfunction \",\n                \"\\nevent \",\n                \"\\nmodifier \",\n                \"\\nerror \",\n                \"\\nstruct \",\n                \"\\nenum \",\n                // Split along control flow statements\n                \"\\nif \",\n                \"\\nfor \",\n                \"\\nwhile \",\n                \"\\ndo while \",\n                \"\\nassembly \",\n                // Split by the normal type of lines\n                \"\\n\\n\",\n                \"\\n\",\n                \" \",\n                \"\",\n            ];\n        }\n        else {\n            throw new Error(`Language ${language} is not supported.`);\n        }\n    }\n}\n/**\n * Implementation of splitter which looks at tokens.\n */\nexport class TokenTextSplitter extends TextSplitter {\n    static lc_name() {\n        return \"TokenTextSplitter\";\n    }\n    constructor(fields) {\n        super(fields);\n        Object.defineProperty(this, \"encodingName\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"allowedSpecial\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"disallowedSpecial\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"tokenizer\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.encodingName = fields?.encodingName ?? \"gpt2\";\n        this.allowedSpecial = fields?.allowedSpecial ?? [];\n        this.disallowedSpecial = fields?.disallowedSpecial ?? \"all\";\n    }\n    async splitText(text) {\n        if (!this.tokenizer) {\n            this.tokenizer = await getEncoding(this.encodingName);\n        }\n        const splits = [];\n        const input_ids = this.tokenizer.encode(text, this.allowedSpecial, this.disallowedSpecial);\n        let start_idx = 0;\n        while (start_idx < input_ids.length) {\n            if (start_idx > 0) {\n                start_idx -= this.chunkOverlap;\n            }\n            const end_idx = Math.min(start_idx + this.chunkSize, input_ids.length);\n            const chunk_ids = input_ids.slice(start_idx, end_idx);\n            splits.push(this.tokenizer.decode(chunk_ids));\n            start_idx = end_idx;\n        }\n        return splits;\n    }\n}\nexport class MarkdownTextSplitter extends RecursiveCharacterTextSplitter {\n    constructor(fields) {\n        super({\n            ...fields,\n            separators: RecursiveCharacterTextSplitter.getSeparatorsForLanguage(\"markdown\"),\n        });\n    }\n}\nexport class LatexTextSplitter extends RecursiveCharacterTextSplitter {\n    constructor(fields) {\n        super({\n            ...fields,\n            separators: RecursiveCharacterTextSplitter.getSeparatorsForLanguage(\"latex\"),\n        });\n    }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}