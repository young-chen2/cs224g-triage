{"ast":null,"code":"export function parseJsonMarkdown(s, parser = parsePartialJson) {\n  // eslint-disable-next-line no-param-reassign\n  s = s.trim();\n  const match = /```(json)?(.*)```/s.exec(s);\n  if (!match) {\n    return parser(s);\n  } else {\n    return parser(match[2]);\n  }\n}\n// Adapted from https://github.com/KillianLucas/open-interpreter/blob/main/interpreter/core/llm/utils/parse_partial_json.py\n// MIT License\nexport function parsePartialJson(s) {\n  // If the input is undefined, return null to indicate failure.\n  if (typeof s === \"undefined\") {\n    return null;\n  }\n  // Attempt to parse the string as-is.\n  try {\n    return JSON.parse(s);\n  } catch (error) {\n    // Pass\n  }\n  // Initialize variables.\n  let new_s = \"\";\n  const stack = [];\n  let isInsideString = false;\n  let escaped = false;\n  // Process each character in the string one at a time.\n  for (let char of s) {\n    if (isInsideString) {\n      if (char === '\"' && !escaped) {\n        isInsideString = false;\n      } else if (char === \"\\n\" && !escaped) {\n        char = \"\\\\n\"; // Replace the newline character with the escape sequence.\n      } else if (char === \"\\\\\") {\n        escaped = !escaped;\n      } else {\n        escaped = false;\n      }\n    } else {\n      if (char === '\"') {\n        isInsideString = true;\n        escaped = false;\n      } else if (char === \"{\") {\n        stack.push(\"}\");\n      } else if (char === \"[\") {\n        stack.push(\"]\");\n      } else if (char === \"}\" || char === \"]\") {\n        if (stack && stack[stack.length - 1] === char) {\n          stack.pop();\n        } else {\n          // Mismatched closing character; the input is malformed.\n          return null;\n        }\n      }\n    }\n    // Append the processed character to the new string.\n    new_s += char;\n  }\n  // If we're still inside a string at the end of processing,\n  // we need to close the string.\n  if (isInsideString) {\n    new_s += '\"';\n  }\n  // Close any remaining open structures in the reverse order that they were opened.\n  for (let i = stack.length - 1; i >= 0; i -= 1) {\n    new_s += stack[i];\n  }\n  // Attempt to parse the modified string as JSON.\n  try {\n    return JSON.parse(new_s);\n  } catch (error) {\n    // If we still can't parse the string as JSON, return null to indicate failure.\n    return null;\n  }\n}","map":{"version":3,"names":["parseJsonMarkdown","s","parser","parsePartialJson","trim","match","exec","JSON","parse","error","new_s","stack","isInsideString","escaped","char","push","length","pop","i"],"sources":["/Users/youngchen/Downloads/cs224g-triage/node_modules/@langchain/core/dist/utils/json.js"],"sourcesContent":["export function parseJsonMarkdown(s, parser = parsePartialJson) {\n    // eslint-disable-next-line no-param-reassign\n    s = s.trim();\n    const match = /```(json)?(.*)```/s.exec(s);\n    if (!match) {\n        return parser(s);\n    }\n    else {\n        return parser(match[2]);\n    }\n}\n// Adapted from https://github.com/KillianLucas/open-interpreter/blob/main/interpreter/core/llm/utils/parse_partial_json.py\n// MIT License\nexport function parsePartialJson(s) {\n    // If the input is undefined, return null to indicate failure.\n    if (typeof s === \"undefined\") {\n        return null;\n    }\n    // Attempt to parse the string as-is.\n    try {\n        return JSON.parse(s);\n    }\n    catch (error) {\n        // Pass\n    }\n    // Initialize variables.\n    let new_s = \"\";\n    const stack = [];\n    let isInsideString = false;\n    let escaped = false;\n    // Process each character in the string one at a time.\n    for (let char of s) {\n        if (isInsideString) {\n            if (char === '\"' && !escaped) {\n                isInsideString = false;\n            }\n            else if (char === \"\\n\" && !escaped) {\n                char = \"\\\\n\"; // Replace the newline character with the escape sequence.\n            }\n            else if (char === \"\\\\\") {\n                escaped = !escaped;\n            }\n            else {\n                escaped = false;\n            }\n        }\n        else {\n            if (char === '\"') {\n                isInsideString = true;\n                escaped = false;\n            }\n            else if (char === \"{\") {\n                stack.push(\"}\");\n            }\n            else if (char === \"[\") {\n                stack.push(\"]\");\n            }\n            else if (char === \"}\" || char === \"]\") {\n                if (stack && stack[stack.length - 1] === char) {\n                    stack.pop();\n                }\n                else {\n                    // Mismatched closing character; the input is malformed.\n                    return null;\n                }\n            }\n        }\n        // Append the processed character to the new string.\n        new_s += char;\n    }\n    // If we're still inside a string at the end of processing,\n    // we need to close the string.\n    if (isInsideString) {\n        new_s += '\"';\n    }\n    // Close any remaining open structures in the reverse order that they were opened.\n    for (let i = stack.length - 1; i >= 0; i -= 1) {\n        new_s += stack[i];\n    }\n    // Attempt to parse the modified string as JSON.\n    try {\n        return JSON.parse(new_s);\n    }\n    catch (error) {\n        // If we still can't parse the string as JSON, return null to indicate failure.\n        return null;\n    }\n}\n"],"mappings":"AAAA,OAAO,SAASA,iBAAiBA,CAACC,CAAC,EAAEC,MAAM,GAAGC,gBAAgB,EAAE;EAC5D;EACAF,CAAC,GAAGA,CAAC,CAACG,IAAI,CAAC,CAAC;EACZ,MAAMC,KAAK,GAAG,oBAAoB,CAACC,IAAI,CAACL,CAAC,CAAC;EAC1C,IAAI,CAACI,KAAK,EAAE;IACR,OAAOH,MAAM,CAACD,CAAC,CAAC;EACpB,CAAC,MACI;IACD,OAAOC,MAAM,CAACG,KAAK,CAAC,CAAC,CAAC,CAAC;EAC3B;AACJ;AACA;AACA;AACA,OAAO,SAASF,gBAAgBA,CAACF,CAAC,EAAE;EAChC;EACA,IAAI,OAAOA,CAAC,KAAK,WAAW,EAAE;IAC1B,OAAO,IAAI;EACf;EACA;EACA,IAAI;IACA,OAAOM,IAAI,CAACC,KAAK,CAACP,CAAC,CAAC;EACxB,CAAC,CACD,OAAOQ,KAAK,EAAE;IACV;EAAA;EAEJ;EACA,IAAIC,KAAK,GAAG,EAAE;EACd,MAAMC,KAAK,GAAG,EAAE;EAChB,IAAIC,cAAc,GAAG,KAAK;EAC1B,IAAIC,OAAO,GAAG,KAAK;EACnB;EACA,KAAK,IAAIC,IAAI,IAAIb,CAAC,EAAE;IAChB,IAAIW,cAAc,EAAE;MAChB,IAAIE,IAAI,KAAK,GAAG,IAAI,CAACD,OAAO,EAAE;QAC1BD,cAAc,GAAG,KAAK;MAC1B,CAAC,MACI,IAAIE,IAAI,KAAK,IAAI,IAAI,CAACD,OAAO,EAAE;QAChCC,IAAI,GAAG,KAAK,CAAC,CAAC;MAClB,CAAC,MACI,IAAIA,IAAI,KAAK,IAAI,EAAE;QACpBD,OAAO,GAAG,CAACA,OAAO;MACtB,CAAC,MACI;QACDA,OAAO,GAAG,KAAK;MACnB;IACJ,CAAC,MACI;MACD,IAAIC,IAAI,KAAK,GAAG,EAAE;QACdF,cAAc,GAAG,IAAI;QACrBC,OAAO,GAAG,KAAK;MACnB,CAAC,MACI,IAAIC,IAAI,KAAK,GAAG,EAAE;QACnBH,KAAK,CAACI,IAAI,CAAC,GAAG,CAAC;MACnB,CAAC,MACI,IAAID,IAAI,KAAK,GAAG,EAAE;QACnBH,KAAK,CAACI,IAAI,CAAC,GAAG,CAAC;MACnB,CAAC,MACI,IAAID,IAAI,KAAK,GAAG,IAAIA,IAAI,KAAK,GAAG,EAAE;QACnC,IAAIH,KAAK,IAAIA,KAAK,CAACA,KAAK,CAACK,MAAM,GAAG,CAAC,CAAC,KAAKF,IAAI,EAAE;UAC3CH,KAAK,CAACM,GAAG,CAAC,CAAC;QACf,CAAC,MACI;UACD;UACA,OAAO,IAAI;QACf;MACJ;IACJ;IACA;IACAP,KAAK,IAAII,IAAI;EACjB;EACA;EACA;EACA,IAAIF,cAAc,EAAE;IAChBF,KAAK,IAAI,GAAG;EAChB;EACA;EACA,KAAK,IAAIQ,CAAC,GAAGP,KAAK,CAACK,MAAM,GAAG,CAAC,EAAEE,CAAC,IAAI,CAAC,EAAEA,CAAC,IAAI,CAAC,EAAE;IAC3CR,KAAK,IAAIC,KAAK,CAACO,CAAC,CAAC;EACrB;EACA;EACA,IAAI;IACA,OAAOX,IAAI,CAACC,KAAK,CAACE,KAAK,CAAC;EAC5B,CAAC,CACD,OAAOD,KAAK,EAAE;IACV;IACA,OAAO,IAAI;EACf;AACJ","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}