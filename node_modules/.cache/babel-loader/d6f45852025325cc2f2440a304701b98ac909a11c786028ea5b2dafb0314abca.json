{"ast":null,"code":"import { zodToJsonSchema } from \"zod-to-json-schema\";\nimport { v4 as uuidv4, validate as isUuid } from \"uuid\";\nimport { isRunnableInterface } from \"./utils.js\";\nimport { drawMermaid, drawMermaidPng } from \"./graph_mermaid.js\";\nfunction nodeDataStr(id, data) {\n  if (id !== undefined && !isUuid(id)) {\n    return id;\n  } else if (isRunnableInterface(data)) {\n    try {\n      let dataStr = data.getName();\n      dataStr = dataStr.startsWith(\"Runnable\") ? dataStr.slice(\"Runnable\".length) : dataStr;\n      return dataStr;\n    } catch (error) {\n      return data.getName();\n    }\n  } else {\n    return data.name ?? \"UnknownSchema\";\n  }\n}\nfunction nodeDataJson(node) {\n  // if node.data implements Runnable\n  if (isRunnableInterface(node.data)) {\n    return {\n      type: \"runnable\",\n      data: {\n        id: node.data.lc_id,\n        name: node.data.getName()\n      }\n    };\n  } else {\n    return {\n      type: \"schema\",\n      data: {\n        ...zodToJsonSchema(node.data.schema),\n        title: node.data.name\n      }\n    };\n  }\n}\nexport class Graph {\n  constructor(params) {\n    Object.defineProperty(this, \"nodes\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: {}\n    });\n    Object.defineProperty(this, \"edges\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: []\n    });\n    this.nodes = params?.nodes ?? this.nodes;\n    this.edges = params?.edges ?? this.edges;\n  }\n  // Convert the graph to a JSON-serializable format.\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  toJSON() {\n    const stableNodeIds = {};\n    Object.values(this.nodes).forEach((node, i) => {\n      stableNodeIds[node.id] = isUuid(node.id) ? i : node.id;\n    });\n    return {\n      nodes: Object.values(this.nodes).map(node => ({\n        id: stableNodeIds[node.id],\n        ...nodeDataJson(node)\n      })),\n      edges: this.edges.map(edge => {\n        const item = {\n          source: stableNodeIds[edge.source],\n          target: stableNodeIds[edge.target]\n        };\n        if (typeof edge.data !== \"undefined\") {\n          item.data = edge.data;\n        }\n        if (typeof edge.conditional !== \"undefined\") {\n          item.conditional = edge.conditional;\n        }\n        return item;\n      })\n    };\n  }\n  addNode(data, id,\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  metadata) {\n    if (id !== undefined && this.nodes[id] !== undefined) {\n      throw new Error(`Node with id ${id} already exists`);\n    }\n    const nodeId = id ?? uuidv4();\n    const node = {\n      id: nodeId,\n      data,\n      name: nodeDataStr(id, data),\n      metadata\n    };\n    this.nodes[nodeId] = node;\n    return node;\n  }\n  removeNode(node) {\n    // Remove the node from the nodes map\n    delete this.nodes[node.id];\n    // Filter out edges connected to the node\n    this.edges = this.edges.filter(edge => edge.source !== node.id && edge.target !== node.id);\n  }\n  addEdge(source, target, data, conditional) {\n    if (this.nodes[source.id] === undefined) {\n      throw new Error(`Source node ${source.id} not in graph`);\n    }\n    if (this.nodes[target.id] === undefined) {\n      throw new Error(`Target node ${target.id} not in graph`);\n    }\n    const edge = {\n      source: source.id,\n      target: target.id,\n      data,\n      conditional\n    };\n    this.edges.push(edge);\n    return edge;\n  }\n  firstNode() {\n    return _firstNode(this);\n  }\n  lastNode() {\n    return _lastNode(this);\n  }\n  /**\n   * Add all nodes and edges from another graph.\n   * Note this doesn't check for duplicates, nor does it connect the graphs.\n   */\n  extend(graph, prefix = \"\") {\n    let finalPrefix = prefix;\n    const nodeIds = Object.values(graph.nodes).map(node => node.id);\n    if (nodeIds.every(isUuid)) {\n      finalPrefix = \"\";\n    }\n    const prefixed = id => {\n      return finalPrefix ? `${finalPrefix}:${id}` : id;\n    };\n    Object.entries(graph.nodes).forEach(([key, value]) => {\n      this.nodes[prefixed(key)] = {\n        ...value,\n        id: prefixed(key)\n      };\n    });\n    const newEdges = graph.edges.map(edge => {\n      return {\n        ...edge,\n        source: prefixed(edge.source),\n        target: prefixed(edge.target)\n      };\n    });\n    // Add all edges from the other graph\n    this.edges = [...this.edges, ...newEdges];\n    const first = graph.firstNode();\n    const last = graph.lastNode();\n    return [first ? {\n      id: prefixed(first.id),\n      data: first.data\n    } : undefined, last ? {\n      id: prefixed(last.id),\n      data: last.data\n    } : undefined];\n  }\n  trimFirstNode() {\n    const firstNode = this.firstNode();\n    if (firstNode && _firstNode(this, [firstNode.id])) {\n      this.removeNode(firstNode);\n    }\n  }\n  trimLastNode() {\n    const lastNode = this.lastNode();\n    if (lastNode && _lastNode(this, [lastNode.id])) {\n      this.removeNode(lastNode);\n    }\n  }\n  /**\n   * Return a new graph with all nodes re-identified,\n   * using their unique, readable names where possible.\n   */\n  reid() {\n    const nodeLabels = Object.fromEntries(Object.values(this.nodes).map(node => [node.id, node.name]));\n    const nodeLabelCounts = new Map();\n    Object.values(nodeLabels).forEach(label => {\n      nodeLabelCounts.set(label, (nodeLabelCounts.get(label) || 0) + 1);\n    });\n    const getNodeId = nodeId => {\n      const label = nodeLabels[nodeId];\n      if (isUuid(nodeId) && nodeLabelCounts.get(label) === 1) {\n        return label;\n      } else {\n        return nodeId;\n      }\n    };\n    return new Graph({\n      nodes: Object.fromEntries(Object.entries(this.nodes).map(([id, node]) => [getNodeId(id), {\n        ...node,\n        id: getNodeId(id)\n      }])),\n      edges: this.edges.map(edge => ({\n        ...edge,\n        source: getNodeId(edge.source),\n        target: getNodeId(edge.target)\n      }))\n    });\n  }\n  drawMermaid(params) {\n    const {\n      withStyles,\n      curveStyle,\n      nodeColors = {\n        default: \"fill:#f2f0ff,line-height:1.2\",\n        first: \"fill-opacity:0\",\n        last: \"fill:#bfb6fc\"\n      },\n      wrapLabelNWords\n    } = params ?? {};\n    const graph = this.reid();\n    const firstNode = graph.firstNode();\n    const lastNode = graph.lastNode();\n    return drawMermaid(graph.nodes, graph.edges, {\n      firstNode: firstNode?.id,\n      lastNode: lastNode?.id,\n      withStyles,\n      curveStyle,\n      nodeColors,\n      wrapLabelNWords\n    });\n  }\n  async drawMermaidPng(params) {\n    const mermaidSyntax = this.drawMermaid(params);\n    return drawMermaidPng(mermaidSyntax, {\n      backgroundColor: params?.backgroundColor\n    });\n  }\n}\n/**\n * Find the single node that is not a target of any edge.\n * Exclude nodes/sources with ids in the exclude list.\n * If there is no such node, or there are multiple, return undefined.\n * When drawing the graph, this node would be the origin.\n */\nfunction _firstNode(graph, exclude = []) {\n  const targets = new Set(graph.edges.filter(edge => !exclude.includes(edge.source)).map(edge => edge.target));\n  const found = [];\n  for (const node of Object.values(graph.nodes)) {\n    if (!exclude.includes(node.id) && !targets.has(node.id)) {\n      found.push(node);\n    }\n  }\n  return found.length === 1 ? found[0] : undefined;\n}\n/**\n * Find the single node that is not a source of any edge.\n * Exclude nodes/targets with ids in the exclude list.\n * If there is no such node, or there are multiple, return undefined.\n * When drawing the graph, this node would be the destination.\n */\nfunction _lastNode(graph, exclude = []) {\n  const sources = new Set(graph.edges.filter(edge => !exclude.includes(edge.target)).map(edge => edge.source));\n  const found = [];\n  for (const node of Object.values(graph.nodes)) {\n    if (!exclude.includes(node.id) && !sources.has(node.id)) {\n      found.push(node);\n    }\n  }\n  return found.length === 1 ? found[0] : undefined;\n}","map":{"version":3,"names":["zodToJsonSchema","v4","uuidv4","validate","isUuid","isRunnableInterface","drawMermaid","drawMermaidPng","nodeDataStr","id","data","undefined","dataStr","getName","startsWith","slice","length","error","name","nodeDataJson","node","type","lc_id","schema","title","Graph","constructor","params","Object","defineProperty","enumerable","configurable","writable","value","nodes","edges","toJSON","stableNodeIds","values","forEach","i","map","edge","item","source","target","conditional","addNode","metadata","Error","nodeId","removeNode","filter","addEdge","push","firstNode","_firstNode","lastNode","_lastNode","extend","graph","prefix","finalPrefix","nodeIds","every","prefixed","entries","key","newEdges","first","last","trimFirstNode","trimLastNode","reid","nodeLabels","fromEntries","nodeLabelCounts","Map","label","set","get","getNodeId","withStyles","curveStyle","nodeColors","default","wrapLabelNWords","mermaidSyntax","backgroundColor","exclude","targets","Set","includes","found","has","sources"],"sources":["/Users/youngchen/Downloads/cs224g-triage/node_modules/@langchain/core/dist/runnables/graph.js"],"sourcesContent":["import { zodToJsonSchema } from \"zod-to-json-schema\";\nimport { v4 as uuidv4, validate as isUuid } from \"uuid\";\nimport { isRunnableInterface } from \"./utils.js\";\nimport { drawMermaid, drawMermaidPng } from \"./graph_mermaid.js\";\nfunction nodeDataStr(id, data) {\n    if (id !== undefined && !isUuid(id)) {\n        return id;\n    }\n    else if (isRunnableInterface(data)) {\n        try {\n            let dataStr = data.getName();\n            dataStr = dataStr.startsWith(\"Runnable\")\n                ? dataStr.slice(\"Runnable\".length)\n                : dataStr;\n            return dataStr;\n        }\n        catch (error) {\n            return data.getName();\n        }\n    }\n    else {\n        return data.name ?? \"UnknownSchema\";\n    }\n}\nfunction nodeDataJson(node) {\n    // if node.data implements Runnable\n    if (isRunnableInterface(node.data)) {\n        return {\n            type: \"runnable\",\n            data: {\n                id: node.data.lc_id,\n                name: node.data.getName(),\n            },\n        };\n    }\n    else {\n        return {\n            type: \"schema\",\n            data: { ...zodToJsonSchema(node.data.schema), title: node.data.name },\n        };\n    }\n}\nexport class Graph {\n    constructor(params) {\n        Object.defineProperty(this, \"nodes\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: {}\n        });\n        Object.defineProperty(this, \"edges\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: []\n        });\n        this.nodes = params?.nodes ?? this.nodes;\n        this.edges = params?.edges ?? this.edges;\n    }\n    // Convert the graph to a JSON-serializable format.\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    toJSON() {\n        const stableNodeIds = {};\n        Object.values(this.nodes).forEach((node, i) => {\n            stableNodeIds[node.id] = isUuid(node.id) ? i : node.id;\n        });\n        return {\n            nodes: Object.values(this.nodes).map((node) => ({\n                id: stableNodeIds[node.id],\n                ...nodeDataJson(node),\n            })),\n            edges: this.edges.map((edge) => {\n                const item = {\n                    source: stableNodeIds[edge.source],\n                    target: stableNodeIds[edge.target],\n                };\n                if (typeof edge.data !== \"undefined\") {\n                    item.data = edge.data;\n                }\n                if (typeof edge.conditional !== \"undefined\") {\n                    item.conditional = edge.conditional;\n                }\n                return item;\n            }),\n        };\n    }\n    addNode(data, id, \n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    metadata) {\n        if (id !== undefined && this.nodes[id] !== undefined) {\n            throw new Error(`Node with id ${id} already exists`);\n        }\n        const nodeId = id ?? uuidv4();\n        const node = {\n            id: nodeId,\n            data,\n            name: nodeDataStr(id, data),\n            metadata,\n        };\n        this.nodes[nodeId] = node;\n        return node;\n    }\n    removeNode(node) {\n        // Remove the node from the nodes map\n        delete this.nodes[node.id];\n        // Filter out edges connected to the node\n        this.edges = this.edges.filter((edge) => edge.source !== node.id && edge.target !== node.id);\n    }\n    addEdge(source, target, data, conditional) {\n        if (this.nodes[source.id] === undefined) {\n            throw new Error(`Source node ${source.id} not in graph`);\n        }\n        if (this.nodes[target.id] === undefined) {\n            throw new Error(`Target node ${target.id} not in graph`);\n        }\n        const edge = {\n            source: source.id,\n            target: target.id,\n            data,\n            conditional,\n        };\n        this.edges.push(edge);\n        return edge;\n    }\n    firstNode() {\n        return _firstNode(this);\n    }\n    lastNode() {\n        return _lastNode(this);\n    }\n    /**\n     * Add all nodes and edges from another graph.\n     * Note this doesn't check for duplicates, nor does it connect the graphs.\n     */\n    extend(graph, prefix = \"\") {\n        let finalPrefix = prefix;\n        const nodeIds = Object.values(graph.nodes).map((node) => node.id);\n        if (nodeIds.every(isUuid)) {\n            finalPrefix = \"\";\n        }\n        const prefixed = (id) => {\n            return finalPrefix ? `${finalPrefix}:${id}` : id;\n        };\n        Object.entries(graph.nodes).forEach(([key, value]) => {\n            this.nodes[prefixed(key)] = { ...value, id: prefixed(key) };\n        });\n        const newEdges = graph.edges.map((edge) => {\n            return {\n                ...edge,\n                source: prefixed(edge.source),\n                target: prefixed(edge.target),\n            };\n        });\n        // Add all edges from the other graph\n        this.edges = [...this.edges, ...newEdges];\n        const first = graph.firstNode();\n        const last = graph.lastNode();\n        return [\n            first ? { id: prefixed(first.id), data: first.data } : undefined,\n            last ? { id: prefixed(last.id), data: last.data } : undefined,\n        ];\n    }\n    trimFirstNode() {\n        const firstNode = this.firstNode();\n        if (firstNode && _firstNode(this, [firstNode.id])) {\n            this.removeNode(firstNode);\n        }\n    }\n    trimLastNode() {\n        const lastNode = this.lastNode();\n        if (lastNode && _lastNode(this, [lastNode.id])) {\n            this.removeNode(lastNode);\n        }\n    }\n    /**\n     * Return a new graph with all nodes re-identified,\n     * using their unique, readable names where possible.\n     */\n    reid() {\n        const nodeLabels = Object.fromEntries(Object.values(this.nodes).map((node) => [node.id, node.name]));\n        const nodeLabelCounts = new Map();\n        Object.values(nodeLabels).forEach((label) => {\n            nodeLabelCounts.set(label, (nodeLabelCounts.get(label) || 0) + 1);\n        });\n        const getNodeId = (nodeId) => {\n            const label = nodeLabels[nodeId];\n            if (isUuid(nodeId) && nodeLabelCounts.get(label) === 1) {\n                return label;\n            }\n            else {\n                return nodeId;\n            }\n        };\n        return new Graph({\n            nodes: Object.fromEntries(Object.entries(this.nodes).map(([id, node]) => [\n                getNodeId(id),\n                { ...node, id: getNodeId(id) },\n            ])),\n            edges: this.edges.map((edge) => ({\n                ...edge,\n                source: getNodeId(edge.source),\n                target: getNodeId(edge.target),\n            })),\n        });\n    }\n    drawMermaid(params) {\n        const { withStyles, curveStyle, nodeColors = {\n            default: \"fill:#f2f0ff,line-height:1.2\",\n            first: \"fill-opacity:0\",\n            last: \"fill:#bfb6fc\",\n        }, wrapLabelNWords, } = params ?? {};\n        const graph = this.reid();\n        const firstNode = graph.firstNode();\n        const lastNode = graph.lastNode();\n        return drawMermaid(graph.nodes, graph.edges, {\n            firstNode: firstNode?.id,\n            lastNode: lastNode?.id,\n            withStyles,\n            curveStyle,\n            nodeColors,\n            wrapLabelNWords,\n        });\n    }\n    async drawMermaidPng(params) {\n        const mermaidSyntax = this.drawMermaid(params);\n        return drawMermaidPng(mermaidSyntax, {\n            backgroundColor: params?.backgroundColor,\n        });\n    }\n}\n/**\n * Find the single node that is not a target of any edge.\n * Exclude nodes/sources with ids in the exclude list.\n * If there is no such node, or there are multiple, return undefined.\n * When drawing the graph, this node would be the origin.\n */\nfunction _firstNode(graph, exclude = []) {\n    const targets = new Set(graph.edges\n        .filter((edge) => !exclude.includes(edge.source))\n        .map((edge) => edge.target));\n    const found = [];\n    for (const node of Object.values(graph.nodes)) {\n        if (!exclude.includes(node.id) && !targets.has(node.id)) {\n            found.push(node);\n        }\n    }\n    return found.length === 1 ? found[0] : undefined;\n}\n/**\n * Find the single node that is not a source of any edge.\n * Exclude nodes/targets with ids in the exclude list.\n * If there is no such node, or there are multiple, return undefined.\n * When drawing the graph, this node would be the destination.\n */\nfunction _lastNode(graph, exclude = []) {\n    const sources = new Set(graph.edges\n        .filter((edge) => !exclude.includes(edge.target))\n        .map((edge) => edge.source));\n    const found = [];\n    for (const node of Object.values(graph.nodes)) {\n        if (!exclude.includes(node.id) && !sources.has(node.id)) {\n            found.push(node);\n        }\n    }\n    return found.length === 1 ? found[0] : undefined;\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}