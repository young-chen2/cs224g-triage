{"ast":null,"code":"import { makeParseableResponseFormat, makeParseableTool } from \"../lib/parser.mjs\";\nimport { zodToJsonSchema as _zodToJsonSchema } from \"../_vendor/zod-to-json-schema/index.mjs\";\nfunction zodToJsonSchema(schema, options) {\n  return _zodToJsonSchema(schema, {\n    openaiStrictMode: true,\n    name: options.name,\n    nameStrategy: 'duplicate-ref',\n    $refStrategy: 'extract-to-root',\n    nullableStrategy: 'property'\n  });\n}\n/**\n * Creates a chat completion `JSONSchema` response format object from\n * the given Zod schema.\n *\n * If this is passed to the `.parse()`, `.stream()` or `.runTools()`\n * chat completion methods then the response message will contain a\n * `.parsed` property that is the result of parsing the content with\n * the given Zod object.\n *\n * ```ts\n * const completion = await client.beta.chat.completions.parse({\n *    model: 'gpt-4o-2024-08-06',\n *    messages: [\n *      { role: 'system', content: 'You are a helpful math tutor.' },\n *      { role: 'user', content: 'solve 8x + 31 = 2' },\n *    ],\n *    response_format: zodResponseFormat(\n *      z.object({\n *        steps: z.array(z.object({\n *          explanation: z.string(),\n *          answer: z.string(),\n *        })),\n *        final_answer: z.string(),\n *      }),\n *      'math_answer',\n *    ),\n *  });\n *  const message = completion.choices[0]?.message;\n *  if (message?.parsed) {\n *    console.log(message.parsed);\n *    console.log(message.parsed.final_answer);\n * }\n * ```\n *\n * This can be passed directly to the `.create()` method but will not\n * result in any automatic parsing, you'll have to parse the response yourself.\n */\nexport function zodResponseFormat(zodObject, name, props) {\n  return makeParseableResponseFormat({\n    type: 'json_schema',\n    json_schema: {\n      ...props,\n      name,\n      strict: true,\n      schema: zodToJsonSchema(zodObject, {\n        name\n      })\n    }\n  }, content => zodObject.parse(JSON.parse(content)));\n}\n/**\n * Creates a chat completion `function` tool that can be invoked\n * automatically by the chat completion `.runTools()` method or automatically\n * parsed by `.parse()` / `.stream()`.\n */\nexport function zodFunction(options) {\n  // @ts-expect-error TODO\n  return makeParseableTool({\n    type: 'function',\n    function: {\n      name: options.name,\n      parameters: zodToJsonSchema(options.parameters, {\n        name: options.name\n      }),\n      strict: true,\n      ...(options.description ? {\n        description: options.description\n      } : undefined)\n    }\n  }, {\n    callback: options.function,\n    parser: args => options.parameters.parse(JSON.parse(args))\n  });\n}","map":{"version":3,"names":["makeParseableResponseFormat","makeParseableTool","zodToJsonSchema","_zodToJsonSchema","schema","options","openaiStrictMode","name","nameStrategy","$refStrategy","nullableStrategy","zodResponseFormat","zodObject","props","type","json_schema","strict","content","parse","JSON","zodFunction","function","parameters","description","undefined","callback","parser","args"],"sources":["/Users/youngchen/Downloads/cs224g-triage/node_modules/openai/src/helpers/zod.ts"],"sourcesContent":["import { ResponseFormatJSONSchema } from '../resources/index';\nimport type { infer as zodInfer, ZodType } from 'zod';\nimport {\n  AutoParseableResponseFormat,\n  AutoParseableTool,\n  makeParseableResponseFormat,\n  makeParseableTool,\n} from '../lib/parser';\nimport { zodToJsonSchema as _zodToJsonSchema } from '../_vendor/zod-to-json-schema';\n\nfunction zodToJsonSchema(schema: ZodType, options: { name: string }): Record<string, unknown> {\n  return _zodToJsonSchema(schema, {\n    openaiStrictMode: true,\n    name: options.name,\n    nameStrategy: 'duplicate-ref',\n    $refStrategy: 'extract-to-root',\n    nullableStrategy: 'property',\n  });\n}\n\n/**\n * Creates a chat completion `JSONSchema` response format object from\n * the given Zod schema.\n *\n * If this is passed to the `.parse()`, `.stream()` or `.runTools()`\n * chat completion methods then the response message will contain a\n * `.parsed` property that is the result of parsing the content with\n * the given Zod object.\n *\n * ```ts\n * const completion = await client.beta.chat.completions.parse({\n *    model: 'gpt-4o-2024-08-06',\n *    messages: [\n *      { role: 'system', content: 'You are a helpful math tutor.' },\n *      { role: 'user', content: 'solve 8x + 31 = 2' },\n *    ],\n *    response_format: zodResponseFormat(\n *      z.object({\n *        steps: z.array(z.object({\n *          explanation: z.string(),\n *          answer: z.string(),\n *        })),\n *        final_answer: z.string(),\n *      }),\n *      'math_answer',\n *    ),\n *  });\n *  const message = completion.choices[0]?.message;\n *  if (message?.parsed) {\n *    console.log(message.parsed);\n *    console.log(message.parsed.final_answer);\n * }\n * ```\n *\n * This can be passed directly to the `.create()` method but will not\n * result in any automatic parsing, you'll have to parse the response yourself.\n */\nexport function zodResponseFormat<ZodInput extends ZodType>(\n  zodObject: ZodInput,\n  name: string,\n  props?: Omit<ResponseFormatJSONSchema.JSONSchema, 'schema' | 'strict' | 'name'>,\n): AutoParseableResponseFormat<zodInfer<ZodInput>> {\n  return makeParseableResponseFormat(\n    {\n      type: 'json_schema',\n      json_schema: {\n        ...props,\n        name,\n        strict: true,\n        schema: zodToJsonSchema(zodObject, { name }),\n      },\n    },\n    (content) => zodObject.parse(JSON.parse(content)),\n  );\n}\n\n/**\n * Creates a chat completion `function` tool that can be invoked\n * automatically by the chat completion `.runTools()` method or automatically\n * parsed by `.parse()` / `.stream()`.\n */\nexport function zodFunction<Parameters extends ZodType>(options: {\n  name: string;\n  parameters: Parameters;\n  function?: ((args: zodInfer<Parameters>) => unknown | Promise<unknown>) | undefined;\n  description?: string | undefined;\n}): AutoParseableTool<{\n  arguments: Parameters;\n  name: string;\n  function: (args: zodInfer<Parameters>) => unknown;\n}> {\n  // @ts-expect-error TODO\n  return makeParseableTool<any>(\n    {\n      type: 'function',\n      function: {\n        name: options.name,\n        parameters: zodToJsonSchema(options.parameters, { name: options.name }),\n        strict: true,\n        ...(options.description ? { description: options.description } : undefined),\n      },\n    },\n    {\n      callback: options.function,\n      parser: (args) => options.parameters.parse(JSON.parse(args)),\n    },\n  );\n}\n"],"mappings":"SAKEA,2BAA2B,EAC3BC,iBAAiB,QAClB;SACQC,eAAe,IAAIC,gBAAgB,QAAE;AAE9C,SAASD,eAAeA,CAACE,MAAe,EAAEC,OAAyB;EACjE,OAAOF,gBAAgB,CAACC,MAAM,EAAE;IAC9BE,gBAAgB,EAAE,IAAI;IACtBC,IAAI,EAAEF,OAAO,CAACE,IAAI;IAClBC,YAAY,EAAE,eAAe;IAC7BC,YAAY,EAAE,iBAAiB;IAC/BC,gBAAgB,EAAE;GACnB,CAAC;AACJ;AAEA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAqCA,OAAM,SAAUC,iBAAiBA,CAC/BC,SAAmB,EACnBL,IAAY,EACZM,KAA+E;EAE/E,OAAOb,2BAA2B,CAChC;IACEc,IAAI,EAAE,aAAa;IACnBC,WAAW,EAAE;MACX,GAAGF,KAAK;MACRN,IAAI;MACJS,MAAM,EAAE,IAAI;MACZZ,MAAM,EAAEF,eAAe,CAACU,SAAS,EAAE;QAAEL;MAAI,CAAE;;GAE9C,EACAU,OAAO,IAAKL,SAAS,CAACM,KAAK,CAACC,IAAI,CAACD,KAAK,CAACD,OAAO,CAAC,CAAC,CAClD;AACH;AAEA;;;;;AAKA,OAAM,SAAUG,WAAWA,CAA6Bf,OAKvD;EAKC;EACA,OAAOJ,iBAAiB,CACtB;IACEa,IAAI,EAAE,UAAU;IAChBO,QAAQ,EAAE;MACRd,IAAI,EAAEF,OAAO,CAACE,IAAI;MAClBe,UAAU,EAAEpB,eAAe,CAACG,OAAO,CAACiB,UAAU,EAAE;QAAEf,IAAI,EAAEF,OAAO,CAACE;MAAI,CAAE,CAAC;MACvES,MAAM,EAAE,IAAI;MACZ,IAAIX,OAAO,CAACkB,WAAW,GAAG;QAAEA,WAAW,EAAElB,OAAO,CAACkB;MAAW,CAAE,GAAGC,SAAS;;GAE7E,EACD;IACEC,QAAQ,EAAEpB,OAAO,CAACgB,QAAQ;IAC1BK,MAAM,EAAGC,IAAI,IAAKtB,OAAO,CAACiB,UAAU,CAACJ,KAAK,CAACC,IAAI,CAACD,KAAK,CAACS,IAAI,CAAC;GAC5D,CACF;AACH","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}