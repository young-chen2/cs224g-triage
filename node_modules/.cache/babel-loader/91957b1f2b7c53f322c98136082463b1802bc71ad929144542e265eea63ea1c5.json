{"ast":null,"code":"import { z } from \"zod\";\nimport { zodToJsonSchema } from \"zod-to-json-schema\";\nimport { BaseOutputParser, OutputParserException } from \"@langchain/core/output_parsers\";\nexport class StructuredOutputParser extends BaseOutputParser {\n  static lc_name() {\n    return \"StructuredOutputParser\";\n  }\n  toJSON() {\n    return this.toJSONNotImplemented();\n  }\n  constructor(schema) {\n    super(schema);\n    Object.defineProperty(this, \"schema\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: schema\n    });\n    Object.defineProperty(this, \"lc_namespace\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: [\"langchain\", \"output_parsers\", \"structured\"]\n    });\n  }\n  /**\n   * Creates a new StructuredOutputParser from a Zod schema.\n   * @param schema The Zod schema which the output should match\n   * @returns A new instance of StructuredOutputParser.\n   */\n  static fromZodSchema(schema) {\n    return new this(schema);\n  }\n  /**\n   * Creates a new StructuredOutputParser from a set of names and\n   * descriptions.\n   * @param schemas An object where each key is a name and each value is a description\n   * @returns A new instance of StructuredOutputParser.\n   */\n  static fromNamesAndDescriptions(schemas) {\n    const zodSchema = z.object(Object.fromEntries(Object.entries(schemas).map(([name, description]) => [name, z.string().describe(description)])));\n    return new this(zodSchema);\n  }\n  /**\n   * Returns a markdown code snippet with a JSON object formatted according\n   * to the schema.\n   * @param options Optional. The options for formatting the instructions\n   * @returns A markdown code snippet with a JSON object formatted according to the schema.\n   */\n  getFormatInstructions() {\n    return `You must format your output as a JSON value that adheres to a given \"JSON Schema\" instance.\n\n\"JSON Schema\" is a declarative language that allows you to annotate and validate JSON documents.\n\nFor example, the example \"JSON Schema\" instance {{\"properties\": {{\"foo\": {{\"description\": \"a list of test words\", \"type\": \"array\", \"items\": {{\"type\": \"string\"}}}}}}, \"required\": [\"foo\"]}}}}\nwould match an object with one required property, \"foo\". The \"type\" property specifies \"foo\" must be an \"array\", and the \"description\" property semantically describes it as \"a list of test words\". The items within \"foo\" must be strings.\nThus, the object {{\"foo\": [\"bar\", \"baz\"]}} is a well-formatted instance of this example \"JSON Schema\". The object {{\"properties\": {{\"foo\": [\"bar\", \"baz\"]}}}} is not well-formatted.\n\nYour output will be parsed and type-checked according to the provided schema instance, so make sure all fields in your output match the schema exactly and there are no trailing commas!\n\nHere is the JSON Schema instance your output must adhere to. Include the enclosing markdown codeblock:\n\\`\\`\\`json\n${JSON.stringify(zodToJsonSchema(this.schema))}\n\\`\\`\\`\n`;\n  }\n  /**\n   * Parses the given text according to the schema.\n   * @param text The text to parse\n   * @returns The parsed output.\n   */\n  async parse(text) {\n    try {\n      const json = text.includes(\"```\") ? text.trim().split(/```(?:json)?/)[1] : text.trim();\n      return await this.schema.parseAsync(JSON.parse(json));\n    } catch (e) {\n      try {\n        return await this.schema.parseAsync(JSON.parse(text.trim()));\n      } catch (e2) {\n        throw new OutputParserException(`Failed to parse. Text: \"${text}\". Error: ${e2}`, text);\n      }\n    }\n  }\n}\n/**\n * A specific type of `StructuredOutputParser` that parses JSON data\n * formatted as a markdown code snippet.\n */\nexport class JsonMarkdownStructuredOutputParser extends StructuredOutputParser {\n  static lc_name() {\n    return \"JsonMarkdownStructuredOutputParser\";\n  }\n  getFormatInstructions(options) {\n    const interpolationDepth = options?.interpolationDepth ?? 1;\n    if (interpolationDepth < 1) {\n      throw new Error(\"f string interpolation depth must be at least 1\");\n    }\n    return `Return a markdown code snippet with a JSON object formatted to look like:\\n\\`\\`\\`json\\n${this._schemaToInstruction(zodToJsonSchema(this.schema)).replaceAll(\"{\", \"{\".repeat(interpolationDepth)).replaceAll(\"}\", \"}\".repeat(interpolationDepth))}\\n\\`\\`\\``;\n  }\n  _schemaToInstruction(schemaInput, indent = 2) {\n    const schema = schemaInput;\n    if (\"type\" in schema) {\n      let nullable = false;\n      let type;\n      if (Array.isArray(schema.type)) {\n        const nullIdx = schema.type.findIndex(type => type === \"null\");\n        if (nullIdx !== -1) {\n          nullable = true;\n          schema.type.splice(nullIdx, 1);\n        }\n        type = schema.type.join(\" | \");\n      } else {\n        type = schema.type;\n      }\n      if (schema.type === \"object\" && schema.properties) {\n        const description = schema.description ? ` // ${schema.description}` : \"\";\n        const properties = Object.entries(schema.properties).map(([key, value]) => {\n          const isOptional = schema.required?.includes(key) ? \"\" : \" (optional)\";\n          return `${\" \".repeat(indent)}\"${key}\": ${this._schemaToInstruction(value, indent + 2)}${isOptional}`;\n        }).join(\"\\n\");\n        return `{\\n${properties}\\n${\" \".repeat(indent - 2)}}${description}`;\n      }\n      if (schema.type === \"array\" && schema.items) {\n        const description = schema.description ? ` // ${schema.description}` : \"\";\n        return `array[\\n${\" \".repeat(indent)}${this._schemaToInstruction(schema.items, indent + 2)}\\n${\" \".repeat(indent - 2)}] ${description}`;\n      }\n      const isNullable = nullable ? \" (nullable)\" : \"\";\n      const description = schema.description ? ` // ${schema.description}` : \"\";\n      return `${type}${description}${isNullable}`;\n    }\n    if (\"anyOf\" in schema) {\n      return schema.anyOf.map(s => this._schemaToInstruction(s, indent)).join(`\\n${\" \".repeat(indent - 2)}`);\n    }\n    throw new Error(\"unsupported schema type\");\n  }\n  static fromZodSchema(schema) {\n    return new this(schema);\n  }\n  static fromNamesAndDescriptions(schemas) {\n    const zodSchema = z.object(Object.fromEntries(Object.entries(schemas).map(([name, description]) => [name, z.string().describe(description)])));\n    return new this(zodSchema);\n  }\n}\n/**\n * A type of `StructuredOutputParser` that handles asymmetric input and\n * output schemas.\n */\nexport class AsymmetricStructuredOutputParser extends BaseOutputParser {\n  constructor({\n    inputSchema\n  }) {\n    super(...arguments);\n    Object.defineProperty(this, \"structuredInputParser\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    this.structuredInputParser = new JsonMarkdownStructuredOutputParser(inputSchema);\n  }\n  async parse(text) {\n    let parsedInput;\n    try {\n      parsedInput = await this.structuredInputParser.parse(text);\n    } catch (e) {\n      throw new OutputParserException(`Failed to parse. Text: \"${text}\". Error: ${e}`, text);\n    }\n    return this.outputProcessor(parsedInput);\n  }\n  getFormatInstructions() {\n    return this.structuredInputParser.getFormatInstructions();\n  }\n}","map":{"version":3,"names":["z","zodToJsonSchema","BaseOutputParser","OutputParserException","StructuredOutputParser","lc_name","toJSON","toJSONNotImplemented","constructor","schema","Object","defineProperty","enumerable","configurable","writable","value","fromZodSchema","fromNamesAndDescriptions","schemas","zodSchema","object","fromEntries","entries","map","name","description","string","describe","getFormatInstructions","JSON","stringify","parse","text","json","includes","trim","split","parseAsync","e","e2","JsonMarkdownStructuredOutputParser","options","interpolationDepth","Error","_schemaToInstruction","replaceAll","repeat","schemaInput","indent","nullable","type","Array","isArray","nullIdx","findIndex","splice","join","properties","key","isOptional","required","items","isNullable","anyOf","s","AsymmetricStructuredOutputParser","inputSchema","arguments","structuredInputParser","parsedInput","outputProcessor"],"sources":["/Users/youngchen/Downloads/cs224g-triage/node_modules/langchain/dist/output_parsers/structured.js"],"sourcesContent":["import { z } from \"zod\";\nimport { zodToJsonSchema, } from \"zod-to-json-schema\";\nimport { BaseOutputParser, OutputParserException, } from \"@langchain/core/output_parsers\";\nexport class StructuredOutputParser extends BaseOutputParser {\n    static lc_name() {\n        return \"StructuredOutputParser\";\n    }\n    toJSON() {\n        return this.toJSONNotImplemented();\n    }\n    constructor(schema) {\n        super(schema);\n        Object.defineProperty(this, \"schema\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: schema\n        });\n        Object.defineProperty(this, \"lc_namespace\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: [\"langchain\", \"output_parsers\", \"structured\"]\n        });\n    }\n    /**\n     * Creates a new StructuredOutputParser from a Zod schema.\n     * @param schema The Zod schema which the output should match\n     * @returns A new instance of StructuredOutputParser.\n     */\n    static fromZodSchema(schema) {\n        return new this(schema);\n    }\n    /**\n     * Creates a new StructuredOutputParser from a set of names and\n     * descriptions.\n     * @param schemas An object where each key is a name and each value is a description\n     * @returns A new instance of StructuredOutputParser.\n     */\n    static fromNamesAndDescriptions(schemas) {\n        const zodSchema = z.object(Object.fromEntries(Object.entries(schemas).map(([name, description]) => [name, z.string().describe(description)])));\n        return new this(zodSchema);\n    }\n    /**\n     * Returns a markdown code snippet with a JSON object formatted according\n     * to the schema.\n     * @param options Optional. The options for formatting the instructions\n     * @returns A markdown code snippet with a JSON object formatted according to the schema.\n     */\n    getFormatInstructions() {\n        return `You must format your output as a JSON value that adheres to a given \"JSON Schema\" instance.\n\n\"JSON Schema\" is a declarative language that allows you to annotate and validate JSON documents.\n\nFor example, the example \"JSON Schema\" instance {{\"properties\": {{\"foo\": {{\"description\": \"a list of test words\", \"type\": \"array\", \"items\": {{\"type\": \"string\"}}}}}}, \"required\": [\"foo\"]}}}}\nwould match an object with one required property, \"foo\". The \"type\" property specifies \"foo\" must be an \"array\", and the \"description\" property semantically describes it as \"a list of test words\". The items within \"foo\" must be strings.\nThus, the object {{\"foo\": [\"bar\", \"baz\"]}} is a well-formatted instance of this example \"JSON Schema\". The object {{\"properties\": {{\"foo\": [\"bar\", \"baz\"]}}}} is not well-formatted.\n\nYour output will be parsed and type-checked according to the provided schema instance, so make sure all fields in your output match the schema exactly and there are no trailing commas!\n\nHere is the JSON Schema instance your output must adhere to. Include the enclosing markdown codeblock:\n\\`\\`\\`json\n${JSON.stringify(zodToJsonSchema(this.schema))}\n\\`\\`\\`\n`;\n    }\n    /**\n     * Parses the given text according to the schema.\n     * @param text The text to parse\n     * @returns The parsed output.\n     */\n    async parse(text) {\n        try {\n            const json = text.includes(\"```\")\n                ? text.trim().split(/```(?:json)?/)[1]\n                : text.trim();\n            return await this.schema.parseAsync(JSON.parse(json));\n        }\n        catch (e) {\n            try {\n                return await this.schema.parseAsync(JSON.parse(text.trim()));\n            }\n            catch (e2) {\n                throw new OutputParserException(`Failed to parse. Text: \"${text}\". Error: ${e2}`, text);\n            }\n        }\n    }\n}\n/**\n * A specific type of `StructuredOutputParser` that parses JSON data\n * formatted as a markdown code snippet.\n */\nexport class JsonMarkdownStructuredOutputParser extends StructuredOutputParser {\n    static lc_name() {\n        return \"JsonMarkdownStructuredOutputParser\";\n    }\n    getFormatInstructions(options) {\n        const interpolationDepth = options?.interpolationDepth ?? 1;\n        if (interpolationDepth < 1) {\n            throw new Error(\"f string interpolation depth must be at least 1\");\n        }\n        return `Return a markdown code snippet with a JSON object formatted to look like:\\n\\`\\`\\`json\\n${this._schemaToInstruction(zodToJsonSchema(this.schema))\n            .replaceAll(\"{\", \"{\".repeat(interpolationDepth))\n            .replaceAll(\"}\", \"}\".repeat(interpolationDepth))}\\n\\`\\`\\``;\n    }\n    _schemaToInstruction(schemaInput, indent = 2) {\n        const schema = schemaInput;\n        if (\"type\" in schema) {\n            let nullable = false;\n            let type;\n            if (Array.isArray(schema.type)) {\n                const nullIdx = schema.type.findIndex((type) => type === \"null\");\n                if (nullIdx !== -1) {\n                    nullable = true;\n                    schema.type.splice(nullIdx, 1);\n                }\n                type = schema.type.join(\" | \");\n            }\n            else {\n                type = schema.type;\n            }\n            if (schema.type === \"object\" && schema.properties) {\n                const description = schema.description\n                    ? ` // ${schema.description}`\n                    : \"\";\n                const properties = Object.entries(schema.properties)\n                    .map(([key, value]) => {\n                    const isOptional = schema.required?.includes(key)\n                        ? \"\"\n                        : \" (optional)\";\n                    return `${\" \".repeat(indent)}\"${key}\": ${this._schemaToInstruction(value, indent + 2)}${isOptional}`;\n                })\n                    .join(\"\\n\");\n                return `{\\n${properties}\\n${\" \".repeat(indent - 2)}}${description}`;\n            }\n            if (schema.type === \"array\" && schema.items) {\n                const description = schema.description\n                    ? ` // ${schema.description}`\n                    : \"\";\n                return `array[\\n${\" \".repeat(indent)}${this._schemaToInstruction(schema.items, indent + 2)}\\n${\" \".repeat(indent - 2)}] ${description}`;\n            }\n            const isNullable = nullable ? \" (nullable)\" : \"\";\n            const description = schema.description ? ` // ${schema.description}` : \"\";\n            return `${type}${description}${isNullable}`;\n        }\n        if (\"anyOf\" in schema) {\n            return schema.anyOf\n                .map((s) => this._schemaToInstruction(s, indent))\n                .join(`\\n${\" \".repeat(indent - 2)}`);\n        }\n        throw new Error(\"unsupported schema type\");\n    }\n    static fromZodSchema(schema) {\n        return new this(schema);\n    }\n    static fromNamesAndDescriptions(schemas) {\n        const zodSchema = z.object(Object.fromEntries(Object.entries(schemas).map(([name, description]) => [name, z.string().describe(description)])));\n        return new this(zodSchema);\n    }\n}\n/**\n * A type of `StructuredOutputParser` that handles asymmetric input and\n * output schemas.\n */\nexport class AsymmetricStructuredOutputParser extends BaseOutputParser {\n    constructor({ inputSchema }) {\n        super(...arguments);\n        Object.defineProperty(this, \"structuredInputParser\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.structuredInputParser = new JsonMarkdownStructuredOutputParser(inputSchema);\n    }\n    async parse(text) {\n        let parsedInput;\n        try {\n            parsedInput = await this.structuredInputParser.parse(text);\n        }\n        catch (e) {\n            throw new OutputParserException(`Failed to parse. Text: \"${text}\". Error: ${e}`, text);\n        }\n        return this.outputProcessor(parsedInput);\n    }\n    getFormatInstructions() {\n        return this.structuredInputParser.getFormatInstructions();\n    }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}