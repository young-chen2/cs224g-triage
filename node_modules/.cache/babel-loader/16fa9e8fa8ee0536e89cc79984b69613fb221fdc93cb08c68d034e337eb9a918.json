{"ast":null,"code":"import { applyPatch } from \"../utils/fast-json-patch/index.js\";\nimport { BaseTracer } from \"./base.js\";\nimport { IterableReadableStream } from \"../utils/stream.js\";\nimport { AIMessageChunk } from \"../messages/ai.js\";\n/**\n * List of jsonpatch JSONPatchOperations, which describe how to create the run state\n * from an empty dict. This is the minimal representation of the log, designed to\n * be serialized as JSON and sent over the wire to reconstruct the log on the other\n * side. Reconstruction of the state can be done with any jsonpatch-compliant library,\n * see https://jsonpatch.com for more information.\n */\nexport class RunLogPatch {\n  constructor(fields) {\n    Object.defineProperty(this, \"ops\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    this.ops = fields.ops ?? [];\n  }\n  concat(other) {\n    const ops = this.ops.concat(other.ops);\n    const states = applyPatch({}, ops);\n    // eslint-disable-next-line @typescript-eslint/no-use-before-define\n    return new RunLog({\n      ops,\n      state: states[states.length - 1].newDocument\n    });\n  }\n}\nexport class RunLog extends RunLogPatch {\n  constructor(fields) {\n    super(fields);\n    Object.defineProperty(this, \"state\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    this.state = fields.state;\n  }\n  concat(other) {\n    const ops = this.ops.concat(other.ops);\n    const states = applyPatch(this.state, other.ops);\n    return new RunLog({\n      ops,\n      state: states[states.length - 1].newDocument\n    });\n  }\n  static fromRunLogPatch(patch) {\n    const states = applyPatch({}, patch.ops);\n    // eslint-disable-next-line @typescript-eslint/no-use-before-define\n    return new RunLog({\n      ops: patch.ops,\n      state: states[states.length - 1].newDocument\n    });\n  }\n}\nexport const isLogStreamHandler = handler => handler.name === \"log_stream_tracer\";\n/**\n * Extract standardized inputs from a run.\n *\n * Standardizes the inputs based on the type of the runnable used.\n *\n * @param run - Run object\n * @param schemaFormat - The schema format to use.\n *\n * @returns Valid inputs are only dict. By conventions, inputs always represented\n * invocation using named arguments.\n * A null means that the input is not yet known!\n */\nasync function _getStandardizedInputs(run, schemaFormat) {\n  if (schemaFormat === \"original\") {\n    throw new Error(\"Do not assign inputs with original schema drop the key for now. \" + \"When inputs are added to streamLog they should be added with \" + \"standardized schema for streaming events.\");\n  }\n  const {\n    inputs\n  } = run;\n  if ([\"retriever\", \"llm\", \"prompt\"].includes(run.run_type)) {\n    return inputs;\n  }\n  if (Object.keys(inputs).length === 1 && inputs?.input === \"\") {\n    return undefined;\n  }\n  // new style chains\n  // These nest an additional 'input' key inside the 'inputs' to make sure\n  // the input is always a dict. We need to unpack and user the inner value.\n  // We should try to fix this in Runnables and callbacks/tracers\n  // Runnables should be using a null type here not a placeholder\n  // dict.\n  return inputs.input;\n}\nasync function _getStandardizedOutputs(run, schemaFormat) {\n  const {\n    outputs\n  } = run;\n  if (schemaFormat === \"original\") {\n    // Return the old schema, without standardizing anything\n    return outputs;\n  }\n  if ([\"retriever\", \"llm\", \"prompt\"].includes(run.run_type)) {\n    return outputs;\n  }\n  // TODO: Remove this hacky check\n  if (outputs !== undefined && Object.keys(outputs).length === 1 && outputs?.output !== undefined) {\n    return outputs.output;\n  }\n  return outputs;\n}\nfunction isChatGenerationChunk(x) {\n  return x !== undefined && x.message !== undefined;\n}\n/**\n * Class that extends the `BaseTracer` class from the\n * `langchain.callbacks.tracers.base` module. It represents a callback\n * handler that logs the execution of runs and emits `RunLog` instances to a\n * `RunLogStream`.\n */\nexport class LogStreamCallbackHandler extends BaseTracer {\n  constructor(fields) {\n    super({\n      _awaitHandler: true,\n      ...fields\n    });\n    Object.defineProperty(this, \"autoClose\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: true\n    });\n    Object.defineProperty(this, \"includeNames\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, \"includeTypes\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, \"includeTags\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, \"excludeNames\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, \"excludeTypes\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, \"excludeTags\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, \"_schemaFormat\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: \"original\"\n    });\n    Object.defineProperty(this, \"rootId\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, \"keyMapByRunId\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: {}\n    });\n    Object.defineProperty(this, \"counterMapByRunName\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: {}\n    });\n    Object.defineProperty(this, \"transformStream\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, \"writer\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, \"receiveStream\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, \"name\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: \"log_stream_tracer\"\n    });\n    Object.defineProperty(this, \"lc_prefer_streaming\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: true\n    });\n    this.autoClose = fields?.autoClose ?? true;\n    this.includeNames = fields?.includeNames;\n    this.includeTypes = fields?.includeTypes;\n    this.includeTags = fields?.includeTags;\n    this.excludeNames = fields?.excludeNames;\n    this.excludeTypes = fields?.excludeTypes;\n    this.excludeTags = fields?.excludeTags;\n    this._schemaFormat = fields?._schemaFormat ?? this._schemaFormat;\n    this.transformStream = new TransformStream();\n    this.writer = this.transformStream.writable.getWriter();\n    this.receiveStream = IterableReadableStream.fromReadableStream(this.transformStream.readable);\n  }\n  [Symbol.asyncIterator]() {\n    return this.receiveStream;\n  }\n  async persistRun(_run) {\n    // This is a legacy method only called once for an entire run tree\n    // and is therefore not useful here\n  }\n  _includeRun(run) {\n    if (run.id === this.rootId) {\n      return false;\n    }\n    const runTags = run.tags ?? [];\n    let include = this.includeNames === undefined && this.includeTags === undefined && this.includeTypes === undefined;\n    if (this.includeNames !== undefined) {\n      include = include || this.includeNames.includes(run.name);\n    }\n    if (this.includeTypes !== undefined) {\n      include = include || this.includeTypes.includes(run.run_type);\n    }\n    if (this.includeTags !== undefined) {\n      include = include || runTags.find(tag => this.includeTags?.includes(tag)) !== undefined;\n    }\n    if (this.excludeNames !== undefined) {\n      include = include && !this.excludeNames.includes(run.name);\n    }\n    if (this.excludeTypes !== undefined) {\n      include = include && !this.excludeTypes.includes(run.run_type);\n    }\n    if (this.excludeTags !== undefined) {\n      include = include && runTags.every(tag => !this.excludeTags?.includes(tag));\n    }\n    return include;\n  }\n  async *tapOutputIterable(runId, output) {\n    // Tap an output async iterator to stream its values to the log.\n    for await (const chunk of output) {\n      // root run is handled in .streamLog()\n      if (runId !== this.rootId) {\n        // if we can't find the run silently ignore\n        // eg. because this run wasn't included in the log\n        const key = this.keyMapByRunId[runId];\n        if (key) {\n          await this.writer.write(new RunLogPatch({\n            ops: [{\n              op: \"add\",\n              path: `/logs/${key}/streamed_output/-`,\n              value: chunk\n            }]\n          }));\n        }\n      }\n      yield chunk;\n    }\n  }\n  async onRunCreate(run) {\n    if (this.rootId === undefined) {\n      this.rootId = run.id;\n      await this.writer.write(new RunLogPatch({\n        ops: [{\n          op: \"replace\",\n          path: \"\",\n          value: {\n            id: run.id,\n            name: run.name,\n            type: run.run_type,\n            streamed_output: [],\n            final_output: undefined,\n            logs: {}\n          }\n        }]\n      }));\n    }\n    if (!this._includeRun(run)) {\n      return;\n    }\n    if (this.counterMapByRunName[run.name] === undefined) {\n      this.counterMapByRunName[run.name] = 0;\n    }\n    this.counterMapByRunName[run.name] += 1;\n    const count = this.counterMapByRunName[run.name];\n    this.keyMapByRunId[run.id] = count === 1 ? run.name : `${run.name}:${count}`;\n    const logEntry = {\n      id: run.id,\n      name: run.name,\n      type: run.run_type,\n      tags: run.tags ?? [],\n      metadata: run.extra?.metadata ?? {},\n      start_time: new Date(run.start_time).toISOString(),\n      streamed_output: [],\n      streamed_output_str: [],\n      final_output: undefined,\n      end_time: undefined\n    };\n    if (this._schemaFormat === \"streaming_events\") {\n      logEntry.inputs = await _getStandardizedInputs(run, this._schemaFormat);\n    }\n    await this.writer.write(new RunLogPatch({\n      ops: [{\n        op: \"add\",\n        path: `/logs/${this.keyMapByRunId[run.id]}`,\n        value: logEntry\n      }]\n    }));\n  }\n  async onRunUpdate(run) {\n    try {\n      const runName = this.keyMapByRunId[run.id];\n      if (runName === undefined) {\n        return;\n      }\n      const ops = [];\n      if (this._schemaFormat === \"streaming_events\") {\n        ops.push({\n          op: \"replace\",\n          path: `/logs/${runName}/inputs`,\n          value: await _getStandardizedInputs(run, this._schemaFormat)\n        });\n      }\n      ops.push({\n        op: \"add\",\n        path: `/logs/${runName}/final_output`,\n        value: await _getStandardizedOutputs(run, this._schemaFormat)\n      });\n      if (run.end_time !== undefined) {\n        ops.push({\n          op: \"add\",\n          path: `/logs/${runName}/end_time`,\n          value: new Date(run.end_time).toISOString()\n        });\n      }\n      const patch = new RunLogPatch({\n        ops\n      });\n      await this.writer.write(patch);\n    } finally {\n      if (run.id === this.rootId) {\n        const patch = new RunLogPatch({\n          ops: [{\n            op: \"replace\",\n            path: \"/final_output\",\n            value: await _getStandardizedOutputs(run, this._schemaFormat)\n          }]\n        });\n        await this.writer.write(patch);\n        if (this.autoClose) {\n          await this.writer.close();\n        }\n      }\n    }\n  }\n  async onLLMNewToken(run, token, kwargs) {\n    const runName = this.keyMapByRunId[run.id];\n    if (runName === undefined) {\n      return;\n    }\n    // TODO: Remove hack\n    const isChatModel = run.inputs.messages !== undefined;\n    let streamedOutputValue;\n    if (isChatModel) {\n      if (isChatGenerationChunk(kwargs?.chunk)) {\n        streamedOutputValue = kwargs?.chunk;\n      } else {\n        streamedOutputValue = new AIMessageChunk({\n          id: `run-${run.id}`,\n          content: token\n        });\n      }\n    } else {\n      streamedOutputValue = token;\n    }\n    const patch = new RunLogPatch({\n      ops: [{\n        op: \"add\",\n        path: `/logs/${runName}/streamed_output_str/-`,\n        value: token\n      }, {\n        op: \"add\",\n        path: `/logs/${runName}/streamed_output/-`,\n        value: streamedOutputValue\n      }]\n    });\n    await this.writer.write(patch);\n  }\n}","map":{"version":3,"names":["applyPatch","BaseTracer","IterableReadableStream","AIMessageChunk","RunLogPatch","constructor","fields","Object","defineProperty","enumerable","configurable","writable","value","ops","concat","other","states","RunLog","state","length","newDocument","fromRunLogPatch","patch","isLogStreamHandler","handler","name","_getStandardizedInputs","run","schemaFormat","Error","inputs","includes","run_type","keys","input","undefined","_getStandardizedOutputs","outputs","output","isChatGenerationChunk","x","message","LogStreamCallbackHandler","_awaitHandler","autoClose","includeNames","includeTypes","includeTags","excludeNames","excludeTypes","excludeTags","_schemaFormat","transformStream","TransformStream","writer","getWriter","receiveStream","fromReadableStream","readable","Symbol","asyncIterator","persistRun","_run","_includeRun","id","rootId","runTags","tags","include","find","tag","every","tapOutputIterable","runId","chunk","key","keyMapByRunId","write","op","path","onRunCreate","type","streamed_output","final_output","logs","counterMapByRunName","count","logEntry","metadata","extra","start_time","Date","toISOString","streamed_output_str","end_time","onRunUpdate","runName","push","close","onLLMNewToken","token","kwargs","isChatModel","messages","streamedOutputValue","content"],"sources":["/Users/youngchen/Downloads/cs224g-triage/node_modules/@langchain/core/dist/tracers/log_stream.js"],"sourcesContent":["import { applyPatch, } from \"../utils/fast-json-patch/index.js\";\nimport { BaseTracer } from \"./base.js\";\nimport { IterableReadableStream } from \"../utils/stream.js\";\nimport { AIMessageChunk } from \"../messages/ai.js\";\n/**\n * List of jsonpatch JSONPatchOperations, which describe how to create the run state\n * from an empty dict. This is the minimal representation of the log, designed to\n * be serialized as JSON and sent over the wire to reconstruct the log on the other\n * side. Reconstruction of the state can be done with any jsonpatch-compliant library,\n * see https://jsonpatch.com for more information.\n */\nexport class RunLogPatch {\n    constructor(fields) {\n        Object.defineProperty(this, \"ops\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.ops = fields.ops ?? [];\n    }\n    concat(other) {\n        const ops = this.ops.concat(other.ops);\n        const states = applyPatch({}, ops);\n        // eslint-disable-next-line @typescript-eslint/no-use-before-define\n        return new RunLog({\n            ops,\n            state: states[states.length - 1].newDocument,\n        });\n    }\n}\nexport class RunLog extends RunLogPatch {\n    constructor(fields) {\n        super(fields);\n        Object.defineProperty(this, \"state\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.state = fields.state;\n    }\n    concat(other) {\n        const ops = this.ops.concat(other.ops);\n        const states = applyPatch(this.state, other.ops);\n        return new RunLog({ ops, state: states[states.length - 1].newDocument });\n    }\n    static fromRunLogPatch(patch) {\n        const states = applyPatch({}, patch.ops);\n        // eslint-disable-next-line @typescript-eslint/no-use-before-define\n        return new RunLog({\n            ops: patch.ops,\n            state: states[states.length - 1].newDocument,\n        });\n    }\n}\nexport const isLogStreamHandler = (handler) => handler.name === \"log_stream_tracer\";\n/**\n * Extract standardized inputs from a run.\n *\n * Standardizes the inputs based on the type of the runnable used.\n *\n * @param run - Run object\n * @param schemaFormat - The schema format to use.\n *\n * @returns Valid inputs are only dict. By conventions, inputs always represented\n * invocation using named arguments.\n * A null means that the input is not yet known!\n */\nasync function _getStandardizedInputs(run, schemaFormat) {\n    if (schemaFormat === \"original\") {\n        throw new Error(\"Do not assign inputs with original schema drop the key for now. \" +\n            \"When inputs are added to streamLog they should be added with \" +\n            \"standardized schema for streaming events.\");\n    }\n    const { inputs } = run;\n    if ([\"retriever\", \"llm\", \"prompt\"].includes(run.run_type)) {\n        return inputs;\n    }\n    if (Object.keys(inputs).length === 1 && inputs?.input === \"\") {\n        return undefined;\n    }\n    // new style chains\n    // These nest an additional 'input' key inside the 'inputs' to make sure\n    // the input is always a dict. We need to unpack and user the inner value.\n    // We should try to fix this in Runnables and callbacks/tracers\n    // Runnables should be using a null type here not a placeholder\n    // dict.\n    return inputs.input;\n}\nasync function _getStandardizedOutputs(run, schemaFormat) {\n    const { outputs } = run;\n    if (schemaFormat === \"original\") {\n        // Return the old schema, without standardizing anything\n        return outputs;\n    }\n    if ([\"retriever\", \"llm\", \"prompt\"].includes(run.run_type)) {\n        return outputs;\n    }\n    // TODO: Remove this hacky check\n    if (outputs !== undefined &&\n        Object.keys(outputs).length === 1 &&\n        outputs?.output !== undefined) {\n        return outputs.output;\n    }\n    return outputs;\n}\nfunction isChatGenerationChunk(x) {\n    return x !== undefined && x.message !== undefined;\n}\n/**\n * Class that extends the `BaseTracer` class from the\n * `langchain.callbacks.tracers.base` module. It represents a callback\n * handler that logs the execution of runs and emits `RunLog` instances to a\n * `RunLogStream`.\n */\nexport class LogStreamCallbackHandler extends BaseTracer {\n    constructor(fields) {\n        super({ _awaitHandler: true, ...fields });\n        Object.defineProperty(this, \"autoClose\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: true\n        });\n        Object.defineProperty(this, \"includeNames\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"includeTypes\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"includeTags\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"excludeNames\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"excludeTypes\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"excludeTags\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"_schemaFormat\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: \"original\"\n        });\n        Object.defineProperty(this, \"rootId\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"keyMapByRunId\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: {}\n        });\n        Object.defineProperty(this, \"counterMapByRunName\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: {}\n        });\n        Object.defineProperty(this, \"transformStream\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"writer\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"receiveStream\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: \"log_stream_tracer\"\n        });\n        Object.defineProperty(this, \"lc_prefer_streaming\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: true\n        });\n        this.autoClose = fields?.autoClose ?? true;\n        this.includeNames = fields?.includeNames;\n        this.includeTypes = fields?.includeTypes;\n        this.includeTags = fields?.includeTags;\n        this.excludeNames = fields?.excludeNames;\n        this.excludeTypes = fields?.excludeTypes;\n        this.excludeTags = fields?.excludeTags;\n        this._schemaFormat = fields?._schemaFormat ?? this._schemaFormat;\n        this.transformStream = new TransformStream();\n        this.writer = this.transformStream.writable.getWriter();\n        this.receiveStream = IterableReadableStream.fromReadableStream(this.transformStream.readable);\n    }\n    [Symbol.asyncIterator]() {\n        return this.receiveStream;\n    }\n    async persistRun(_run) {\n        // This is a legacy method only called once for an entire run tree\n        // and is therefore not useful here\n    }\n    _includeRun(run) {\n        if (run.id === this.rootId) {\n            return false;\n        }\n        const runTags = run.tags ?? [];\n        let include = this.includeNames === undefined &&\n            this.includeTags === undefined &&\n            this.includeTypes === undefined;\n        if (this.includeNames !== undefined) {\n            include = include || this.includeNames.includes(run.name);\n        }\n        if (this.includeTypes !== undefined) {\n            include = include || this.includeTypes.includes(run.run_type);\n        }\n        if (this.includeTags !== undefined) {\n            include =\n                include ||\n                    runTags.find((tag) => this.includeTags?.includes(tag)) !== undefined;\n        }\n        if (this.excludeNames !== undefined) {\n            include = include && !this.excludeNames.includes(run.name);\n        }\n        if (this.excludeTypes !== undefined) {\n            include = include && !this.excludeTypes.includes(run.run_type);\n        }\n        if (this.excludeTags !== undefined) {\n            include =\n                include && runTags.every((tag) => !this.excludeTags?.includes(tag));\n        }\n        return include;\n    }\n    async *tapOutputIterable(runId, output) {\n        // Tap an output async iterator to stream its values to the log.\n        for await (const chunk of output) {\n            // root run is handled in .streamLog()\n            if (runId !== this.rootId) {\n                // if we can't find the run silently ignore\n                // eg. because this run wasn't included in the log\n                const key = this.keyMapByRunId[runId];\n                if (key) {\n                    await this.writer.write(new RunLogPatch({\n                        ops: [\n                            {\n                                op: \"add\",\n                                path: `/logs/${key}/streamed_output/-`,\n                                value: chunk,\n                            },\n                        ],\n                    }));\n                }\n            }\n            yield chunk;\n        }\n    }\n    async onRunCreate(run) {\n        if (this.rootId === undefined) {\n            this.rootId = run.id;\n            await this.writer.write(new RunLogPatch({\n                ops: [\n                    {\n                        op: \"replace\",\n                        path: \"\",\n                        value: {\n                            id: run.id,\n                            name: run.name,\n                            type: run.run_type,\n                            streamed_output: [],\n                            final_output: undefined,\n                            logs: {},\n                        },\n                    },\n                ],\n            }));\n        }\n        if (!this._includeRun(run)) {\n            return;\n        }\n        if (this.counterMapByRunName[run.name] === undefined) {\n            this.counterMapByRunName[run.name] = 0;\n        }\n        this.counterMapByRunName[run.name] += 1;\n        const count = this.counterMapByRunName[run.name];\n        this.keyMapByRunId[run.id] =\n            count === 1 ? run.name : `${run.name}:${count}`;\n        const logEntry = {\n            id: run.id,\n            name: run.name,\n            type: run.run_type,\n            tags: run.tags ?? [],\n            metadata: run.extra?.metadata ?? {},\n            start_time: new Date(run.start_time).toISOString(),\n            streamed_output: [],\n            streamed_output_str: [],\n            final_output: undefined,\n            end_time: undefined,\n        };\n        if (this._schemaFormat === \"streaming_events\") {\n            logEntry.inputs = await _getStandardizedInputs(run, this._schemaFormat);\n        }\n        await this.writer.write(new RunLogPatch({\n            ops: [\n                {\n                    op: \"add\",\n                    path: `/logs/${this.keyMapByRunId[run.id]}`,\n                    value: logEntry,\n                },\n            ],\n        }));\n    }\n    async onRunUpdate(run) {\n        try {\n            const runName = this.keyMapByRunId[run.id];\n            if (runName === undefined) {\n                return;\n            }\n            const ops = [];\n            if (this._schemaFormat === \"streaming_events\") {\n                ops.push({\n                    op: \"replace\",\n                    path: `/logs/${runName}/inputs`,\n                    value: await _getStandardizedInputs(run, this._schemaFormat),\n                });\n            }\n            ops.push({\n                op: \"add\",\n                path: `/logs/${runName}/final_output`,\n                value: await _getStandardizedOutputs(run, this._schemaFormat),\n            });\n            if (run.end_time !== undefined) {\n                ops.push({\n                    op: \"add\",\n                    path: `/logs/${runName}/end_time`,\n                    value: new Date(run.end_time).toISOString(),\n                });\n            }\n            const patch = new RunLogPatch({ ops });\n            await this.writer.write(patch);\n        }\n        finally {\n            if (run.id === this.rootId) {\n                const patch = new RunLogPatch({\n                    ops: [\n                        {\n                            op: \"replace\",\n                            path: \"/final_output\",\n                            value: await _getStandardizedOutputs(run, this._schemaFormat),\n                        },\n                    ],\n                });\n                await this.writer.write(patch);\n                if (this.autoClose) {\n                    await this.writer.close();\n                }\n            }\n        }\n    }\n    async onLLMNewToken(run, token, kwargs) {\n        const runName = this.keyMapByRunId[run.id];\n        if (runName === undefined) {\n            return;\n        }\n        // TODO: Remove hack\n        const isChatModel = run.inputs.messages !== undefined;\n        let streamedOutputValue;\n        if (isChatModel) {\n            if (isChatGenerationChunk(kwargs?.chunk)) {\n                streamedOutputValue = kwargs?.chunk;\n            }\n            else {\n                streamedOutputValue = new AIMessageChunk({\n                    id: `run-${run.id}`,\n                    content: token,\n                });\n            }\n        }\n        else {\n            streamedOutputValue = token;\n        }\n        const patch = new RunLogPatch({\n            ops: [\n                {\n                    op: \"add\",\n                    path: `/logs/${runName}/streamed_output_str/-`,\n                    value: token,\n                },\n                {\n                    op: \"add\",\n                    path: `/logs/${runName}/streamed_output/-`,\n                    value: streamedOutputValue,\n                },\n            ],\n        });\n        await this.writer.write(patch);\n    }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}