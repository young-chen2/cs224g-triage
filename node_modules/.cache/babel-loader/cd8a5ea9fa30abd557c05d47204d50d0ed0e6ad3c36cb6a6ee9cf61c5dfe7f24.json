{"ast":null,"code":"import mustache from \"mustache\";\nimport { addLangChainErrorFields } from \"../errors/index.js\";\nfunction configureMustache() {\n  // Use unescaped HTML\n  // https://github.com/janl/mustache.js?tab=readme-ov-file#variables\n  mustache.escape = text => text;\n}\nexport const parseFString = template => {\n  // Core logic replicated from internals of pythons built in Formatter class.\n  // https://github.com/python/cpython/blob/135ec7cefbaffd516b77362ad2b2ad1025af462e/Objects/stringlib/unicode_format.h#L700-L706\n  const chars = template.split(\"\");\n  const nodes = [];\n  const nextBracket = (bracket, start) => {\n    for (let i = start; i < chars.length; i += 1) {\n      if (bracket.includes(chars[i])) {\n        return i;\n      }\n    }\n    return -1;\n  };\n  let i = 0;\n  while (i < chars.length) {\n    if (chars[i] === \"{\" && i + 1 < chars.length && chars[i + 1] === \"{\") {\n      nodes.push({\n        type: \"literal\",\n        text: \"{\"\n      });\n      i += 2;\n    } else if (chars[i] === \"}\" && i + 1 < chars.length && chars[i + 1] === \"}\") {\n      nodes.push({\n        type: \"literal\",\n        text: \"}\"\n      });\n      i += 2;\n    } else if (chars[i] === \"{\") {\n      const j = nextBracket(\"}\", i);\n      if (j < 0) {\n        throw new Error(\"Unclosed '{' in template.\");\n      }\n      nodes.push({\n        type: \"variable\",\n        name: chars.slice(i + 1, j).join(\"\")\n      });\n      i = j + 1;\n    } else if (chars[i] === \"}\") {\n      throw new Error(\"Single '}' in template.\");\n    } else {\n      const next = nextBracket(\"{}\", i);\n      const text = (next < 0 ? chars.slice(i) : chars.slice(i, next)).join(\"\");\n      nodes.push({\n        type: \"literal\",\n        text\n      });\n      i = next < 0 ? chars.length : next;\n    }\n  }\n  return nodes;\n};\n/**\n * Convert the result of mustache.parse into an array of ParsedTemplateNode,\n * to make it compatible with other LangChain string parsing template formats.\n *\n * @param {mustache.TemplateSpans} template The result of parsing a mustache template with the mustache.js library.\n * @returns {ParsedTemplateNode[]}\n */\nconst mustacheTemplateToNodes = template => template.map(temp => {\n  if (temp[0] === \"name\") {\n    const name = temp[1].includes(\".\") ? temp[1].split(\".\")[0] : temp[1];\n    return {\n      type: \"variable\",\n      name\n    };\n  } else if ([\"#\", \"&\", \"^\", \">\"].includes(temp[0])) {\n    // # represents a section, \"&\" represents an unescaped variable.\n    // These should both be considered variables.\n    return {\n      type: \"variable\",\n      name: temp[1]\n    };\n  } else {\n    return {\n      type: \"literal\",\n      text: temp[1]\n    };\n  }\n});\nexport const parseMustache = template => {\n  configureMustache();\n  const parsed = mustache.parse(template);\n  return mustacheTemplateToNodes(parsed);\n};\nexport const interpolateFString = (template, values) => {\n  return parseFString(template).reduce((res, node) => {\n    if (node.type === \"variable\") {\n      if (node.name in values) {\n        const stringValue = typeof values[node.name] === \"string\" ? values[node.name] : JSON.stringify(values[node.name]);\n        return res + stringValue;\n      }\n      throw new Error(`(f-string) Missing value for input ${node.name}`);\n    }\n    return res + node.text;\n  }, \"\");\n};\nexport const interpolateMustache = (template, values) => {\n  configureMustache();\n  return mustache.render(template, values);\n};\nexport const DEFAULT_FORMATTER_MAPPING = {\n  \"f-string\": interpolateFString,\n  mustache: interpolateMustache\n};\nexport const DEFAULT_PARSER_MAPPING = {\n  \"f-string\": parseFString,\n  mustache: parseMustache\n};\nexport const renderTemplate = (template, templateFormat, inputValues) => {\n  try {\n    return DEFAULT_FORMATTER_MAPPING[templateFormat](template, inputValues);\n  } catch (e) {\n    const error = addLangChainErrorFields(e, \"INVALID_PROMPT_INPUT\");\n    throw error;\n  }\n};\nexport const parseTemplate = (template, templateFormat) => DEFAULT_PARSER_MAPPING[templateFormat](template);\nexport const checkValidTemplate = (template, templateFormat, inputVariables) => {\n  if (!(templateFormat in DEFAULT_FORMATTER_MAPPING)) {\n    const validFormats = Object.keys(DEFAULT_FORMATTER_MAPPING);\n    throw new Error(`Invalid template format. Got \\`${templateFormat}\\`;\n                         should be one of ${validFormats}`);\n  }\n  try {\n    const dummyInputs = inputVariables.reduce((acc, v) => {\n      acc[v] = \"foo\";\n      return acc;\n    }, {});\n    if (Array.isArray(template)) {\n      template.forEach(message => {\n        if (message.type === \"text\") {\n          renderTemplate(message.text, templateFormat, dummyInputs);\n        } else if (message.type === \"image_url\") {\n          if (typeof message.image_url === \"string\") {\n            renderTemplate(message.image_url, templateFormat, dummyInputs);\n          } else {\n            const imageUrl = message.image_url.url;\n            renderTemplate(imageUrl, templateFormat, dummyInputs);\n          }\n        } else {\n          throw new Error(`Invalid message template received. ${JSON.stringify(message, null, 2)}`);\n        }\n      });\n    } else {\n      renderTemplate(template, templateFormat, dummyInputs);\n    }\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  } catch (e) {\n    throw new Error(`Invalid prompt schema: ${e.message}`);\n  }\n};","map":{"version":3,"names":["mustache","addLangChainErrorFields","configureMustache","escape","text","parseFString","template","chars","split","nodes","nextBracket","bracket","start","i","length","includes","push","type","j","Error","name","slice","join","next","mustacheTemplateToNodes","map","temp","parseMustache","parsed","parse","interpolateFString","values","reduce","res","node","stringValue","JSON","stringify","interpolateMustache","render","DEFAULT_FORMATTER_MAPPING","DEFAULT_PARSER_MAPPING","renderTemplate","templateFormat","inputValues","e","error","parseTemplate","checkValidTemplate","inputVariables","validFormats","Object","keys","dummyInputs","acc","v","Array","isArray","forEach","message","image_url","imageUrl","url"],"sources":["/Users/youngchen/Downloads/cs224g-triage/node_modules/@langchain/core/dist/prompts/template.js"],"sourcesContent":["import mustache from \"mustache\";\nimport { addLangChainErrorFields } from \"../errors/index.js\";\nfunction configureMustache() {\n    // Use unescaped HTML\n    // https://github.com/janl/mustache.js?tab=readme-ov-file#variables\n    mustache.escape = (text) => text;\n}\nexport const parseFString = (template) => {\n    // Core logic replicated from internals of pythons built in Formatter class.\n    // https://github.com/python/cpython/blob/135ec7cefbaffd516b77362ad2b2ad1025af462e/Objects/stringlib/unicode_format.h#L700-L706\n    const chars = template.split(\"\");\n    const nodes = [];\n    const nextBracket = (bracket, start) => {\n        for (let i = start; i < chars.length; i += 1) {\n            if (bracket.includes(chars[i])) {\n                return i;\n            }\n        }\n        return -1;\n    };\n    let i = 0;\n    while (i < chars.length) {\n        if (chars[i] === \"{\" && i + 1 < chars.length && chars[i + 1] === \"{\") {\n            nodes.push({ type: \"literal\", text: \"{\" });\n            i += 2;\n        }\n        else if (chars[i] === \"}\" &&\n            i + 1 < chars.length &&\n            chars[i + 1] === \"}\") {\n            nodes.push({ type: \"literal\", text: \"}\" });\n            i += 2;\n        }\n        else if (chars[i] === \"{\") {\n            const j = nextBracket(\"}\", i);\n            if (j < 0) {\n                throw new Error(\"Unclosed '{' in template.\");\n            }\n            nodes.push({\n                type: \"variable\",\n                name: chars.slice(i + 1, j).join(\"\"),\n            });\n            i = j + 1;\n        }\n        else if (chars[i] === \"}\") {\n            throw new Error(\"Single '}' in template.\");\n        }\n        else {\n            const next = nextBracket(\"{}\", i);\n            const text = (next < 0 ? chars.slice(i) : chars.slice(i, next)).join(\"\");\n            nodes.push({ type: \"literal\", text });\n            i = next < 0 ? chars.length : next;\n        }\n    }\n    return nodes;\n};\n/**\n * Convert the result of mustache.parse into an array of ParsedTemplateNode,\n * to make it compatible with other LangChain string parsing template formats.\n *\n * @param {mustache.TemplateSpans} template The result of parsing a mustache template with the mustache.js library.\n * @returns {ParsedTemplateNode[]}\n */\nconst mustacheTemplateToNodes = (template) => template.map((temp) => {\n    if (temp[0] === \"name\") {\n        const name = temp[1].includes(\".\") ? temp[1].split(\".\")[0] : temp[1];\n        return { type: \"variable\", name };\n    }\n    else if ([\"#\", \"&\", \"^\", \">\"].includes(temp[0])) {\n        // # represents a section, \"&\" represents an unescaped variable.\n        // These should both be considered variables.\n        return { type: \"variable\", name: temp[1] };\n    }\n    else {\n        return { type: \"literal\", text: temp[1] };\n    }\n});\nexport const parseMustache = (template) => {\n    configureMustache();\n    const parsed = mustache.parse(template);\n    return mustacheTemplateToNodes(parsed);\n};\nexport const interpolateFString = (template, values) => {\n    return parseFString(template).reduce((res, node) => {\n        if (node.type === \"variable\") {\n            if (node.name in values) {\n                const stringValue = typeof values[node.name] === \"string\"\n                    ? values[node.name]\n                    : JSON.stringify(values[node.name]);\n                return res + stringValue;\n            }\n            throw new Error(`(f-string) Missing value for input ${node.name}`);\n        }\n        return res + node.text;\n    }, \"\");\n};\nexport const interpolateMustache = (template, values) => {\n    configureMustache();\n    return mustache.render(template, values);\n};\nexport const DEFAULT_FORMATTER_MAPPING = {\n    \"f-string\": interpolateFString,\n    mustache: interpolateMustache,\n};\nexport const DEFAULT_PARSER_MAPPING = {\n    \"f-string\": parseFString,\n    mustache: parseMustache,\n};\nexport const renderTemplate = (template, templateFormat, inputValues) => {\n    try {\n        return DEFAULT_FORMATTER_MAPPING[templateFormat](template, inputValues);\n    }\n    catch (e) {\n        const error = addLangChainErrorFields(e, \"INVALID_PROMPT_INPUT\");\n        throw error;\n    }\n};\nexport const parseTemplate = (template, templateFormat) => DEFAULT_PARSER_MAPPING[templateFormat](template);\nexport const checkValidTemplate = (template, templateFormat, inputVariables) => {\n    if (!(templateFormat in DEFAULT_FORMATTER_MAPPING)) {\n        const validFormats = Object.keys(DEFAULT_FORMATTER_MAPPING);\n        throw new Error(`Invalid template format. Got \\`${templateFormat}\\`;\n                         should be one of ${validFormats}`);\n    }\n    try {\n        const dummyInputs = inputVariables.reduce((acc, v) => {\n            acc[v] = \"foo\";\n            return acc;\n        }, {});\n        if (Array.isArray(template)) {\n            template.forEach((message) => {\n                if (message.type === \"text\") {\n                    renderTemplate(message.text, templateFormat, dummyInputs);\n                }\n                else if (message.type === \"image_url\") {\n                    if (typeof message.image_url === \"string\") {\n                        renderTemplate(message.image_url, templateFormat, dummyInputs);\n                    }\n                    else {\n                        const imageUrl = message.image_url.url;\n                        renderTemplate(imageUrl, templateFormat, dummyInputs);\n                    }\n                }\n                else {\n                    throw new Error(`Invalid message template received. ${JSON.stringify(message, null, 2)}`);\n                }\n            });\n        }\n        else {\n            renderTemplate(template, templateFormat, dummyInputs);\n        }\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    }\n    catch (e) {\n        throw new Error(`Invalid prompt schema: ${e.message}`);\n    }\n};\n"],"mappings":"AAAA,OAAOA,QAAQ,MAAM,UAAU;AAC/B,SAASC,uBAAuB,QAAQ,oBAAoB;AAC5D,SAASC,iBAAiBA,CAAA,EAAG;EACzB;EACA;EACAF,QAAQ,CAACG,MAAM,GAAIC,IAAI,IAAKA,IAAI;AACpC;AACA,OAAO,MAAMC,YAAY,GAAIC,QAAQ,IAAK;EACtC;EACA;EACA,MAAMC,KAAK,GAAGD,QAAQ,CAACE,KAAK,CAAC,EAAE,CAAC;EAChC,MAAMC,KAAK,GAAG,EAAE;EAChB,MAAMC,WAAW,GAAGA,CAACC,OAAO,EAAEC,KAAK,KAAK;IACpC,KAAK,IAAIC,CAAC,GAAGD,KAAK,EAAEC,CAAC,GAAGN,KAAK,CAACO,MAAM,EAAED,CAAC,IAAI,CAAC,EAAE;MAC1C,IAAIF,OAAO,CAACI,QAAQ,CAACR,KAAK,CAACM,CAAC,CAAC,CAAC,EAAE;QAC5B,OAAOA,CAAC;MACZ;IACJ;IACA,OAAO,CAAC,CAAC;EACb,CAAC;EACD,IAAIA,CAAC,GAAG,CAAC;EACT,OAAOA,CAAC,GAAGN,KAAK,CAACO,MAAM,EAAE;IACrB,IAAIP,KAAK,CAACM,CAAC,CAAC,KAAK,GAAG,IAAIA,CAAC,GAAG,CAAC,GAAGN,KAAK,CAACO,MAAM,IAAIP,KAAK,CAACM,CAAC,GAAG,CAAC,CAAC,KAAK,GAAG,EAAE;MAClEJ,KAAK,CAACO,IAAI,CAAC;QAAEC,IAAI,EAAE,SAAS;QAAEb,IAAI,EAAE;MAAI,CAAC,CAAC;MAC1CS,CAAC,IAAI,CAAC;IACV,CAAC,MACI,IAAIN,KAAK,CAACM,CAAC,CAAC,KAAK,GAAG,IACrBA,CAAC,GAAG,CAAC,GAAGN,KAAK,CAACO,MAAM,IACpBP,KAAK,CAACM,CAAC,GAAG,CAAC,CAAC,KAAK,GAAG,EAAE;MACtBJ,KAAK,CAACO,IAAI,CAAC;QAAEC,IAAI,EAAE,SAAS;QAAEb,IAAI,EAAE;MAAI,CAAC,CAAC;MAC1CS,CAAC,IAAI,CAAC;IACV,CAAC,MACI,IAAIN,KAAK,CAACM,CAAC,CAAC,KAAK,GAAG,EAAE;MACvB,MAAMK,CAAC,GAAGR,WAAW,CAAC,GAAG,EAAEG,CAAC,CAAC;MAC7B,IAAIK,CAAC,GAAG,CAAC,EAAE;QACP,MAAM,IAAIC,KAAK,CAAC,2BAA2B,CAAC;MAChD;MACAV,KAAK,CAACO,IAAI,CAAC;QACPC,IAAI,EAAE,UAAU;QAChBG,IAAI,EAAEb,KAAK,CAACc,KAAK,CAACR,CAAC,GAAG,CAAC,EAAEK,CAAC,CAAC,CAACI,IAAI,CAAC,EAAE;MACvC,CAAC,CAAC;MACFT,CAAC,GAAGK,CAAC,GAAG,CAAC;IACb,CAAC,MACI,IAAIX,KAAK,CAACM,CAAC,CAAC,KAAK,GAAG,EAAE;MACvB,MAAM,IAAIM,KAAK,CAAC,yBAAyB,CAAC;IAC9C,CAAC,MACI;MACD,MAAMI,IAAI,GAAGb,WAAW,CAAC,IAAI,EAAEG,CAAC,CAAC;MACjC,MAAMT,IAAI,GAAG,CAACmB,IAAI,GAAG,CAAC,GAAGhB,KAAK,CAACc,KAAK,CAACR,CAAC,CAAC,GAAGN,KAAK,CAACc,KAAK,CAACR,CAAC,EAAEU,IAAI,CAAC,EAAED,IAAI,CAAC,EAAE,CAAC;MACxEb,KAAK,CAACO,IAAI,CAAC;QAAEC,IAAI,EAAE,SAAS;QAAEb;MAAK,CAAC,CAAC;MACrCS,CAAC,GAAGU,IAAI,GAAG,CAAC,GAAGhB,KAAK,CAACO,MAAM,GAAGS,IAAI;IACtC;EACJ;EACA,OAAOd,KAAK;AAChB,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAMe,uBAAuB,GAAIlB,QAAQ,IAAKA,QAAQ,CAACmB,GAAG,CAAEC,IAAI,IAAK;EACjE,IAAIA,IAAI,CAAC,CAAC,CAAC,KAAK,MAAM,EAAE;IACpB,MAAMN,IAAI,GAAGM,IAAI,CAAC,CAAC,CAAC,CAACX,QAAQ,CAAC,GAAG,CAAC,GAAGW,IAAI,CAAC,CAAC,CAAC,CAAClB,KAAK,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC,GAAGkB,IAAI,CAAC,CAAC,CAAC;IACpE,OAAO;MAAET,IAAI,EAAE,UAAU;MAAEG;IAAK,CAAC;EACrC,CAAC,MACI,IAAI,CAAC,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,CAAC,CAACL,QAAQ,CAACW,IAAI,CAAC,CAAC,CAAC,CAAC,EAAE;IAC7C;IACA;IACA,OAAO;MAAET,IAAI,EAAE,UAAU;MAAEG,IAAI,EAAEM,IAAI,CAAC,CAAC;IAAE,CAAC;EAC9C,CAAC,MACI;IACD,OAAO;MAAET,IAAI,EAAE,SAAS;MAAEb,IAAI,EAAEsB,IAAI,CAAC,CAAC;IAAE,CAAC;EAC7C;AACJ,CAAC,CAAC;AACF,OAAO,MAAMC,aAAa,GAAIrB,QAAQ,IAAK;EACvCJ,iBAAiB,CAAC,CAAC;EACnB,MAAM0B,MAAM,GAAG5B,QAAQ,CAAC6B,KAAK,CAACvB,QAAQ,CAAC;EACvC,OAAOkB,uBAAuB,CAACI,MAAM,CAAC;AAC1C,CAAC;AACD,OAAO,MAAME,kBAAkB,GAAGA,CAACxB,QAAQ,EAAEyB,MAAM,KAAK;EACpD,OAAO1B,YAAY,CAACC,QAAQ,CAAC,CAAC0B,MAAM,CAAC,CAACC,GAAG,EAAEC,IAAI,KAAK;IAChD,IAAIA,IAAI,CAACjB,IAAI,KAAK,UAAU,EAAE;MAC1B,IAAIiB,IAAI,CAACd,IAAI,IAAIW,MAAM,EAAE;QACrB,MAAMI,WAAW,GAAG,OAAOJ,MAAM,CAACG,IAAI,CAACd,IAAI,CAAC,KAAK,QAAQ,GACnDW,MAAM,CAACG,IAAI,CAACd,IAAI,CAAC,GACjBgB,IAAI,CAACC,SAAS,CAACN,MAAM,CAACG,IAAI,CAACd,IAAI,CAAC,CAAC;QACvC,OAAOa,GAAG,GAAGE,WAAW;MAC5B;MACA,MAAM,IAAIhB,KAAK,CAAC,sCAAsCe,IAAI,CAACd,IAAI,EAAE,CAAC;IACtE;IACA,OAAOa,GAAG,GAAGC,IAAI,CAAC9B,IAAI;EAC1B,CAAC,EAAE,EAAE,CAAC;AACV,CAAC;AACD,OAAO,MAAMkC,mBAAmB,GAAGA,CAAChC,QAAQ,EAAEyB,MAAM,KAAK;EACrD7B,iBAAiB,CAAC,CAAC;EACnB,OAAOF,QAAQ,CAACuC,MAAM,CAACjC,QAAQ,EAAEyB,MAAM,CAAC;AAC5C,CAAC;AACD,OAAO,MAAMS,yBAAyB,GAAG;EACrC,UAAU,EAAEV,kBAAkB;EAC9B9B,QAAQ,EAAEsC;AACd,CAAC;AACD,OAAO,MAAMG,sBAAsB,GAAG;EAClC,UAAU,EAAEpC,YAAY;EACxBL,QAAQ,EAAE2B;AACd,CAAC;AACD,OAAO,MAAMe,cAAc,GAAGA,CAACpC,QAAQ,EAAEqC,cAAc,EAAEC,WAAW,KAAK;EACrE,IAAI;IACA,OAAOJ,yBAAyB,CAACG,cAAc,CAAC,CAACrC,QAAQ,EAAEsC,WAAW,CAAC;EAC3E,CAAC,CACD,OAAOC,CAAC,EAAE;IACN,MAAMC,KAAK,GAAG7C,uBAAuB,CAAC4C,CAAC,EAAE,sBAAsB,CAAC;IAChE,MAAMC,KAAK;EACf;AACJ,CAAC;AACD,OAAO,MAAMC,aAAa,GAAGA,CAACzC,QAAQ,EAAEqC,cAAc,KAAKF,sBAAsB,CAACE,cAAc,CAAC,CAACrC,QAAQ,CAAC;AAC3G,OAAO,MAAM0C,kBAAkB,GAAGA,CAAC1C,QAAQ,EAAEqC,cAAc,EAAEM,cAAc,KAAK;EAC5E,IAAI,EAAEN,cAAc,IAAIH,yBAAyB,CAAC,EAAE;IAChD,MAAMU,YAAY,GAAGC,MAAM,CAACC,IAAI,CAACZ,yBAAyB,CAAC;IAC3D,MAAM,IAAIrB,KAAK,CAAC,kCAAkCwB,cAAc;AACxE,4CAA4CO,YAAY,EAAE,CAAC;EACvD;EACA,IAAI;IACA,MAAMG,WAAW,GAAGJ,cAAc,CAACjB,MAAM,CAAC,CAACsB,GAAG,EAAEC,CAAC,KAAK;MAClDD,GAAG,CAACC,CAAC,CAAC,GAAG,KAAK;MACd,OAAOD,GAAG;IACd,CAAC,EAAE,CAAC,CAAC,CAAC;IACN,IAAIE,KAAK,CAACC,OAAO,CAACnD,QAAQ,CAAC,EAAE;MACzBA,QAAQ,CAACoD,OAAO,CAAEC,OAAO,IAAK;QAC1B,IAAIA,OAAO,CAAC1C,IAAI,KAAK,MAAM,EAAE;UACzByB,cAAc,CAACiB,OAAO,CAACvD,IAAI,EAAEuC,cAAc,EAAEU,WAAW,CAAC;QAC7D,CAAC,MACI,IAAIM,OAAO,CAAC1C,IAAI,KAAK,WAAW,EAAE;UACnC,IAAI,OAAO0C,OAAO,CAACC,SAAS,KAAK,QAAQ,EAAE;YACvClB,cAAc,CAACiB,OAAO,CAACC,SAAS,EAAEjB,cAAc,EAAEU,WAAW,CAAC;UAClE,CAAC,MACI;YACD,MAAMQ,QAAQ,GAAGF,OAAO,CAACC,SAAS,CAACE,GAAG;YACtCpB,cAAc,CAACmB,QAAQ,EAAElB,cAAc,EAAEU,WAAW,CAAC;UACzD;QACJ,CAAC,MACI;UACD,MAAM,IAAIlC,KAAK,CAAC,sCAAsCiB,IAAI,CAACC,SAAS,CAACsB,OAAO,EAAE,IAAI,EAAE,CAAC,CAAC,EAAE,CAAC;QAC7F;MACJ,CAAC,CAAC;IACN,CAAC,MACI;MACDjB,cAAc,CAACpC,QAAQ,EAAEqC,cAAc,EAAEU,WAAW,CAAC;IACzD;IACA;EACJ,CAAC,CACD,OAAOR,CAAC,EAAE;IACN,MAAM,IAAI1B,KAAK,CAAC,0BAA0B0B,CAAC,CAACc,OAAO,EAAE,CAAC;EAC1D;AACJ,CAAC","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}