{"ast":null,"code":"import { z } from \"zod\";\nimport { CallbackManager, parseCallbackConfigArg } from \"../callbacks/manager.js\";\nimport { BaseLangChain } from \"../language_models/base.js\";\nimport { ensureConfig, patchConfig, pickRunnableConfigKeys } from \"../runnables/config.js\";\nimport { isDirectToolOutput, ToolMessage } from \"../messages/tool.js\";\nimport { AsyncLocalStorageProviderSingleton } from \"../singletons/index.js\";\nimport { _isToolCall, ToolInputParsingException } from \"./utils.js\";\nimport { isZodSchema } from \"../utils/types/is_zod_schema.js\";\nexport { ToolInputParsingException };\n/**\n * Base class for Tools that accept input of any shape defined by a Zod schema.\n */\nexport class StructuredTool extends BaseLangChain {\n  get lc_namespace() {\n    return [\"langchain\", \"tools\"];\n  }\n  constructor(fields) {\n    super(fields ?? {});\n    /**\n     * Whether to return the tool's output directly.\n     *\n     * Setting this to true means that after the tool is called,\n     * an agent should stop looping.\n     */\n    Object.defineProperty(this, \"returnDirect\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: false\n    });\n    Object.defineProperty(this, \"verboseParsingErrors\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: false\n    });\n    /**\n     * The tool response format.\n     *\n     * If \"content\" then the output of the tool is interpreted as the contents of a\n     * ToolMessage. If \"content_and_artifact\" then the output is expected to be a\n     * two-tuple corresponding to the (content, artifact) of a ToolMessage.\n     *\n     * @default \"content\"\n     */\n    Object.defineProperty(this, \"responseFormat\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: \"content\"\n    });\n    this.verboseParsingErrors = fields?.verboseParsingErrors ?? this.verboseParsingErrors;\n    this.responseFormat = fields?.responseFormat ?? this.responseFormat;\n  }\n  /**\n   * Invokes the tool with the provided input and configuration.\n   * @param input The input for the tool.\n   * @param config Optional configuration for the tool.\n   * @returns A Promise that resolves with a string.\n   */\n  async invoke(input, config) {\n    let tool_call_id;\n    let toolInput;\n    let enrichedConfig = ensureConfig(config);\n    if (_isToolCall(input)) {\n      tool_call_id = input.id;\n      toolInput = input.args;\n      enrichedConfig = {\n        ...enrichedConfig,\n        toolCall: input,\n        configurable: {\n          ...enrichedConfig.configurable,\n          tool_call_id\n        }\n      };\n    } else {\n      toolInput = input;\n    }\n    return this.call(toolInput, enrichedConfig);\n  }\n  /**\n   * @deprecated Use .invoke() instead. Will be removed in 0.3.0.\n   *\n   * Calls the tool with the provided argument, configuration, and tags. It\n   * parses the input according to the schema, handles any errors, and\n   * manages callbacks.\n   * @param arg The input argument for the tool.\n   * @param configArg Optional configuration or callbacks for the tool.\n   * @param tags Optional tags for the tool.\n   * @returns A Promise that resolves with a string.\n   */\n  async call(arg, configArg, /** @deprecated */\n  tags) {\n    let parsed;\n    try {\n      parsed = await this.schema.parseAsync(arg);\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    } catch (e) {\n      let message = `Received tool input did not match expected schema`;\n      if (this.verboseParsingErrors) {\n        message = `${message}\\nDetails: ${e.message}`;\n      }\n      throw new ToolInputParsingException(message, JSON.stringify(arg));\n    }\n    const config = parseCallbackConfigArg(configArg);\n    const callbackManager_ = CallbackManager.configure(config.callbacks, this.callbacks, config.tags || tags, this.tags, config.metadata, this.metadata, {\n      verbose: this.verbose\n    });\n    const runManager = await callbackManager_?.handleToolStart(this.toJSON(), typeof parsed === \"string\" ? parsed : JSON.stringify(parsed), config.runId, undefined, undefined, undefined, config.runName);\n    delete config.runId;\n    let result;\n    try {\n      result = await this._call(parsed, runManager, config);\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    } catch (e) {\n      await runManager?.handleToolError(e);\n      throw e;\n    }\n    let content;\n    let artifact;\n    if (this.responseFormat === \"content_and_artifact\") {\n      if (Array.isArray(result) && result.length === 2) {\n        [content, artifact] = result;\n      } else {\n        throw new Error(`Tool response format is \"content_and_artifact\" but the output was not a two-tuple.\\nResult: ${JSON.stringify(result)}`);\n      }\n    } else {\n      content = result;\n    }\n    let toolCallId;\n    if (config && \"configurable\" in config) {\n      toolCallId = config.configurable.tool_call_id;\n    }\n    const formattedOutput = _formatToolOutput({\n      content,\n      artifact,\n      toolCallId,\n      name: this.name\n    });\n    await runManager?.handleToolEnd(formattedOutput);\n    return formattedOutput;\n  }\n}\n/**\n * Base class for Tools that accept input as a string.\n */\nexport class Tool extends StructuredTool {\n  constructor(fields) {\n    super(fields);\n    Object.defineProperty(this, \"schema\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: z.object({\n        input: z.string().optional()\n      }).transform(obj => obj.input)\n    });\n  }\n  /**\n   * @deprecated Use .invoke() instead. Will be removed in 0.3.0.\n   *\n   * Calls the tool with the provided argument and callbacks. It handles\n   * string inputs specifically.\n   * @param arg The input argument for the tool, which can be a string, undefined, or an input of the tool's schema.\n   * @param callbacks Optional callbacks for the tool.\n   * @returns A Promise that resolves with a string.\n   */\n  call(arg, callbacks) {\n    return super.call(typeof arg === \"string\" || !arg ? {\n      input: arg\n    } : arg, callbacks);\n  }\n}\n/**\n * A tool that can be created dynamically from a function, name, and description.\n */\nexport class DynamicTool extends Tool {\n  static lc_name() {\n    return \"DynamicTool\";\n  }\n  constructor(fields) {\n    super(fields);\n    Object.defineProperty(this, \"name\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, \"description\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, \"func\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    this.name = fields.name;\n    this.description = fields.description;\n    this.func = fields.func;\n    this.returnDirect = fields.returnDirect ?? this.returnDirect;\n  }\n  /**\n   * @deprecated Use .invoke() instead. Will be removed in 0.3.0.\n   */\n  async call(arg, configArg) {\n    const config = parseCallbackConfigArg(configArg);\n    if (config.runName === undefined) {\n      config.runName = this.name;\n    }\n    return super.call(arg, config);\n  }\n  /** @ignore */\n  async _call(input, runManager, parentConfig) {\n    return this.func(input, runManager, parentConfig);\n  }\n}\n/**\n * A tool that can be created dynamically from a function, name, and\n * description, designed to work with structured data. It extends the\n * StructuredTool class and overrides the _call method to execute the\n * provided function when the tool is called.\n *\n * Schema can be passed as Zod or JSON schema. The tool will not validate\n * input if JSON schema is passed.\n */\nexport class DynamicStructuredTool extends StructuredTool {\n  static lc_name() {\n    return \"DynamicStructuredTool\";\n  }\n  constructor(fields) {\n    super(fields);\n    Object.defineProperty(this, \"name\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, \"description\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, \"func\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, \"schema\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    this.name = fields.name;\n    this.description = fields.description;\n    this.func = fields.func;\n    this.returnDirect = fields.returnDirect ?? this.returnDirect;\n    this.schema = isZodSchema(fields.schema) ? fields.schema : z.object({}).passthrough();\n  }\n  /**\n   * @deprecated Use .invoke() instead. Will be removed in 0.3.0.\n   */\n  async call(arg, configArg, /** @deprecated */\n  tags) {\n    const config = parseCallbackConfigArg(configArg);\n    if (config.runName === undefined) {\n      config.runName = this.name;\n    }\n    return super.call(arg, config, tags);\n  }\n  _call(arg, runManager, parentConfig) {\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    return this.func(arg, runManager, parentConfig);\n  }\n}\n/**\n * Abstract base class for toolkits in LangChain. Toolkits are collections\n * of tools that agents can use. Subclasses must implement the `tools`\n * property to provide the specific tools for the toolkit.\n */\nexport class BaseToolkit {\n  getTools() {\n    return this.tools;\n  }\n}\nexport function tool(func, fields) {\n  // If the schema is not provided, or it's a string schema, create a DynamicTool\n  if (!fields.schema || isZodSchema(fields.schema) && (!(\"shape\" in fields.schema) || !fields.schema.shape)) {\n    return new DynamicTool({\n      ...fields,\n      description: fields.description ?? fields.schema?.description ?? `${fields.name} tool`,\n      func: async (input, runManager, config) => {\n        return new Promise((resolve, reject) => {\n          const childConfig = patchConfig(config, {\n            callbacks: runManager?.getChild()\n          });\n          void AsyncLocalStorageProviderSingleton.runWithConfig(pickRunnableConfigKeys(childConfig), async () => {\n            try {\n              // TS doesn't restrict the type here based on the guard above\n              // eslint-disable-next-line @typescript-eslint/no-explicit-any\n              resolve(func(input, childConfig));\n            } catch (e) {\n              reject(e);\n            }\n          });\n        });\n      }\n    });\n  }\n  const description = fields.description ?? fields.schema.description ?? `${fields.name} tool`;\n  return new DynamicStructuredTool({\n    ...fields,\n    description,\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    schema: fields.schema,\n    // TODO: Consider moving into DynamicStructuredTool constructor\n    func: async (input, runManager, config) => {\n      return new Promise((resolve, reject) => {\n        const childConfig = patchConfig(config, {\n          callbacks: runManager?.getChild()\n        });\n        void AsyncLocalStorageProviderSingleton.runWithConfig(pickRunnableConfigKeys(childConfig), async () => {\n          try {\n            // TS doesn't restrict the type here based on the guard above\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n            resolve(func(input, childConfig));\n          } catch (e) {\n            reject(e);\n          }\n        });\n      });\n    }\n  });\n}\nfunction _formatToolOutput(params) {\n  const {\n    content,\n    artifact,\n    toolCallId\n  } = params;\n  if (toolCallId && !isDirectToolOutput(content)) {\n    if (typeof content === \"string\" || Array.isArray(content) && content.every(item => typeof item === \"object\")) {\n      return new ToolMessage({\n        content,\n        artifact,\n        tool_call_id: toolCallId,\n        name: params.name\n      });\n    } else {\n      return new ToolMessage({\n        content: _stringify(content),\n        artifact,\n        tool_call_id: toolCallId,\n        name: params.name\n      });\n    }\n  } else {\n    return content;\n  }\n}\nfunction _stringify(content) {\n  try {\n    return JSON.stringify(content, null, 2);\n  } catch (_noOp) {\n    return `${content}`;\n  }\n}","map":{"version":3,"names":["z","CallbackManager","parseCallbackConfigArg","BaseLangChain","ensureConfig","patchConfig","pickRunnableConfigKeys","isDirectToolOutput","ToolMessage","AsyncLocalStorageProviderSingleton","_isToolCall","ToolInputParsingException","isZodSchema","StructuredTool","lc_namespace","constructor","fields","Object","defineProperty","enumerable","configurable","writable","value","verboseParsingErrors","responseFormat","invoke","input","config","tool_call_id","toolInput","enrichedConfig","id","args","toolCall","call","arg","configArg","tags","parsed","schema","parseAsync","e","message","JSON","stringify","callbackManager_","configure","callbacks","metadata","verbose","runManager","handleToolStart","toJSON","runId","undefined","runName","result","_call","handleToolError","content","artifact","Array","isArray","length","Error","toolCallId","formattedOutput","_formatToolOutput","name","handleToolEnd","Tool","object","string","optional","transform","obj","DynamicTool","lc_name","description","func","returnDirect","parentConfig","DynamicStructuredTool","passthrough","BaseToolkit","getTools","tools","tool","shape","Promise","resolve","reject","childConfig","getChild","runWithConfig","params","every","item","_stringify","_noOp"],"sources":["/Users/youngchen/Downloads/cs224g-triage/node_modules/@langchain/core/dist/tools/index.js"],"sourcesContent":["import { z } from \"zod\";\nimport { CallbackManager, parseCallbackConfigArg, } from \"../callbacks/manager.js\";\nimport { BaseLangChain, } from \"../language_models/base.js\";\nimport { ensureConfig, patchConfig, pickRunnableConfigKeys, } from \"../runnables/config.js\";\nimport { isDirectToolOutput, ToolMessage } from \"../messages/tool.js\";\nimport { AsyncLocalStorageProviderSingleton } from \"../singletons/index.js\";\nimport { _isToolCall, ToolInputParsingException } from \"./utils.js\";\nimport { isZodSchema } from \"../utils/types/is_zod_schema.js\";\nexport { ToolInputParsingException };\n/**\n * Base class for Tools that accept input of any shape defined by a Zod schema.\n */\nexport class StructuredTool extends BaseLangChain {\n    get lc_namespace() {\n        return [\"langchain\", \"tools\"];\n    }\n    constructor(fields) {\n        super(fields ?? {});\n        /**\n         * Whether to return the tool's output directly.\n         *\n         * Setting this to true means that after the tool is called,\n         * an agent should stop looping.\n         */\n        Object.defineProperty(this, \"returnDirect\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: false\n        });\n        Object.defineProperty(this, \"verboseParsingErrors\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: false\n        });\n        /**\n         * The tool response format.\n         *\n         * If \"content\" then the output of the tool is interpreted as the contents of a\n         * ToolMessage. If \"content_and_artifact\" then the output is expected to be a\n         * two-tuple corresponding to the (content, artifact) of a ToolMessage.\n         *\n         * @default \"content\"\n         */\n        Object.defineProperty(this, \"responseFormat\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: \"content\"\n        });\n        this.verboseParsingErrors =\n            fields?.verboseParsingErrors ?? this.verboseParsingErrors;\n        this.responseFormat = fields?.responseFormat ?? this.responseFormat;\n    }\n    /**\n     * Invokes the tool with the provided input and configuration.\n     * @param input The input for the tool.\n     * @param config Optional configuration for the tool.\n     * @returns A Promise that resolves with a string.\n     */\n    async invoke(input, config) {\n        let tool_call_id;\n        let toolInput;\n        let enrichedConfig = ensureConfig(config);\n        if (_isToolCall(input)) {\n            tool_call_id = input.id;\n            toolInput = input.args;\n            enrichedConfig = {\n                ...enrichedConfig,\n                toolCall: input,\n                configurable: {\n                    ...enrichedConfig.configurable,\n                    tool_call_id,\n                },\n            };\n        }\n        else {\n            toolInput = input;\n        }\n        return this.call(toolInput, enrichedConfig);\n    }\n    /**\n     * @deprecated Use .invoke() instead. Will be removed in 0.3.0.\n     *\n     * Calls the tool with the provided argument, configuration, and tags. It\n     * parses the input according to the schema, handles any errors, and\n     * manages callbacks.\n     * @param arg The input argument for the tool.\n     * @param configArg Optional configuration or callbacks for the tool.\n     * @param tags Optional tags for the tool.\n     * @returns A Promise that resolves with a string.\n     */\n    async call(arg, configArg, \n    /** @deprecated */\n    tags) {\n        let parsed;\n        try {\n            parsed = await this.schema.parseAsync(arg);\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        }\n        catch (e) {\n            let message = `Received tool input did not match expected schema`;\n            if (this.verboseParsingErrors) {\n                message = `${message}\\nDetails: ${e.message}`;\n            }\n            throw new ToolInputParsingException(message, JSON.stringify(arg));\n        }\n        const config = parseCallbackConfigArg(configArg);\n        const callbackManager_ = CallbackManager.configure(config.callbacks, this.callbacks, config.tags || tags, this.tags, config.metadata, this.metadata, { verbose: this.verbose });\n        const runManager = await callbackManager_?.handleToolStart(this.toJSON(), typeof parsed === \"string\" ? parsed : JSON.stringify(parsed), config.runId, undefined, undefined, undefined, config.runName);\n        delete config.runId;\n        let result;\n        try {\n            result = await this._call(parsed, runManager, config);\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        }\n        catch (e) {\n            await runManager?.handleToolError(e);\n            throw e;\n        }\n        let content;\n        let artifact;\n        if (this.responseFormat === \"content_and_artifact\") {\n            if (Array.isArray(result) && result.length === 2) {\n                [content, artifact] = result;\n            }\n            else {\n                throw new Error(`Tool response format is \"content_and_artifact\" but the output was not a two-tuple.\\nResult: ${JSON.stringify(result)}`);\n            }\n        }\n        else {\n            content = result;\n        }\n        let toolCallId;\n        if (config && \"configurable\" in config) {\n            toolCallId = config.configurable\n                .tool_call_id;\n        }\n        const formattedOutput = _formatToolOutput({\n            content,\n            artifact,\n            toolCallId,\n            name: this.name,\n        });\n        await runManager?.handleToolEnd(formattedOutput);\n        return formattedOutput;\n    }\n}\n/**\n * Base class for Tools that accept input as a string.\n */\nexport class Tool extends StructuredTool {\n    constructor(fields) {\n        super(fields);\n        Object.defineProperty(this, \"schema\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: z\n                .object({ input: z.string().optional() })\n                .transform((obj) => obj.input)\n        });\n    }\n    /**\n     * @deprecated Use .invoke() instead. Will be removed in 0.3.0.\n     *\n     * Calls the tool with the provided argument and callbacks. It handles\n     * string inputs specifically.\n     * @param arg The input argument for the tool, which can be a string, undefined, or an input of the tool's schema.\n     * @param callbacks Optional callbacks for the tool.\n     * @returns A Promise that resolves with a string.\n     */\n    call(arg, callbacks) {\n        return super.call(typeof arg === \"string\" || !arg ? { input: arg } : arg, callbacks);\n    }\n}\n/**\n * A tool that can be created dynamically from a function, name, and description.\n */\nexport class DynamicTool extends Tool {\n    static lc_name() {\n        return \"DynamicTool\";\n    }\n    constructor(fields) {\n        super(fields);\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"description\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"func\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.name = fields.name;\n        this.description = fields.description;\n        this.func = fields.func;\n        this.returnDirect = fields.returnDirect ?? this.returnDirect;\n    }\n    /**\n     * @deprecated Use .invoke() instead. Will be removed in 0.3.0.\n     */\n    async call(arg, configArg) {\n        const config = parseCallbackConfigArg(configArg);\n        if (config.runName === undefined) {\n            config.runName = this.name;\n        }\n        return super.call(arg, config);\n    }\n    /** @ignore */\n    async _call(input, runManager, parentConfig) {\n        return this.func(input, runManager, parentConfig);\n    }\n}\n/**\n * A tool that can be created dynamically from a function, name, and\n * description, designed to work with structured data. It extends the\n * StructuredTool class and overrides the _call method to execute the\n * provided function when the tool is called.\n *\n * Schema can be passed as Zod or JSON schema. The tool will not validate\n * input if JSON schema is passed.\n */\nexport class DynamicStructuredTool extends StructuredTool {\n    static lc_name() {\n        return \"DynamicStructuredTool\";\n    }\n    constructor(fields) {\n        super(fields);\n        Object.defineProperty(this, \"name\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"description\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"func\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"schema\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.name = fields.name;\n        this.description = fields.description;\n        this.func = fields.func;\n        this.returnDirect = fields.returnDirect ?? this.returnDirect;\n        this.schema = (isZodSchema(fields.schema) ? fields.schema : z.object({}).passthrough());\n    }\n    /**\n     * @deprecated Use .invoke() instead. Will be removed in 0.3.0.\n     */\n    async call(arg, configArg, \n    /** @deprecated */\n    tags) {\n        const config = parseCallbackConfigArg(configArg);\n        if (config.runName === undefined) {\n            config.runName = this.name;\n        }\n        return super.call(arg, config, tags);\n    }\n    _call(arg, runManager, parentConfig) {\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        return this.func(arg, runManager, parentConfig);\n    }\n}\n/**\n * Abstract base class for toolkits in LangChain. Toolkits are collections\n * of tools that agents can use. Subclasses must implement the `tools`\n * property to provide the specific tools for the toolkit.\n */\nexport class BaseToolkit {\n    getTools() {\n        return this.tools;\n    }\n}\nexport function tool(func, fields) {\n    // If the schema is not provided, or it's a string schema, create a DynamicTool\n    if (!fields.schema ||\n        (isZodSchema(fields.schema) &&\n            (!(\"shape\" in fields.schema) || !fields.schema.shape))) {\n        return new DynamicTool({\n            ...fields,\n            description: fields.description ??\n                fields.schema?.description ??\n                `${fields.name} tool`,\n            func: async (input, runManager, config) => {\n                return new Promise((resolve, reject) => {\n                    const childConfig = patchConfig(config, {\n                        callbacks: runManager?.getChild(),\n                    });\n                    void AsyncLocalStorageProviderSingleton.runWithConfig(pickRunnableConfigKeys(childConfig), async () => {\n                        try {\n                            // TS doesn't restrict the type here based on the guard above\n                            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n                            resolve(func(input, childConfig));\n                        }\n                        catch (e) {\n                            reject(e);\n                        }\n                    });\n                });\n            },\n        });\n    }\n    const description = fields.description ?? fields.schema.description ?? `${fields.name} tool`;\n    return new DynamicStructuredTool({\n        ...fields,\n        description,\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        schema: fields.schema,\n        // TODO: Consider moving into DynamicStructuredTool constructor\n        func: async (input, runManager, config) => {\n            return new Promise((resolve, reject) => {\n                const childConfig = patchConfig(config, {\n                    callbacks: runManager?.getChild(),\n                });\n                void AsyncLocalStorageProviderSingleton.runWithConfig(pickRunnableConfigKeys(childConfig), async () => {\n                    try {\n                        // TS doesn't restrict the type here based on the guard above\n                        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n                        resolve(func(input, childConfig));\n                    }\n                    catch (e) {\n                        reject(e);\n                    }\n                });\n            });\n        },\n    });\n}\nfunction _formatToolOutput(params) {\n    const { content, artifact, toolCallId } = params;\n    if (toolCallId && !isDirectToolOutput(content)) {\n        if (typeof content === \"string\" ||\n            (Array.isArray(content) &&\n                content.every((item) => typeof item === \"object\"))) {\n            return new ToolMessage({\n                content,\n                artifact,\n                tool_call_id: toolCallId,\n                name: params.name,\n            });\n        }\n        else {\n            return new ToolMessage({\n                content: _stringify(content),\n                artifact,\n                tool_call_id: toolCallId,\n                name: params.name,\n            });\n        }\n    }\n    else {\n        return content;\n    }\n}\nfunction _stringify(content) {\n    try {\n        return JSON.stringify(content, null, 2);\n    }\n    catch (_noOp) {\n        return `${content}`;\n    }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}