{"ast":null,"code":"import { encodePointer } from './pointer.js';\nexport const schemaKeyword = {\n  additionalItems: true,\n  unevaluatedItems: true,\n  items: true,\n  contains: true,\n  additionalProperties: true,\n  unevaluatedProperties: true,\n  propertyNames: true,\n  not: true,\n  if: true,\n  then: true,\n  else: true\n};\nexport const schemaArrayKeyword = {\n  prefixItems: true,\n  items: true,\n  allOf: true,\n  anyOf: true,\n  oneOf: true\n};\nexport const schemaMapKeyword = {\n  $defs: true,\n  definitions: true,\n  properties: true,\n  patternProperties: true,\n  dependentSchemas: true\n};\nexport const ignoredKeyword = {\n  id: true,\n  $id: true,\n  $ref: true,\n  $schema: true,\n  $anchor: true,\n  $vocabulary: true,\n  $comment: true,\n  default: true,\n  enum: true,\n  const: true,\n  required: true,\n  type: true,\n  maximum: true,\n  minimum: true,\n  exclusiveMaximum: true,\n  exclusiveMinimum: true,\n  multipleOf: true,\n  maxLength: true,\n  minLength: true,\n  pattern: true,\n  format: true,\n  maxItems: true,\n  minItems: true,\n  uniqueItems: true,\n  maxProperties: true,\n  minProperties: true\n};\nexport let initialBaseURI = typeof self !== 'undefined' && self.location && self.location.origin !== 'null' ? new URL(self.location.origin + self.location.pathname + location.search) : new URL('https://github.com/cfworker');\nexport function dereference(schema, lookup = Object.create(null), baseURI = initialBaseURI, basePointer = '') {\n  if (schema && typeof schema === 'object' && !Array.isArray(schema)) {\n    const id = schema.$id || schema.id;\n    if (id) {\n      const url = new URL(id, baseURI.href);\n      if (url.hash.length > 1) {\n        lookup[url.href] = schema;\n      } else {\n        url.hash = '';\n        if (basePointer === '') {\n          baseURI = url;\n        } else {\n          dereference(schema, lookup, baseURI);\n        }\n      }\n    }\n  } else if (schema !== true && schema !== false) {\n    return lookup;\n  }\n  const schemaURI = baseURI.href + (basePointer ? '#' + basePointer : '');\n  if (lookup[schemaURI] !== undefined) {\n    throw new Error(`Duplicate schema URI \"${schemaURI}\".`);\n  }\n  lookup[schemaURI] = schema;\n  if (schema === true || schema === false) {\n    return lookup;\n  }\n  if (schema.__absolute_uri__ === undefined) {\n    Object.defineProperty(schema, '__absolute_uri__', {\n      enumerable: false,\n      value: schemaURI\n    });\n  }\n  if (schema.$ref && schema.__absolute_ref__ === undefined) {\n    const url = new URL(schema.$ref, baseURI.href);\n    url.hash = url.hash;\n    Object.defineProperty(schema, '__absolute_ref__', {\n      enumerable: false,\n      value: url.href\n    });\n  }\n  if (schema.$recursiveRef && schema.__absolute_recursive_ref__ === undefined) {\n    const url = new URL(schema.$recursiveRef, baseURI.href);\n    url.hash = url.hash;\n    Object.defineProperty(schema, '__absolute_recursive_ref__', {\n      enumerable: false,\n      value: url.href\n    });\n  }\n  if (schema.$anchor) {\n    const url = new URL('#' + schema.$anchor, baseURI.href);\n    lookup[url.href] = schema;\n  }\n  for (let key in schema) {\n    if (ignoredKeyword[key]) {\n      continue;\n    }\n    const keyBase = `${basePointer}/${encodePointer(key)}`;\n    const subSchema = schema[key];\n    if (Array.isArray(subSchema)) {\n      if (schemaArrayKeyword[key]) {\n        const length = subSchema.length;\n        for (let i = 0; i < length; i++) {\n          dereference(subSchema[i], lookup, baseURI, `${keyBase}/${i}`);\n        }\n      }\n    } else if (schemaMapKeyword[key]) {\n      for (let subKey in subSchema) {\n        dereference(subSchema[subKey], lookup, baseURI, `${keyBase}/${encodePointer(subKey)}`);\n      }\n    } else {\n      dereference(subSchema, lookup, baseURI, keyBase);\n    }\n  }\n  return lookup;\n}","map":{"version":3,"names":["encodePointer","schemaKeyword","additionalItems","unevaluatedItems","items","contains","additionalProperties","unevaluatedProperties","propertyNames","not","if","then","else","schemaArrayKeyword","prefixItems","allOf","anyOf","oneOf","schemaMapKeyword","$defs","definitions","properties","patternProperties","dependentSchemas","ignoredKeyword","id","$id","$ref","$schema","$anchor","$vocabulary","$comment","default","enum","const","required","type","maximum","minimum","exclusiveMaximum","exclusiveMinimum","multipleOf","maxLength","minLength","pattern","format","maxItems","minItems","uniqueItems","maxProperties","minProperties","initialBaseURI","self","location","origin","URL","pathname","search","dereference","schema","lookup","Object","create","baseURI","basePointer","Array","isArray","url","href","hash","length","schemaURI","undefined","Error","__absolute_uri__","defineProperty","enumerable","value","__absolute_ref__","$recursiveRef","__absolute_recursive_ref__","key","keyBase","subSchema","i","subKey"],"sources":["/Users/youngchen/Downloads/cs224g-triage/node_modules/@cfworker/json-schema/dist/esm/dereference.js"],"sourcesContent":["import { encodePointer } from './pointer.js';\nexport const schemaKeyword = {\n    additionalItems: true,\n    unevaluatedItems: true,\n    items: true,\n    contains: true,\n    additionalProperties: true,\n    unevaluatedProperties: true,\n    propertyNames: true,\n    not: true,\n    if: true,\n    then: true,\n    else: true\n};\nexport const schemaArrayKeyword = {\n    prefixItems: true,\n    items: true,\n    allOf: true,\n    anyOf: true,\n    oneOf: true\n};\nexport const schemaMapKeyword = {\n    $defs: true,\n    definitions: true,\n    properties: true,\n    patternProperties: true,\n    dependentSchemas: true\n};\nexport const ignoredKeyword = {\n    id: true,\n    $id: true,\n    $ref: true,\n    $schema: true,\n    $anchor: true,\n    $vocabulary: true,\n    $comment: true,\n    default: true,\n    enum: true,\n    const: true,\n    required: true,\n    type: true,\n    maximum: true,\n    minimum: true,\n    exclusiveMaximum: true,\n    exclusiveMinimum: true,\n    multipleOf: true,\n    maxLength: true,\n    minLength: true,\n    pattern: true,\n    format: true,\n    maxItems: true,\n    minItems: true,\n    uniqueItems: true,\n    maxProperties: true,\n    minProperties: true\n};\nexport let initialBaseURI = typeof self !== 'undefined' &&\n    self.location &&\n    self.location.origin !== 'null'\n    ?\n        new URL(self.location.origin + self.location.pathname + location.search)\n    : new URL('https://github.com/cfworker');\nexport function dereference(schema, lookup = Object.create(null), baseURI = initialBaseURI, basePointer = '') {\n    if (schema && typeof schema === 'object' && !Array.isArray(schema)) {\n        const id = schema.$id || schema.id;\n        if (id) {\n            const url = new URL(id, baseURI.href);\n            if (url.hash.length > 1) {\n                lookup[url.href] = schema;\n            }\n            else {\n                url.hash = '';\n                if (basePointer === '') {\n                    baseURI = url;\n                }\n                else {\n                    dereference(schema, lookup, baseURI);\n                }\n            }\n        }\n    }\n    else if (schema !== true && schema !== false) {\n        return lookup;\n    }\n    const schemaURI = baseURI.href + (basePointer ? '#' + basePointer : '');\n    if (lookup[schemaURI] !== undefined) {\n        throw new Error(`Duplicate schema URI \"${schemaURI}\".`);\n    }\n    lookup[schemaURI] = schema;\n    if (schema === true || schema === false) {\n        return lookup;\n    }\n    if (schema.__absolute_uri__ === undefined) {\n        Object.defineProperty(schema, '__absolute_uri__', {\n            enumerable: false,\n            value: schemaURI\n        });\n    }\n    if (schema.$ref && schema.__absolute_ref__ === undefined) {\n        const url = new URL(schema.$ref, baseURI.href);\n        url.hash = url.hash;\n        Object.defineProperty(schema, '__absolute_ref__', {\n            enumerable: false,\n            value: url.href\n        });\n    }\n    if (schema.$recursiveRef && schema.__absolute_recursive_ref__ === undefined) {\n        const url = new URL(schema.$recursiveRef, baseURI.href);\n        url.hash = url.hash;\n        Object.defineProperty(schema, '__absolute_recursive_ref__', {\n            enumerable: false,\n            value: url.href\n        });\n    }\n    if (schema.$anchor) {\n        const url = new URL('#' + schema.$anchor, baseURI.href);\n        lookup[url.href] = schema;\n    }\n    for (let key in schema) {\n        if (ignoredKeyword[key]) {\n            continue;\n        }\n        const keyBase = `${basePointer}/${encodePointer(key)}`;\n        const subSchema = schema[key];\n        if (Array.isArray(subSchema)) {\n            if (schemaArrayKeyword[key]) {\n                const length = subSchema.length;\n                for (let i = 0; i < length; i++) {\n                    dereference(subSchema[i], lookup, baseURI, `${keyBase}/${i}`);\n                }\n            }\n        }\n        else if (schemaMapKeyword[key]) {\n            for (let subKey in subSchema) {\n                dereference(subSchema[subKey], lookup, baseURI, `${keyBase}/${encodePointer(subKey)}`);\n            }\n        }\n        else {\n            dereference(subSchema, lookup, baseURI, keyBase);\n        }\n    }\n    return lookup;\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}