{"ast":null,"code":"import { AIMessage, HumanMessage, isBaseMessage } from \"../messages/index.js\";\nimport { RunnableBinding, RunnableLambda } from \"./base.js\";\nimport { RunnablePassthrough } from \"./passthrough.js\";\n/**\n * Wraps a LCEL chain and manages history. It appends input messages\n * and chain outputs as history, and adds the current history messages to\n * the chain input.\n * @example\n * ```typescript\n * // yarn add @langchain/anthropic @langchain/community @upstash/redis\n *\n * import {\n *   ChatPromptTemplate,\n *   MessagesPlaceholder,\n * } from \"@langchain/core/prompts\";\n * import { ChatAnthropic } from \"@langchain/anthropic\";\n * import { UpstashRedisChatMessageHistory } from \"@langchain/community/stores/message/upstash_redis\";\n * // For demos, you can also use an in-memory store:\n * // import { ChatMessageHistory } from \"langchain/stores/message/in_memory\";\n *\n * const prompt = ChatPromptTemplate.fromMessages([\n *   [\"system\", \"You're an assistant who's good at {ability}\"],\n *   new MessagesPlaceholder(\"history\"),\n *   [\"human\", \"{question}\"],\n * ]);\n *\n * const chain = prompt.pipe(new ChatAnthropic({}));\n *\n * const chainWithHistory = new RunnableWithMessageHistory({\n *   runnable: chain,\n *   getMessageHistory: (sessionId) =>\n *     new UpstashRedisChatMessageHistory({\n *       sessionId,\n *       config: {\n *         url: process.env.UPSTASH_REDIS_REST_URL!,\n *         token: process.env.UPSTASH_REDIS_REST_TOKEN!,\n *       },\n *     }),\n *   inputMessagesKey: \"question\",\n *   historyMessagesKey: \"history\",\n * });\n *\n * const result = await chainWithHistory.invoke(\n *   {\n *     ability: \"math\",\n *     question: \"What does cosine mean?\",\n *   },\n *   {\n *     configurable: {\n *       sessionId: \"some_string_identifying_a_user\",\n *     },\n *   }\n * );\n *\n * const result2 = await chainWithHistory.invoke(\n *   {\n *     ability: \"math\",\n *     question: \"What's its inverse?\",\n *   },\n *   {\n *     configurable: {\n *       sessionId: \"some_string_identifying_a_user\",\n *     },\n *   }\n * );\n * ```\n */\nexport class RunnableWithMessageHistory extends RunnableBinding {\n  constructor(fields) {\n    let historyChain = RunnableLambda.from((input, options) => this._enterHistory(input, options ?? {})).withConfig({\n      runName: \"loadHistory\"\n    });\n    const messagesKey = fields.historyMessagesKey ?? fields.inputMessagesKey;\n    if (messagesKey) {\n      historyChain = RunnablePassthrough.assign({\n        [messagesKey]: historyChain\n      }).withConfig({\n        runName: \"insertHistory\"\n      });\n    }\n    const bound = historyChain.pipe(fields.runnable.withListeners({\n      onEnd: (run, config) => this._exitHistory(run, config ?? {})\n    })).withConfig({\n      runName: \"RunnableWithMessageHistory\"\n    });\n    const config = fields.config ?? {};\n    super({\n      ...fields,\n      config,\n      bound\n    });\n    Object.defineProperty(this, \"runnable\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, \"inputMessagesKey\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, \"outputMessagesKey\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, \"historyMessagesKey\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    Object.defineProperty(this, \"getMessageHistory\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    this.runnable = fields.runnable;\n    this.getMessageHistory = fields.getMessageHistory;\n    this.inputMessagesKey = fields.inputMessagesKey;\n    this.outputMessagesKey = fields.outputMessagesKey;\n    this.historyMessagesKey = fields.historyMessagesKey;\n  }\n  _getInputMessages(\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  inputValue) {\n    let parsedInputValue;\n    if (typeof inputValue === \"object\" && !Array.isArray(inputValue) && !isBaseMessage(inputValue)) {\n      let key;\n      if (this.inputMessagesKey) {\n        key = this.inputMessagesKey;\n      } else if (Object.keys(inputValue).length === 1) {\n        key = Object.keys(inputValue)[0];\n      } else {\n        key = \"input\";\n      }\n      if (Array.isArray(inputValue[key]) && Array.isArray(inputValue[key][0])) {\n        parsedInputValue = inputValue[key][0];\n      } else {\n        parsedInputValue = inputValue[key];\n      }\n    } else {\n      parsedInputValue = inputValue;\n    }\n    if (typeof parsedInputValue === \"string\") {\n      return [new HumanMessage(parsedInputValue)];\n    } else if (Array.isArray(parsedInputValue)) {\n      return parsedInputValue;\n    } else if (isBaseMessage(parsedInputValue)) {\n      return [parsedInputValue];\n    } else {\n      throw new Error(`Expected a string, BaseMessage, or array of BaseMessages.\\nGot ${JSON.stringify(parsedInputValue, null, 2)}`);\n    }\n  }\n  _getOutputMessages(\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  outputValue) {\n    let parsedOutputValue;\n    if (!Array.isArray(outputValue) && !isBaseMessage(outputValue) && typeof outputValue !== \"string\") {\n      let key;\n      if (this.outputMessagesKey !== undefined) {\n        key = this.outputMessagesKey;\n      } else if (Object.keys(outputValue).length === 1) {\n        key = Object.keys(outputValue)[0];\n      } else {\n        key = \"output\";\n      }\n      // If you are wrapping a chat model directly\n      // The output is actually this weird generations object\n      if (outputValue.generations !== undefined) {\n        parsedOutputValue = outputValue.generations[0][0].message;\n      } else {\n        parsedOutputValue = outputValue[key];\n      }\n    } else {\n      parsedOutputValue = outputValue;\n    }\n    if (typeof parsedOutputValue === \"string\") {\n      return [new AIMessage(parsedOutputValue)];\n    } else if (Array.isArray(parsedOutputValue)) {\n      return parsedOutputValue;\n    } else if (isBaseMessage(parsedOutputValue)) {\n      return [parsedOutputValue];\n    } else {\n      throw new Error(`Expected a string, BaseMessage, or array of BaseMessages. Received: ${JSON.stringify(parsedOutputValue, null, 2)}`);\n    }\n  }\n  async _enterHistory(\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  input, kwargs) {\n    const history = kwargs?.configurable?.messageHistory;\n    const messages = await history.getMessages();\n    if (this.historyMessagesKey === undefined) {\n      return messages.concat(this._getInputMessages(input));\n    }\n    return messages;\n  }\n  async _exitHistory(run, config) {\n    const history = config.configurable?.messageHistory;\n    // Get input messages\n    let inputs;\n    // Chat model inputs are nested arrays\n    if (Array.isArray(run.inputs) && Array.isArray(run.inputs[0])) {\n      inputs = run.inputs[0];\n    } else {\n      inputs = run.inputs;\n    }\n    let inputMessages = this._getInputMessages(inputs);\n    // If historic messages were prepended to the input messages, remove them to\n    // avoid adding duplicate messages to history.\n    if (this.historyMessagesKey === undefined) {\n      const existingMessages = await history.getMessages();\n      inputMessages = inputMessages.slice(existingMessages.length);\n    }\n    // Get output messages\n    const outputValue = run.outputs;\n    if (!outputValue) {\n      throw new Error(`Output values from 'Run' undefined. Run: ${JSON.stringify(run, null, 2)}`);\n    }\n    const outputMessages = this._getOutputMessages(outputValue);\n    await history.addMessages([...inputMessages, ...outputMessages]);\n  }\n  async _mergeConfig(...configs) {\n    const config = await super._mergeConfig(...configs);\n    // Extract sessionId\n    if (!config.configurable || !config.configurable.sessionId) {\n      const exampleInput = {\n        [this.inputMessagesKey ?? \"input\"]: \"foo\"\n      };\n      const exampleConfig = {\n        configurable: {\n          sessionId: \"123\"\n        }\n      };\n      throw new Error(`sessionId is required. Pass it in as part of the config argument to .invoke() or .stream()\\n` + `eg. chain.invoke(${JSON.stringify(exampleInput)}, ${JSON.stringify(exampleConfig)})`);\n    }\n    // attach messageHistory\n    const {\n      sessionId\n    } = config.configurable;\n    config.configurable.messageHistory = await this.getMessageHistory(sessionId);\n    return config;\n  }\n}","map":{"version":3,"names":["AIMessage","HumanMessage","isBaseMessage","RunnableBinding","RunnableLambda","RunnablePassthrough","RunnableWithMessageHistory","constructor","fields","historyChain","from","input","options","_enterHistory","withConfig","runName","messagesKey","historyMessagesKey","inputMessagesKey","assign","bound","pipe","runnable","withListeners","onEnd","run","config","_exitHistory","Object","defineProperty","enumerable","configurable","writable","value","getMessageHistory","outputMessagesKey","_getInputMessages","inputValue","parsedInputValue","Array","isArray","key","keys","length","Error","JSON","stringify","_getOutputMessages","outputValue","parsedOutputValue","undefined","generations","message","kwargs","history","messageHistory","messages","getMessages","concat","inputs","inputMessages","existingMessages","slice","outputs","outputMessages","addMessages","_mergeConfig","configs","sessionId","exampleInput","exampleConfig"],"sources":["/Users/youngchen/Downloads/cs224g-triage/node_modules/@langchain/core/dist/runnables/history.js"],"sourcesContent":["import { AIMessage, HumanMessage, isBaseMessage, } from \"../messages/index.js\";\nimport { RunnableBinding, RunnableLambda, } from \"./base.js\";\nimport { RunnablePassthrough } from \"./passthrough.js\";\n/**\n * Wraps a LCEL chain and manages history. It appends input messages\n * and chain outputs as history, and adds the current history messages to\n * the chain input.\n * @example\n * ```typescript\n * // yarn add @langchain/anthropic @langchain/community @upstash/redis\n *\n * import {\n *   ChatPromptTemplate,\n *   MessagesPlaceholder,\n * } from \"@langchain/core/prompts\";\n * import { ChatAnthropic } from \"@langchain/anthropic\";\n * import { UpstashRedisChatMessageHistory } from \"@langchain/community/stores/message/upstash_redis\";\n * // For demos, you can also use an in-memory store:\n * // import { ChatMessageHistory } from \"langchain/stores/message/in_memory\";\n *\n * const prompt = ChatPromptTemplate.fromMessages([\n *   [\"system\", \"You're an assistant who's good at {ability}\"],\n *   new MessagesPlaceholder(\"history\"),\n *   [\"human\", \"{question}\"],\n * ]);\n *\n * const chain = prompt.pipe(new ChatAnthropic({}));\n *\n * const chainWithHistory = new RunnableWithMessageHistory({\n *   runnable: chain,\n *   getMessageHistory: (sessionId) =>\n *     new UpstashRedisChatMessageHistory({\n *       sessionId,\n *       config: {\n *         url: process.env.UPSTASH_REDIS_REST_URL!,\n *         token: process.env.UPSTASH_REDIS_REST_TOKEN!,\n *       },\n *     }),\n *   inputMessagesKey: \"question\",\n *   historyMessagesKey: \"history\",\n * });\n *\n * const result = await chainWithHistory.invoke(\n *   {\n *     ability: \"math\",\n *     question: \"What does cosine mean?\",\n *   },\n *   {\n *     configurable: {\n *       sessionId: \"some_string_identifying_a_user\",\n *     },\n *   }\n * );\n *\n * const result2 = await chainWithHistory.invoke(\n *   {\n *     ability: \"math\",\n *     question: \"What's its inverse?\",\n *   },\n *   {\n *     configurable: {\n *       sessionId: \"some_string_identifying_a_user\",\n *     },\n *   }\n * );\n * ```\n */\nexport class RunnableWithMessageHistory extends RunnableBinding {\n    constructor(fields) {\n        let historyChain = RunnableLambda.from((input, options) => this._enterHistory(input, options ?? {})).withConfig({ runName: \"loadHistory\" });\n        const messagesKey = fields.historyMessagesKey ?? fields.inputMessagesKey;\n        if (messagesKey) {\n            historyChain = RunnablePassthrough.assign({\n                [messagesKey]: historyChain,\n            }).withConfig({ runName: \"insertHistory\" });\n        }\n        const bound = historyChain\n            .pipe(fields.runnable.withListeners({\n            onEnd: (run, config) => this._exitHistory(run, config ?? {}),\n        }))\n            .withConfig({ runName: \"RunnableWithMessageHistory\" });\n        const config = fields.config ?? {};\n        super({\n            ...fields,\n            config,\n            bound,\n        });\n        Object.defineProperty(this, \"runnable\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"inputMessagesKey\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"outputMessagesKey\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"historyMessagesKey\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"getMessageHistory\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        this.runnable = fields.runnable;\n        this.getMessageHistory = fields.getMessageHistory;\n        this.inputMessagesKey = fields.inputMessagesKey;\n        this.outputMessagesKey = fields.outputMessagesKey;\n        this.historyMessagesKey = fields.historyMessagesKey;\n    }\n    _getInputMessages(\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    inputValue) {\n        let parsedInputValue;\n        if (typeof inputValue === \"object\" &&\n            !Array.isArray(inputValue) &&\n            !isBaseMessage(inputValue)) {\n            let key;\n            if (this.inputMessagesKey) {\n                key = this.inputMessagesKey;\n            }\n            else if (Object.keys(inputValue).length === 1) {\n                key = Object.keys(inputValue)[0];\n            }\n            else {\n                key = \"input\";\n            }\n            if (Array.isArray(inputValue[key]) && Array.isArray(inputValue[key][0])) {\n                parsedInputValue = inputValue[key][0];\n            }\n            else {\n                parsedInputValue = inputValue[key];\n            }\n        }\n        else {\n            parsedInputValue = inputValue;\n        }\n        if (typeof parsedInputValue === \"string\") {\n            return [new HumanMessage(parsedInputValue)];\n        }\n        else if (Array.isArray(parsedInputValue)) {\n            return parsedInputValue;\n        }\n        else if (isBaseMessage(parsedInputValue)) {\n            return [parsedInputValue];\n        }\n        else {\n            throw new Error(`Expected a string, BaseMessage, or array of BaseMessages.\\nGot ${JSON.stringify(parsedInputValue, null, 2)}`);\n        }\n    }\n    _getOutputMessages(\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    outputValue) {\n        let parsedOutputValue;\n        if (!Array.isArray(outputValue) &&\n            !isBaseMessage(outputValue) &&\n            typeof outputValue !== \"string\") {\n            let key;\n            if (this.outputMessagesKey !== undefined) {\n                key = this.outputMessagesKey;\n            }\n            else if (Object.keys(outputValue).length === 1) {\n                key = Object.keys(outputValue)[0];\n            }\n            else {\n                key = \"output\";\n            }\n            // If you are wrapping a chat model directly\n            // The output is actually this weird generations object\n            if (outputValue.generations !== undefined) {\n                parsedOutputValue = outputValue.generations[0][0].message;\n            }\n            else {\n                parsedOutputValue = outputValue[key];\n            }\n        }\n        else {\n            parsedOutputValue = outputValue;\n        }\n        if (typeof parsedOutputValue === \"string\") {\n            return [new AIMessage(parsedOutputValue)];\n        }\n        else if (Array.isArray(parsedOutputValue)) {\n            return parsedOutputValue;\n        }\n        else if (isBaseMessage(parsedOutputValue)) {\n            return [parsedOutputValue];\n        }\n        else {\n            throw new Error(`Expected a string, BaseMessage, or array of BaseMessages. Received: ${JSON.stringify(parsedOutputValue, null, 2)}`);\n        }\n    }\n    async _enterHistory(\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    input, kwargs) {\n        const history = kwargs?.configurable?.messageHistory;\n        const messages = await history.getMessages();\n        if (this.historyMessagesKey === undefined) {\n            return messages.concat(this._getInputMessages(input));\n        }\n        return messages;\n    }\n    async _exitHistory(run, config) {\n        const history = config.configurable?.messageHistory;\n        // Get input messages\n        let inputs;\n        // Chat model inputs are nested arrays\n        if (Array.isArray(run.inputs) && Array.isArray(run.inputs[0])) {\n            inputs = run.inputs[0];\n        }\n        else {\n            inputs = run.inputs;\n        }\n        let inputMessages = this._getInputMessages(inputs);\n        // If historic messages were prepended to the input messages, remove them to\n        // avoid adding duplicate messages to history.\n        if (this.historyMessagesKey === undefined) {\n            const existingMessages = await history.getMessages();\n            inputMessages = inputMessages.slice(existingMessages.length);\n        }\n        // Get output messages\n        const outputValue = run.outputs;\n        if (!outputValue) {\n            throw new Error(`Output values from 'Run' undefined. Run: ${JSON.stringify(run, null, 2)}`);\n        }\n        const outputMessages = this._getOutputMessages(outputValue);\n        await history.addMessages([...inputMessages, ...outputMessages]);\n    }\n    async _mergeConfig(...configs) {\n        const config = await super._mergeConfig(...configs);\n        // Extract sessionId\n        if (!config.configurable || !config.configurable.sessionId) {\n            const exampleInput = {\n                [this.inputMessagesKey ?? \"input\"]: \"foo\",\n            };\n            const exampleConfig = { configurable: { sessionId: \"123\" } };\n            throw new Error(`sessionId is required. Pass it in as part of the config argument to .invoke() or .stream()\\n` +\n                `eg. chain.invoke(${JSON.stringify(exampleInput)}, ${JSON.stringify(exampleConfig)})`);\n        }\n        // attach messageHistory\n        const { sessionId } = config.configurable;\n        config.configurable.messageHistory = await this.getMessageHistory(sessionId);\n        return config;\n    }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}