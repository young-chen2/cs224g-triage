{"ast":null,"code":"import { concat } from \"../utils/stream.js\";\nimport { Runnable, RunnableAssign, RunnableMap } from \"./base.js\";\nimport { ensureConfig } from \"./config.js\";\n/**\n * A runnable to passthrough inputs unchanged or with additional keys.\n *\n * This runnable behaves almost like the identity function, except that it\n * can be configured to add additional keys to the output, if the input is\n * an object.\n *\n * The example below demonstrates how to use `RunnablePassthrough to\n * passthrough the input from the `.invoke()`\n *\n * @example\n * ```typescript\n * const chain = RunnableSequence.from([\n *   {\n *     question: new RunnablePassthrough(),\n *     context: async () => loadContextFromStore(),\n *   },\n *   prompt,\n *   llm,\n *   outputParser,\n * ]);\n * const response = await chain.invoke(\n *   \"I can pass a single string instead of an object since I'm using `RunnablePassthrough`.\"\n * );\n * ```\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport class RunnablePassthrough extends Runnable {\n  static lc_name() {\n    return \"RunnablePassthrough\";\n  }\n  constructor(fields) {\n    super(fields);\n    Object.defineProperty(this, \"lc_namespace\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: [\"langchain_core\", \"runnables\"]\n    });\n    Object.defineProperty(this, \"lc_serializable\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: true\n    });\n    Object.defineProperty(this, \"func\", {\n      enumerable: true,\n      configurable: true,\n      writable: true,\n      value: void 0\n    });\n    if (fields) {\n      this.func = fields.func;\n    }\n  }\n  async invoke(input, options) {\n    const config = ensureConfig(options);\n    if (this.func) {\n      await this.func(input, config);\n    }\n    return this._callWithConfig(input => Promise.resolve(input), input, config);\n  }\n  async *transform(generator, options) {\n    const config = ensureConfig(options);\n    let finalOutput;\n    let finalOutputSupported = true;\n    for await (const chunk of this._transformStreamWithConfig(generator, input => input, config)) {\n      yield chunk;\n      if (finalOutputSupported) {\n        if (finalOutput === undefined) {\n          finalOutput = chunk;\n        } else {\n          try {\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n            finalOutput = concat(finalOutput, chunk);\n          } catch {\n            finalOutput = undefined;\n            finalOutputSupported = false;\n          }\n        }\n      }\n    }\n    if (this.func && finalOutput !== undefined) {\n      await this.func(finalOutput, config);\n    }\n  }\n  /**\n   * A runnable that assigns key-value pairs to the input.\n   *\n   * The example below shows how you could use it with an inline function.\n   *\n   * @example\n   * ```typescript\n   * const prompt =\n   *   PromptTemplate.fromTemplate(`Write a SQL query to answer the question using the following schema: {schema}\n   * Question: {question}\n   * SQL Query:`);\n   *\n   * // The `RunnablePassthrough.assign()` is used here to passthrough the input from the `.invoke()`\n   * // call (in this example it's the question), along with any inputs passed to the `.assign()` method.\n   * // In this case, we're passing the schema.\n   * const sqlQueryGeneratorChain = RunnableSequence.from([\n   *   RunnablePassthrough.assign({\n   *     schema: async () => db.getTableInfo(),\n   *   }),\n   *   prompt,\n   *   new ChatOpenAI({}).bind({ stop: [\"\\nSQLResult:\"] }),\n   *   new StringOutputParser(),\n   * ]);\n   * const result = await sqlQueryGeneratorChain.invoke({\n   *   question: \"How many employees are there?\",\n   * });\n   * ```\n   */\n  static assign(mapping) {\n    return new RunnableAssign(new RunnableMap({\n      steps: mapping\n    }));\n  }\n}","map":{"version":3,"names":["concat","Runnable","RunnableAssign","RunnableMap","ensureConfig","RunnablePassthrough","lc_name","constructor","fields","Object","defineProperty","enumerable","configurable","writable","value","func","invoke","input","options","config","_callWithConfig","Promise","resolve","transform","generator","finalOutput","finalOutputSupported","chunk","_transformStreamWithConfig","undefined","assign","mapping","steps"],"sources":["/Users/youngchen/Downloads/cs224g-triage/node_modules/@langchain/core/dist/runnables/passthrough.js"],"sourcesContent":["import { concat } from \"../utils/stream.js\";\nimport { Runnable, RunnableAssign, RunnableMap, } from \"./base.js\";\nimport { ensureConfig } from \"./config.js\";\n/**\n * A runnable to passthrough inputs unchanged or with additional keys.\n *\n * This runnable behaves almost like the identity function, except that it\n * can be configured to add additional keys to the output, if the input is\n * an object.\n *\n * The example below demonstrates how to use `RunnablePassthrough to\n * passthrough the input from the `.invoke()`\n *\n * @example\n * ```typescript\n * const chain = RunnableSequence.from([\n *   {\n *     question: new RunnablePassthrough(),\n *     context: async () => loadContextFromStore(),\n *   },\n *   prompt,\n *   llm,\n *   outputParser,\n * ]);\n * const response = await chain.invoke(\n *   \"I can pass a single string instead of an object since I'm using `RunnablePassthrough`.\"\n * );\n * ```\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport class RunnablePassthrough extends Runnable {\n    static lc_name() {\n        return \"RunnablePassthrough\";\n    }\n    constructor(fields) {\n        super(fields);\n        Object.defineProperty(this, \"lc_namespace\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: [\"langchain_core\", \"runnables\"]\n        });\n        Object.defineProperty(this, \"lc_serializable\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: true\n        });\n        Object.defineProperty(this, \"func\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        if (fields) {\n            this.func = fields.func;\n        }\n    }\n    async invoke(input, options) {\n        const config = ensureConfig(options);\n        if (this.func) {\n            await this.func(input, config);\n        }\n        return this._callWithConfig((input) => Promise.resolve(input), input, config);\n    }\n    async *transform(generator, options) {\n        const config = ensureConfig(options);\n        let finalOutput;\n        let finalOutputSupported = true;\n        for await (const chunk of this._transformStreamWithConfig(generator, (input) => input, config)) {\n            yield chunk;\n            if (finalOutputSupported) {\n                if (finalOutput === undefined) {\n                    finalOutput = chunk;\n                }\n                else {\n                    try {\n                        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n                        finalOutput = concat(finalOutput, chunk);\n                    }\n                    catch {\n                        finalOutput = undefined;\n                        finalOutputSupported = false;\n                    }\n                }\n            }\n        }\n        if (this.func && finalOutput !== undefined) {\n            await this.func(finalOutput, config);\n        }\n    }\n    /**\n     * A runnable that assigns key-value pairs to the input.\n     *\n     * The example below shows how you could use it with an inline function.\n     *\n     * @example\n     * ```typescript\n     * const prompt =\n     *   PromptTemplate.fromTemplate(`Write a SQL query to answer the question using the following schema: {schema}\n     * Question: {question}\n     * SQL Query:`);\n     *\n     * // The `RunnablePassthrough.assign()` is used here to passthrough the input from the `.invoke()`\n     * // call (in this example it's the question), along with any inputs passed to the `.assign()` method.\n     * // In this case, we're passing the schema.\n     * const sqlQueryGeneratorChain = RunnableSequence.from([\n     *   RunnablePassthrough.assign({\n     *     schema: async () => db.getTableInfo(),\n     *   }),\n     *   prompt,\n     *   new ChatOpenAI({}).bind({ stop: [\"\\nSQLResult:\"] }),\n     *   new StringOutputParser(),\n     * ]);\n     * const result = await sqlQueryGeneratorChain.invoke({\n     *   question: \"How many employees are there?\",\n     * });\n     * ```\n     */\n    static assign(mapping) {\n        return new RunnableAssign(new RunnableMap({ steps: mapping }));\n    }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}