{"ast":null,"code":"/**\n * Most browsers don't yet have async iterable support for ReadableStream,\n * and Node has a very different way of reading bytes from its \"ReadableStream\".\n *\n * This polyfill was pulled from https://github.com/MattiasBuelens/web-streams-polyfill/pull/122#issuecomment-1627354490\n */\nexport function ReadableStreamToAsyncIterable(stream) {\n  if (stream[Symbol.asyncIterator]) return stream;\n  const reader = stream.getReader();\n  return {\n    async next() {\n      try {\n        const result = await reader.read();\n        if (result?.done) reader.releaseLock(); // release lock when stream becomes closed\n        return result;\n      } catch (e) {\n        reader.releaseLock(); // release lock when stream becomes errored\n        throw e;\n      }\n    },\n    async return() {\n      const cancelPromise = reader.cancel();\n      reader.releaseLock();\n      await cancelPromise;\n      return {\n        done: true,\n        value: undefined\n      };\n    },\n    [Symbol.asyncIterator]() {\n      return this;\n    }\n  };\n}","map":{"version":3,"names":["ReadableStreamToAsyncIterable","stream","Symbol","asyncIterator","reader","getReader","next","result","read","done","releaseLock","e","return","cancelPromise","cancel","value","undefined"],"sources":["/Users/youngchen/Downloads/cs224g-triage/node_modules/openai/src/internal/stream-utils.ts"],"sourcesContent":["/**\n * Most browsers don't yet have async iterable support for ReadableStream,\n * and Node has a very different way of reading bytes from its \"ReadableStream\".\n *\n * This polyfill was pulled from https://github.com/MattiasBuelens/web-streams-polyfill/pull/122#issuecomment-1627354490\n */\nexport function ReadableStreamToAsyncIterable<T>(stream: any): AsyncIterableIterator<T> {\n  if (stream[Symbol.asyncIterator]) return stream;\n\n  const reader = stream.getReader();\n  return {\n    async next() {\n      try {\n        const result = await reader.read();\n        if (result?.done) reader.releaseLock(); // release lock when stream becomes closed\n        return result;\n      } catch (e) {\n        reader.releaseLock(); // release lock when stream becomes errored\n        throw e;\n      }\n    },\n    async return() {\n      const cancelPromise = reader.cancel();\n      reader.releaseLock();\n      await cancelPromise;\n      return { done: true, value: undefined };\n    },\n    [Symbol.asyncIterator]() {\n      return this;\n    },\n  };\n}\n"],"mappings":"AAAA;;;;;;AAMA,OAAM,SAAUA,6BAA6BA,CAAIC,MAAW;EAC1D,IAAIA,MAAM,CAACC,MAAM,CAACC,aAAa,CAAC,EAAE,OAAOF,MAAM;EAE/C,MAAMG,MAAM,GAAGH,MAAM,CAACI,SAAS,EAAE;EACjC,OAAO;IACL,MAAMC,IAAIA,CAAA;MACR,IAAI;QACF,MAAMC,MAAM,GAAG,MAAMH,MAAM,CAACI,IAAI,EAAE;QAClC,IAAID,MAAM,EAAEE,IAAI,EAAEL,MAAM,CAACM,WAAW,EAAE,CAAC,CAAC;QACxC,OAAOH,MAAM;OACd,CAAC,OAAOI,CAAC,EAAE;QACVP,MAAM,CAACM,WAAW,EAAE,CAAC,CAAC;QACtB,MAAMC,CAAC;;IAEX,CAAC;IACD,MAAMC,MAAMA,CAAA;MACV,MAAMC,aAAa,GAAGT,MAAM,CAACU,MAAM,EAAE;MACrCV,MAAM,CAACM,WAAW,EAAE;MACpB,MAAMG,aAAa;MACnB,OAAO;QAAEJ,IAAI,EAAE,IAAI;QAAEM,KAAK,EAAEC;MAAS,CAAE;IACzC,CAAC;IACD,CAACd,MAAM,CAACC,aAAa,IAAC;MACpB,OAAO,IAAI;IACb;GACD;AACH","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}